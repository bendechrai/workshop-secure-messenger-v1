{"version":3,"file":"polyfill.umd.min.js","sources":["../src/stub/number-isinteger.js","../src/stub/symbol.js","../src/utils.js","../src/stub/number-isnan.js","../spec/reference-implementation/lib/helpers.js","../src/stub/assert.js","../spec/reference-implementation/lib/utils.js","../spec/reference-implementation/lib/queue-with-sizes.js","../spec/reference-implementation/lib/writable-stream.js","../spec/reference-implementation/lib/readable-stream.js","../spec/reference-implementation/lib/byte-length-queuing-strategy.js","../spec/reference-implementation/lib/count-queuing-strategy.js","../spec/reference-implementation/lib/transform-stream.js","../src/polyfill.js"],"sourcesContent":["// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\nexport default NumberIsInteger;\n","const FakeSymbol = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n  Symbol :\n  description => `Symbol(${description})`;\n\nexport default FakeSymbol;\n","export function noop() {\n  // do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\r\n\r\nfunction IsPropertyKey(argument) {\r\n  return typeof argument === 'string' || typeof argument === 'symbol';\r\n}\r\n\r\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\r\n\r\nexports.createDataProperty = (o, p, v) => {\r\n  assert(exports.typeIsObject(o));\r\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\r\n};\r\n\r\nexports.createArrayFromList = elements => {\r\n  // We use arrays to represent lists, so this is basically a no-op.\r\n  // Do a slice though just in case we happen to depend on the unique-ness.\r\n  return elements.slice();\r\n};\r\n\r\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\r\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\r\n};\r\n\r\nexports.CreateIterResultObject = (value, done) => {\r\n  assert(typeof done === 'boolean');\r\n  const obj = {};\r\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\r\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\r\n  return obj;\r\n};\r\n\r\nexports.IsFiniteNonNegativeNumber = v => {\r\n  if (exports.IsNonNegativeNumber(v) === false) {\r\n    return false;\r\n  }\r\n\r\n  if (v === Infinity) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexports.IsNonNegativeNumber = v => {\r\n  if (typeof v !== 'number') {\r\n    return false;\r\n  }\r\n\r\n  if (Number.isNaN(v)) {\r\n    return false;\r\n  }\r\n\r\n  if (v < 0) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction Call(F, V, args) {\r\n  if (typeof F !== 'function') {\r\n    throw new TypeError('Argument is not a function');\r\n  }\r\n\r\n  return Function.prototype.apply.call(F, V, args);\r\n}\r\n\r\nexports.Call = Call;\r\n\r\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\r\n  assert(underlyingObject !== undefined);\r\n  assert(IsPropertyKey(methodName));\r\n  assert(algoArgCount === 0 || algoArgCount === 1);\r\n  assert(Array.isArray(extraArgs));\r\n  const method = underlyingObject[methodName];\r\n  if (method !== undefined) {\r\n    if (typeof method !== 'function') {\r\n      throw new TypeError(`${method} is not a method`);\r\n    }\r\n    switch (algoArgCount) {\r\n      case 0: {\r\n        return () => {\r\n          return PromiseCall(method, underlyingObject, extraArgs);\r\n        };\r\n      }\r\n\r\n      case 1: {\r\n        return arg => {\r\n          const fullArgs = [arg].concat(extraArgs);\r\n          return PromiseCall(method, underlyingObject, fullArgs);\r\n        };\r\n      }\r\n    }\r\n  }\r\n  return () => Promise.resolve();\r\n};\r\n\r\nexports.InvokeOrNoop = (O, P, args) => {\r\n  assert(O !== undefined);\r\n  assert(IsPropertyKey(P));\r\n  assert(Array.isArray(args));\r\n\r\n  const method = O[P];\r\n  if (method === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  return Call(method, O, args);\r\n};\r\n\r\nfunction PromiseCall(F, V, args) {\r\n  assert(typeof F === 'function');\r\n  assert(V !== undefined);\r\n  assert(Array.isArray(args));\r\n  try {\r\n    return Promise.resolve(Call(F, V, args));\r\n  } catch (value) {\r\n    return Promise.reject(value);\r\n  }\r\n}\r\n\r\nexports.PromiseCall = PromiseCall;\r\n\r\n// Not implemented correctly\r\nexports.TransferArrayBuffer = O => {\r\n  assert(!exports.IsDetachedBuffer(O));\r\n  const transferredIshVersion = O.slice();\r\n\r\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\r\n  // ArrayBuffer and checking if its byteLength starts returning 0.\r\n  Object.defineProperty(O, 'byteLength', {\r\n    get() {\r\n      return 0;\r\n    }\r\n  });\r\n  O[isFakeDetached] = true;\r\n\r\n  return transferredIshVersion;\r\n};\r\n\r\n// Not implemented correctly\r\nexports.IsDetachedBuffer = O => {\r\n  return isFakeDetached in O;\r\n};\r\n\r\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\r\n  highWaterMark = Number(highWaterMark);\r\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\r\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\r\n  }\r\n\r\n  return highWaterMark;\r\n};\r\n\r\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\r\n  if (size === undefined) {\r\n    return () => 1;\r\n  }\r\n  if (typeof size !== 'function') {\r\n    throw new TypeError('size property of a queuing strategy must be a function');\r\n  }\r\n  return chunk => size(chunk);\r\n};\r\n","import { noop } from '../utils';\n\nexport default function assert() {\n  // do nothing\n}\n\nassert.AssertionError = noop;\n","'use strict';\r\nconst assert = require('assert');\r\n\r\nexports.rethrowAssertionErrorRejection = e => {\r\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\r\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\r\n  // expect any errors, but assertion errors are always problematic.\r\n  if (e && e instanceof assert.AssertionError) {\r\n    setTimeout(() => {\r\n      throw e;\r\n    }, 0);\r\n  }\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\r\n\r\nexports.DequeueValue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n  assert(container._queue.length > 0);\r\n\r\n  const pair = container._queue.shift();\r\n  container._queueTotalSize -= pair.size;\r\n  if (container._queueTotalSize < 0) {\r\n    container._queueTotalSize = 0;\r\n  }\r\n\r\n  return pair.value;\r\n};\r\n\r\nexports.EnqueueValueWithSize = (container, value, size) => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n\r\n  size = Number(size);\r\n  if (!IsFiniteNonNegativeNumber(size)) {\r\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\r\n  }\r\n\r\n  container._queue.push({ value, size });\r\n  container._queueTotalSize += size;\r\n};\r\n\r\nexports.PeekQueueValue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n  assert(container._queue.length > 0);\r\n\r\n  const pair = container._queue[0];\r\n  return pair.value;\r\n};\r\n\r\nexports.ResetQueue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n\r\n  container._queue = [];\r\n  container._queueTotalSize = 0;\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\r\n// and do not appear in the standard text.\r\nconst verbose = require('debug')('streams:writable-stream:verbose');\r\n\r\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\r\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\r\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\r\n\r\nconst AbortSteps = Symbol('[[AbortSteps]]');\r\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\r\n\r\nclass WritableStream {\r\n  constructor(underlyingSink = {}, { size, highWaterMark = 1 } = {}) {\r\n    InitializeWritableStream(this);\r\n\r\n    const type = underlyingSink.type;\r\n\r\n    if (type !== undefined) {\r\n      throw new RangeError('Invalid type is specified');\r\n    }\r\n\r\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\r\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\r\n  }\r\n\r\n  get locked() {\r\n    if (IsWritableStream(this) === false) {\r\n      throw streamBrandCheckException('locked');\r\n    }\r\n\r\n    return IsWritableStreamLocked(this);\r\n  }\r\n\r\n  abort(reason) {\r\n    if (IsWritableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('abort'));\r\n    }\r\n\r\n    if (IsWritableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\r\n    }\r\n\r\n    return WritableStreamAbort(this, reason);\r\n  }\r\n\r\n  getWriter() {\r\n    if (IsWritableStream(this) === false) {\r\n      throw streamBrandCheckException('getWriter');\r\n    }\r\n\r\n    return AcquireWritableStreamDefaultWriter(this);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  AcquireWritableStreamDefaultWriter,\r\n  CreateWritableStream,\r\n  IsWritableStream,\r\n  IsWritableStreamLocked,\r\n  WritableStream,\r\n  WritableStreamAbort,\r\n  WritableStreamDefaultControllerErrorIfNeeded,\r\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\r\n  WritableStreamDefaultWriterRelease,\r\n  WritableStreamDefaultWriterWrite,\r\n  WritableStreamCloseQueuedOrInFlight\r\n};\r\n\r\n// Abstract operations for the WritableStream.\r\n\r\nfunction AcquireWritableStreamDefaultWriter(stream) {\r\n  return new WritableStreamDefaultWriter(stream);\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\r\n                              sizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n\r\n  const stream = Object.create(WritableStream.prototype);\r\n  InitializeWritableStream(stream);\r\n\r\n  const controller = Object.create(WritableStreamDefaultController.prototype);\r\n\r\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\r\n  return stream;\r\n}\r\n\r\nfunction InitializeWritableStream(stream) {\r\n  stream._state = 'writable';\r\n\r\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\r\n  // 'erroring' or 'errored'. May be set to an undefined value.\r\n  stream._storedError = undefined;\r\n\r\n  stream._writer = undefined;\r\n\r\n  // Initialize to undefined first because the constructor of the controller checks this\r\n  // variable to validate the caller.\r\n  stream._writableStreamController = undefined;\r\n\r\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\r\n  // producer without waiting for the queued writes to finish.\r\n  stream._writeRequests = [];\r\n\r\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\r\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\r\n  stream._inFlightWriteRequest = undefined;\r\n\r\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\r\n  // has been detached.\r\n  stream._closeRequest = undefined;\r\n\r\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\r\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\r\n  stream._pendingAbortRequest = undefined;\r\n\r\n  // The backpressure signal set by the controller.\r\n  stream._backpressure = false;\r\n}\r\n\r\nfunction IsWritableStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsWritableStreamLocked(stream) {\r\n  assert(IsWritableStream(stream) === true);\r\n\r\n  if (stream._writer === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamAbort(stream, reason) {\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return Promise.resolve(undefined);\r\n  }\r\n  if (stream._pendingAbortRequest !== undefined) {\r\n    return stream._pendingAbortRequest._promise;\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  let wasAlreadyErroring = false;\r\n  if (state === 'erroring') {\r\n    wasAlreadyErroring = true;\r\n    // reason will not be used, so don't keep a reference to it.\r\n    reason = undefined;\r\n  }\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    stream._pendingAbortRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject,\r\n      _reason: reason,\r\n      _wasAlreadyErroring: wasAlreadyErroring\r\n    };\r\n  });\r\n  stream._pendingAbortRequest._promise = promise;\r\n\r\n  if (wasAlreadyErroring === false) {\r\n    WritableStreamStartErroring(stream, reason);\r\n  }\r\n\r\n  return promise;\r\n}\r\n\r\n// WritableStream API exposed for controllers.\r\n\r\nfunction WritableStreamAddWriteRequest(stream) {\r\n  assert(IsWritableStreamLocked(stream) === true);\r\n  assert(stream._state === 'writable');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const writeRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._writeRequests.push(writeRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction WritableStreamDealWithRejection(stream, error) {\r\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\r\n  const state = stream._state;\r\n\r\n  if (state === 'writable') {\r\n    WritableStreamStartErroring(stream, error);\r\n    return;\r\n  }\r\n\r\n  assert(state === 'erroring');\r\n  WritableStreamFinishErroring(stream);\r\n}\r\n\r\nfunction WritableStreamStartErroring(stream, reason) {\r\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\r\n  assert(stream._storedError === undefined);\r\n  assert(stream._state === 'writable');\r\n\r\n  const controller = stream._writableStreamController;\r\n  assert(controller !== undefined);\r\n\r\n  stream._state = 'erroring';\r\n  stream._storedError = reason;\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\r\n  }\r\n\r\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\r\n    WritableStreamFinishErroring(stream);\r\n  }\r\n}\r\n\r\nfunction WritableStreamFinishErroring(stream) {\r\n  verbose('WritableStreamFinishErroring()');\r\n  assert(stream._state === 'erroring');\r\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\r\n  stream._state = 'errored';\r\n  stream._writableStreamController[ErrorSteps]();\r\n\r\n  const storedError = stream._storedError;\r\n  for (const writeRequest of stream._writeRequests) {\r\n    writeRequest._reject(storedError);\r\n  }\r\n  stream._writeRequests = [];\r\n\r\n  if (stream._pendingAbortRequest === undefined) {\r\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n    return;\r\n  }\r\n\r\n  const abortRequest = stream._pendingAbortRequest;\r\n  stream._pendingAbortRequest = undefined;\r\n\r\n  if (abortRequest._wasAlreadyErroring === true) {\r\n    abortRequest._reject(storedError);\r\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n    return;\r\n  }\r\n\r\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\r\n  promise.then(\r\n      () => {\r\n        abortRequest._resolve();\r\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n      },\r\n      reason => {\r\n        abortRequest._reject(reason);\r\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n      });\r\n}\r\n\r\nfunction WritableStreamFinishInFlightWrite(stream) {\r\n  assert(stream._inFlightWriteRequest !== undefined);\r\n  stream._inFlightWriteRequest._resolve(undefined);\r\n  stream._inFlightWriteRequest = undefined;\r\n}\r\n\r\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\r\n  assert(stream._inFlightWriteRequest !== undefined);\r\n  stream._inFlightWriteRequest._reject(error);\r\n  stream._inFlightWriteRequest = undefined;\r\n\r\n  assert(stream._state === 'writable' || stream._state === 'erroring');\r\n\r\n  WritableStreamDealWithRejection(stream, error);\r\n}\r\n\r\nfunction WritableStreamFinishInFlightClose(stream) {\r\n  assert(stream._inFlightCloseRequest !== undefined);\r\n  stream._inFlightCloseRequest._resolve(undefined);\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  const state = stream._state;\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  if (state === 'erroring') {\r\n    // The error was too late to do anything, so it is ignored.\r\n    stream._storedError = undefined;\r\n    if (stream._pendingAbortRequest !== undefined) {\r\n      stream._pendingAbortRequest._resolve();\r\n      stream._pendingAbortRequest = undefined;\r\n    }\r\n  }\r\n\r\n  stream._state = 'closed';\r\n\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    defaultWriterClosedPromiseResolve(writer);\r\n  }\r\n\r\n  assert(stream._pendingAbortRequest === undefined);\r\n  assert(stream._storedError === undefined);\r\n}\r\n\r\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\r\n  assert(stream._inFlightCloseRequest !== undefined);\r\n  stream._inFlightCloseRequest._reject(error);\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  assert(stream._state === 'writable' || stream._state === 'erroring');\r\n\r\n  // Never execute sink abort() after sink close().\r\n  if (stream._pendingAbortRequest !== undefined) {\r\n    stream._pendingAbortRequest._reject(error);\r\n    stream._pendingAbortRequest = undefined;\r\n  }\r\n  WritableStreamDealWithRejection(stream, error);\r\n}\r\n\r\n// TODO(ricea): Fix alphabetical order.\r\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\r\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\r\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\r\n    return false;\r\n  }\r\n\r\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\r\n  assert(stream._inFlightCloseRequest === undefined);\r\n  assert(stream._closeRequest !== undefined);\r\n  stream._inFlightCloseRequest = stream._closeRequest;\r\n  stream._closeRequest = undefined;\r\n}\r\n\r\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\r\n  assert(stream._inFlightWriteRequest === undefined);\r\n  assert(stream._writeRequests.length !== 0);\r\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\r\n}\r\n\r\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\r\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\r\n  assert(stream._state === 'errored');\r\n  if (stream._closeRequest !== undefined) {\r\n    assert(stream._inFlightCloseRequest === undefined);\r\n\r\n    stream._closeRequest._reject(stream._storedError);\r\n    stream._closeRequest = undefined;\r\n  }\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\r\n    writer._closedPromise.catch(() => {});\r\n  }\r\n}\r\n\r\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\r\n  assert(stream._state === 'writable');\r\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\r\n\r\n  const writer = stream._writer;\r\n  if (writer !== undefined && backpressure !== stream._backpressure) {\r\n    if (backpressure === true) {\r\n      defaultWriterReadyPromiseReset(writer);\r\n    } else {\r\n      assert(backpressure === false);\r\n\r\n      defaultWriterReadyPromiseResolve(writer);\r\n    }\r\n  }\r\n\r\n  stream._backpressure = backpressure;\r\n}\r\n\r\nclass WritableStreamDefaultWriter {\r\n  constructor(stream) {\r\n    if (IsWritableStream(stream) === false) {\r\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\r\n    }\r\n    if (IsWritableStreamLocked(stream) === true) {\r\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\r\n    }\r\n\r\n    this._ownerWritableStream = stream;\r\n    stream._writer = this;\r\n\r\n    const state = stream._state;\r\n\r\n    if (state === 'writable') {\r\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\r\n        defaultWriterReadyPromiseInitialize(this);\r\n      } else {\r\n        defaultWriterReadyPromiseInitializeAsResolved(this);\r\n      }\r\n\r\n      defaultWriterClosedPromiseInitialize(this);\r\n    } else if (state === 'erroring') {\r\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\r\n      this._readyPromise.catch(() => {});\r\n      defaultWriterClosedPromiseInitialize(this);\r\n    } else if (state === 'closed') {\r\n      defaultWriterReadyPromiseInitializeAsResolved(this);\r\n      defaultWriterClosedPromiseInitializeAsResolved(this);\r\n    } else {\r\n      assert(state === 'errored');\r\n\r\n      const storedError = stream._storedError;\r\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\r\n      this._readyPromise.catch(() => {});\r\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\r\n      this._closedPromise.catch(() => {});\r\n    }\r\n  }\r\n\r\n  get closed() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      throw defaultWriterBrandCheckException('desiredSize');\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      throw defaultWriterLockException('desiredSize');\r\n    }\r\n\r\n    return WritableStreamDefaultWriterGetDesiredSize(this);\r\n  }\r\n\r\n  get ready() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\r\n    }\r\n\r\n    return this._readyPromise;\r\n  }\r\n\r\n  abort(reason) {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('abort'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterAbort(this, reason);\r\n  }\r\n\r\n  close() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('close'));\r\n    }\r\n\r\n    const stream = this._ownerWritableStream;\r\n\r\n    if (stream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('close'));\r\n    }\r\n\r\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\r\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterClose(this);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      throw defaultWriterBrandCheckException('releaseLock');\r\n    }\r\n\r\n    const stream = this._ownerWritableStream;\r\n\r\n    if (stream === undefined) {\r\n      return;\r\n    }\r\n\r\n    assert(stream._writer !== undefined);\r\n\r\n    WritableStreamDefaultWriterRelease(this);\r\n  }\r\n\r\n  write(chunk) {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('write'));\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('write to'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterWrite(this, chunk);\r\n  }\r\n}\r\n\r\n// Abstract operations for the WritableStreamDefaultWriter.\r\n\r\nfunction IsWritableStreamDefaultWriter(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\r\n\r\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  return WritableStreamAbort(stream, reason);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterClose(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return Promise.reject(new TypeError(\r\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const closeRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._closeRequest = closeRequest;\r\n  });\r\n\r\n  if (stream._backpressure === true && state === 'writable') {\r\n    defaultWriterReadyPromiseResolve(writer);\r\n  }\r\n\r\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\r\n\r\n  return promise;\r\n}\r\n\r\n\r\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const state = stream._state;\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\r\n    return Promise.resolve();\r\n  }\r\n\r\n  if (state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  return WritableStreamDefaultWriterClose(writer);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\r\n  if (writer._closedPromiseState === 'pending') {\r\n    defaultWriterClosedPromiseReject(writer, error);\r\n  } else {\r\n    defaultWriterClosedPromiseResetToRejected(writer, error);\r\n  }\r\n  writer._closedPromise.catch(() => {});\r\n}\r\n\r\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\r\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\r\n  if (writer._readyPromiseState === 'pending') {\r\n    defaultWriterReadyPromiseReject(writer, error);\r\n  } else {\r\n    defaultWriterReadyPromiseResetToRejected(writer, error);\r\n  }\r\n  writer._readyPromise.catch(() => {});\r\n}\r\n\r\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored' || state === 'erroring') {\r\n    return null;\r\n  }\r\n\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterRelease(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n  assert(stream !== undefined);\r\n  assert(stream._writer === writer);\r\n\r\n  const releasedError = new TypeError(\r\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\r\n\r\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\r\n\r\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\r\n  // rejected until afterwards. This means that simply testing state will not work.\r\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\r\n\r\n  stream._writer = undefined;\r\n  writer._ownerWritableStream = undefined;\r\n}\r\n\r\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const controller = stream._writableStreamController;\r\n\r\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\r\n\r\n  if (stream !== writer._ownerWritableStream) {\r\n    return Promise.reject(defaultWriterLockException('write to'));\r\n  }\r\n\r\n  const state = stream._state;\r\n  if (state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\r\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\r\n  }\r\n  if (state === 'erroring') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(state === 'writable');\r\n\r\n  const promise = WritableStreamAddWriteRequest(stream);\r\n\r\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\r\n\r\n  return promise;\r\n}\r\n\r\nclass WritableStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\r\n  }\r\n\r\n  error(e) {\r\n    if (IsWritableStreamDefaultController(this) === false) {\r\n      throw new TypeError(\r\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\r\n    }\r\n    const state = this._controlledWritableStream._state;\r\n    if (state !== 'writable') {\r\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\r\n      // just treat it as a no-op.\r\n      return;\r\n    }\r\n\r\n    WritableStreamDefaultControllerError(this, e);\r\n  }\r\n\r\n  [AbortSteps](reason) {\r\n    return this._abortAlgorithm(reason);\r\n  }\r\n\r\n  [ErrorSteps]() {\r\n    ResetQueue(this);\r\n  }\r\n}\r\n\r\n// Abstract operations implementing interface required by the WritableStream.\r\n\r\nfunction IsWritableStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\r\n  assert(IsWritableStream(stream) === true);\r\n  assert(stream._writableStreamController === undefined);\r\n\r\n  controller._controlledWritableStream = stream;\r\n  stream._writableStreamController = controller;\r\n\r\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\r\n  controller._queue = undefined;\r\n  controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._started = false;\r\n\r\n  controller._strategySizeAlgorithm = sizeAlgorithm;\r\n  controller._strategyHWM = highWaterMark;\r\n\r\n  controller._writeAlgorithm = writeAlgorithm;\r\n  controller._closeAlgorithm = closeAlgorithm;\r\n  controller._abortAlgorithm = abortAlgorithm;\r\n\r\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n  WritableStreamUpdateBackpressure(stream, backpressure);\r\n\r\n  const startResult = startAlgorithm();\r\n  const startPromise = Promise.resolve(startResult);\r\n  startPromise.then(\r\n      () => {\r\n        assert(stream._state === 'writable' || stream._state === 'erroring');\r\n        controller._started = true;\r\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n      },\r\n      r => {\r\n        assert(stream._state === 'writable' || stream._state === 'erroring');\r\n        controller._started = true;\r\n        WritableStreamDealWithRejection(stream, r);\r\n      }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\r\n  assert(underlyingSink !== undefined);\r\n\r\n  const controller = Object.create(WritableStreamDefaultController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\r\n  }\r\n\r\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\r\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\r\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\r\n\r\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerClose(controller) {\r\n  EnqueueValueWithSize(controller, 'close', 0);\r\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\r\n  try {\r\n    return controller._strategySizeAlgorithm(chunk);\r\n  } catch (chunkSizeE) {\r\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\r\n    return 1;\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\r\n  const writeRecord = { chunk };\r\n\r\n  try {\r\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\r\n  } catch (enqueueE) {\r\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\r\n    return;\r\n  }\r\n\r\n  const stream = controller._controlledWritableStream;\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\r\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n    WritableStreamUpdateBackpressure(stream, backpressure);\r\n  }\r\n\r\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n}\r\n\r\n// Abstract operations for the WritableStreamDefaultController.\r\n\r\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\r\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  if (controller._started === false) {\r\n    return;\r\n  }\r\n\r\n  if (stream._inFlightWriteRequest !== undefined) {\r\n    return;\r\n  }\r\n\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return;\r\n  }\r\n  if (state === 'erroring') {\r\n    WritableStreamFinishErroring(stream);\r\n    return;\r\n  }\r\n\r\n  if (controller._queue.length === 0) {\r\n    return;\r\n  }\r\n\r\n  const writeRecord = PeekQueueValue(controller);\r\n  if (writeRecord === 'close') {\r\n    WritableStreamDefaultControllerProcessClose(controller);\r\n  } else {\r\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\r\n  if (controller._controlledWritableStream._state === 'writable') {\r\n    WritableStreamDefaultControllerError(controller, error);\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerProcessClose(controller) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  WritableStreamMarkCloseRequestInFlight(stream);\r\n\r\n  DequeueValue(controller);\r\n  assert(controller._queue.length === 0);\r\n\r\n  const sinkClosePromise = controller._closeAlgorithm();\r\n  sinkClosePromise.then(\r\n    () => {\r\n      WritableStreamFinishInFlightClose(stream);\r\n    },\r\n    reason => {\r\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\r\n\r\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\r\n  sinkWritePromise.then(\r\n    () => {\r\n      WritableStreamFinishInFlightWrite(stream);\r\n\r\n      const state = stream._state;\r\n      assert(state === 'writable' || state === 'erroring');\r\n\r\n      DequeueValue(controller);\r\n\r\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\r\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n        WritableStreamUpdateBackpressure(stream, backpressure);\r\n      }\r\n\r\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n    },\r\n    reason => {\r\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\r\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\r\n  return desiredSize <= 0;\r\n}\r\n\r\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\r\n\r\nfunction WritableStreamDefaultControllerError(controller, error) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  assert(stream._state === 'writable');\r\n\r\n  WritableStreamStartErroring(stream, error);\r\n}\r\n\r\n// Helper functions for the WritableStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\r\n}\r\n\r\n// Helper functions for the WritableStreamDefaultWriter.\r\n\r\nfunction defaultWriterBrandCheckException(name) {\r\n  return new TypeError(\r\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\r\n}\r\n\r\nfunction defaultWriterLockException(name) {\r\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitialize(writer) {\r\n  writer._closedPromise = new Promise((resolve, reject) => {\r\n    writer._closedPromise_resolve = resolve;\r\n    writer._closedPromise_reject = reject;\r\n    writer._closedPromiseState = 'pending';\r\n  });\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\r\n  writer._closedPromise = Promise.reject(reason);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\r\n  writer._closedPromise = Promise.resolve(undefined);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'resolved';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseReject(writer, reason) {\r\n  assert(writer._closedPromise_resolve !== undefined);\r\n  assert(writer._closedPromise_reject !== undefined);\r\n  assert(writer._closedPromiseState === 'pending');\r\n\r\n  writer._closedPromise_reject(reason);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\r\n  assert(writer._closedPromise_resolve === undefined);\r\n  assert(writer._closedPromise_reject === undefined);\r\n  assert(writer._closedPromiseState !== 'pending');\r\n\r\n  writer._closedPromise = Promise.reject(reason);\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseResolve(writer) {\r\n  assert(writer._closedPromise_resolve !== undefined);\r\n  assert(writer._closedPromise_reject !== undefined);\r\n  assert(writer._closedPromiseState === 'pending');\r\n\r\n  writer._closedPromise_resolve(undefined);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'resolved';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitialize(writer) {\r\n  verbose('defaultWriterReadyPromiseInitialize()');\r\n  writer._readyPromise = new Promise((resolve, reject) => {\r\n    writer._readyPromise_resolve = resolve;\r\n    writer._readyPromise_reject = reject;\r\n  });\r\n  writer._readyPromiseState = 'pending';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\r\n  writer._readyPromise = Promise.reject(reason);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\r\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\r\n  writer._readyPromise = Promise.resolve(undefined);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'fulfilled';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseReject(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\r\n  assert(writer._readyPromise_resolve !== undefined);\r\n  assert(writer._readyPromise_reject !== undefined);\r\n\r\n  writer._readyPromise_reject(reason);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseReset(writer) {\r\n  verbose('defaultWriterReadyPromiseReset()');\r\n  assert(writer._readyPromise_resolve === undefined);\r\n  assert(writer._readyPromise_reject === undefined);\r\n\r\n  writer._readyPromise = new Promise((resolve, reject) => {\r\n    writer._readyPromise_resolve = resolve;\r\n    writer._readyPromise_reject = reject;\r\n  });\r\n  writer._readyPromiseState = 'pending';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\r\n  assert(writer._readyPromise_resolve === undefined);\r\n  assert(writer._readyPromise_reject === undefined);\r\n\r\n  writer._readyPromise = Promise.reject(reason);\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseResolve(writer) {\r\n  verbose('defaultWriterReadyPromiseResolve()');\r\n  assert(writer._readyPromise_resolve !== undefined);\r\n  assert(writer._readyPromise_reject !== undefined);\r\n\r\n  writer._readyPromise_resolve(undefined);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'fulfilled';\r\n}\r\n","'use strict';\r\nconst assert = require('better-assert');\r\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, CreateIterResultObject, IsFiniteNonNegativeNumber,\r\n        InvokeOrNoop, IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject } = require('./helpers.js');\r\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\r\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\r\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\r\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\r\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\r\n      require('./writable-stream.js');\r\n\r\nconst CancelSteps = Symbol('[[CancelSteps]]');\r\nconst PullSteps = Symbol('[[PullSteps]]');\r\n\r\nclass ReadableStream {\r\n  constructor(underlyingSource = {}, { size, highWaterMark } = {}) {\r\n    InitializeReadableStream(this);\r\n    const type = underlyingSource.type;\r\n    const typeString = String(type);\r\n    if (typeString === 'bytes') {\r\n      if (highWaterMark === undefined) {\r\n        highWaterMark = 0;\r\n      }\r\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n      if (size !== undefined) {\r\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\r\n      }\r\n\r\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\r\n    } else if (type === undefined) {\r\n      if (highWaterMark === undefined) {\r\n        highWaterMark = 1;\r\n      }\r\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\r\n\r\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\r\n    } else {\r\n      throw new RangeError('Invalid type is specified');\r\n    }\r\n  }\r\n\r\n  get locked() {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('locked');\r\n    }\r\n\r\n    return IsReadableStreamLocked(this);\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (IsReadableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (IsReadableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\r\n    }\r\n\r\n    return ReadableStreamCancel(this, reason);\r\n  }\r\n\r\n  getReader({ mode } = {}) {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('getReader');\r\n    }\r\n\r\n    if (mode === undefined) {\r\n      return AcquireReadableStreamDefaultReader(this);\r\n    }\r\n\r\n    mode = String(mode);\r\n\r\n    if (mode === 'byob') {\r\n      return AcquireReadableStreamBYOBReader(this);\r\n    }\r\n\r\n    throw new RangeError('Invalid mode is specified');\r\n  }\r\n\r\n  pipeThrough({ writable, readable }, options) {\r\n    if (writable === undefined || readable === undefined) {\r\n      throw new TypeError('readable and writable arguments must be defined');\r\n    }\r\n\r\n    const promise = this.pipeTo(writable, options);\r\n\r\n    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\r\n\r\n    return readable;\r\n  }\r\n\r\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\r\n    if (IsReadableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('pipeTo'));\r\n    }\r\n    if (IsWritableStream(dest) === false) {\r\n      return Promise.reject(\r\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\r\n    }\r\n\r\n    preventClose = Boolean(preventClose);\r\n    preventAbort = Boolean(preventAbort);\r\n    preventCancel = Boolean(preventCancel);\r\n\r\n    if (IsReadableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\r\n    }\r\n    if (IsWritableStreamLocked(dest) === true) {\r\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\r\n    }\r\n\r\n    const reader = AcquireReadableStreamDefaultReader(this);\r\n    const writer = AcquireWritableStreamDefaultWriter(dest);\r\n\r\n    let shuttingDown = false;\r\n\r\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\r\n    let currentWrite = Promise.resolve();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      // Using reader and writer, read all chunks from this and write them to dest\r\n      // - Backpressure must be enforced\r\n      // - Shutdown must stop all activity\r\n      function pipeLoop() {\r\n        if (shuttingDown === true) {\r\n          return Promise.resolve();\r\n        }\r\n\r\n        return writer._readyPromise.then(() => {\r\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\r\n            if (done === true) {\r\n              return;\r\n            }\r\n\r\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\r\n          });\r\n        })\r\n        .then(pipeLoop);\r\n      }\r\n\r\n      // Errors must be propagated forward\r\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\r\n        if (preventAbort === false) {\r\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\r\n        } else {\r\n          shutdown(true, storedError);\r\n        }\r\n      });\r\n\r\n      // Errors must be propagated backward\r\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\r\n        if (preventCancel === false) {\r\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\r\n        } else {\r\n          shutdown(true, storedError);\r\n        }\r\n      });\r\n\r\n      // Closing must be propagated forward\r\n      isOrBecomesClosed(this, reader._closedPromise, () => {\r\n        if (preventClose === false) {\r\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\r\n        } else {\r\n          shutdown();\r\n        }\r\n      });\r\n\r\n      // Closing must be propagated backward\r\n      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\r\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\r\n\r\n        if (preventCancel === false) {\r\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\r\n        } else {\r\n          shutdown(true, destClosed);\r\n        }\r\n      }\r\n\r\n      pipeLoop().catch(err => {\r\n        currentWrite = Promise.resolve();\r\n        rethrowAssertionErrorRejection(err);\r\n      });\r\n\r\n      function waitForWritesToFinish() {\r\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\r\n        // for that too.\r\n        const oldCurrentWrite = currentWrite;\r\n        return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\r\n      }\r\n\r\n      function isOrBecomesErrored(stream, promise, action) {\r\n        if (stream._state === 'errored') {\r\n          action(stream._storedError);\r\n        } else {\r\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function isOrBecomesClosed(stream, promise, action) {\r\n        if (stream._state === 'closed') {\r\n          action();\r\n        } else {\r\n          promise.then(action).catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function shutdownWithAction(action, originalIsError, originalError) {\r\n        if (shuttingDown === true) {\r\n          return;\r\n        }\r\n        shuttingDown = true;\r\n\r\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\r\n          waitForWritesToFinish().then(doTheRest);\r\n        } else {\r\n          doTheRest();\r\n        }\r\n\r\n        function doTheRest() {\r\n          action().then(\r\n            () => finalize(originalIsError, originalError),\r\n            newError => finalize(true, newError)\r\n          )\r\n          .catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function shutdown(isError, error) {\r\n        if (shuttingDown === true) {\r\n          return;\r\n        }\r\n        shuttingDown = true;\r\n\r\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\r\n          waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\r\n        } else {\r\n          finalize(isError, error);\r\n        }\r\n      }\r\n\r\n      function finalize(isError, error) {\r\n        WritableStreamDefaultWriterRelease(writer);\r\n        ReadableStreamReaderGenericRelease(reader);\r\n\r\n        if (isError) {\r\n          reject(error);\r\n        } else {\r\n          resolve(undefined);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  tee() {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('tee');\r\n    }\r\n\r\n    const branches = ReadableStreamTee(this, false);\r\n    return createArrayFromList(branches);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  CreateReadableByteStream,\r\n  CreateReadableStream,\r\n  ReadableStream,\r\n  IsReadableStreamDisturbed,\r\n  ReadableStreamDefaultControllerClose,\r\n  ReadableStreamDefaultControllerEnqueue,\r\n  ReadableStreamDefaultControllerError,\r\n  ReadableStreamDefaultControllerGetDesiredSize,\r\n  ReadableStreamDefaultControllerHasBackpressure,\r\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\r\n};\r\n\r\n// Abstract operations for the ReadableStream.\r\n\r\nfunction AcquireReadableStreamBYOBReader(stream) {\r\n  return new ReadableStreamBYOBReader(stream);\r\n}\r\n\r\nfunction AcquireReadableStreamDefaultReader(stream) {\r\n  return new ReadableStreamDefaultReader(stream);\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\r\n                              sizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n\r\n  const stream = Object.create(ReadableStream.prototype);\r\n  InitializeReadableStream(stream);\r\n\r\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\r\n\r\n  SetUpReadableStreamDefaultController(\r\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\r\n  );\r\n\r\n  return stream;\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\r\n                                  autoAllocateChunkSize = undefined) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\r\n    assert(autoAllocateChunkSize > 0);\r\n  }\r\n\r\n  const stream = Object.create(ReadableStream.prototype);\r\n  InitializeReadableStream(stream);\r\n\r\n  const controller = Object.create(ReadableByteStreamController.prototype);\r\n\r\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\r\n                                    autoAllocateChunkSize);\r\n\r\n  return stream;\r\n}\r\n\r\nfunction InitializeReadableStream(stream) {\r\n  stream._state = 'readable';\r\n  stream._reader = undefined;\r\n  stream._storedError = undefined;\r\n  stream._disturbed = false;\r\n}\r\n\r\nfunction IsReadableStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamDisturbed(stream) {\r\n  assert(IsReadableStream(stream) === true);\r\n\r\n  return stream._disturbed;\r\n}\r\n\r\nfunction IsReadableStreamLocked(stream) {\r\n  assert(IsReadableStream(stream) === true);\r\n\r\n  if (stream._reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamTee(stream, cloneForBranch2) {\r\n  assert(IsReadableStream(stream) === true);\r\n  assert(typeof cloneForBranch2 === 'boolean');\r\n\r\n  const reader = AcquireReadableStreamDefaultReader(stream);\r\n\r\n  let closedOrErrored = false;\r\n  let canceled1 = false;\r\n  let canceled2 = false;\r\n  let reason1;\r\n  let reason2;\r\n  let branch1;\r\n  let branch2;\r\n\r\n  let resolveCancelPromise;\r\n  const cancelPromise = new Promise(resolve => {\r\n    resolveCancelPromise = resolve;\r\n  });\r\n\r\n  function pullAlgorithm() {\r\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\r\n      assert(typeIsObject(result));\r\n      const value = result.value;\r\n      const done = result.done;\r\n      assert(typeof done === 'boolean');\r\n\r\n      if (done === true && closedOrErrored === false) {\r\n        if (canceled1 === false) {\r\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\r\n        }\r\n        if (canceled2 === false) {\r\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\r\n        }\r\n        closedOrErrored = true;\r\n      }\r\n\r\n      if (closedOrErrored === true) {\r\n        return;\r\n      }\r\n\r\n      const value1 = value;\r\n      const value2 = value;\r\n\r\n      // There is no way to access the cloning code right now in the reference implementation.\r\n      // If we add one then we'll need an implementation for serializable objects.\r\n      // if (canceled2 === false && cloneForBranch2 === true) {\r\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\r\n      // }\r\n\r\n      if (canceled1 === false) {\r\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\r\n      }\r\n\r\n      if (canceled2 === false) {\r\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\r\n      }\r\n    });\r\n  }\r\n\r\n  function cancel1Algorithm(reason) {\r\n    canceled1 = true;\r\n    reason1 = reason;\r\n    if (canceled2 === true) {\r\n      const compositeReason = createArrayFromList([reason1, reason2]);\r\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n      resolveCancelPromise(cancelResult);\r\n    }\r\n    return cancelPromise;\r\n  }\r\n\r\n  function cancel2Algorithm(reason) {\r\n    canceled2 = true;\r\n    reason2 = reason;\r\n    if (canceled1 === true) {\r\n      const compositeReason = createArrayFromList([reason1, reason2]);\r\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n      resolveCancelPromise(cancelResult);\r\n    }\r\n    return cancelPromise;\r\n  }\r\n\r\n  function startAlgorithm() {}\r\n\r\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\r\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\r\n\r\n  reader._closedPromise.catch(r => {\r\n    if (closedOrErrored === true) {\r\n      return;\r\n    }\r\n\r\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\r\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\r\n    closedOrErrored = true;\r\n  });\r\n\r\n  return [branch1, branch2];\r\n}\r\n\r\n// ReadableStream API exposed for controllers.\r\n\r\nfunction ReadableStreamAddReadIntoRequest(stream) {\r\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\r\n  assert(stream._state === 'readable' || stream._state === 'closed');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const readIntoRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._reader._readIntoRequests.push(readIntoRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableStreamAddReadRequest(stream) {\r\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\r\n  assert(stream._state === 'readable');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const readRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._reader._readRequests.push(readRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableStreamCancel(stream, reason) {\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'closed') {\r\n    return Promise.resolve(undefined);\r\n  }\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  ReadableStreamClose(stream);\r\n\r\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\r\n  return sourceCancelPromise.then(() => undefined);\r\n}\r\n\r\nfunction ReadableStreamClose(stream) {\r\n  assert(stream._state === 'readable');\r\n\r\n  stream._state = 'closed';\r\n\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === true) {\r\n    for (const { _resolve } of reader._readRequests) {\r\n      _resolve(CreateIterResultObject(undefined, true));\r\n    }\r\n    reader._readRequests = [];\r\n  }\r\n\r\n  defaultReaderClosedPromiseResolve(reader);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamError(stream, e) {\r\n  assert(IsReadableStream(stream) === true);\r\n  assert(stream._state === 'readable');\r\n\r\n  stream._state = 'errored';\r\n  stream._storedError = e;\r\n\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === true) {\r\n    for (const readRequest of reader._readRequests) {\r\n      readRequest._reject(e);\r\n    }\r\n\r\n    reader._readRequests = [];\r\n  } else {\r\n    assert(IsReadableStreamBYOBReader(reader));\r\n\r\n    for (const readIntoRequest of reader._readIntoRequests) {\r\n      readIntoRequest._reject(e);\r\n    }\r\n\r\n    reader._readIntoRequests = [];\r\n  }\r\n\r\n  defaultReaderClosedPromiseReject(reader, e);\r\n  reader._closedPromise.catch(() => {});\r\n}\r\n\r\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\r\n  const reader = stream._reader;\r\n\r\n  assert(reader._readIntoRequests.length > 0);\r\n\r\n  const readIntoRequest = reader._readIntoRequests.shift();\r\n  readIntoRequest._resolve(CreateIterResultObject(chunk, done));\r\n}\r\n\r\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\r\n  const reader = stream._reader;\r\n\r\n  assert(reader._readRequests.length > 0);\r\n\r\n  const readRequest = reader._readRequests.shift();\r\n  readRequest._resolve(CreateIterResultObject(chunk, done));\r\n}\r\n\r\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\r\n  return stream._reader._readIntoRequests.length;\r\n}\r\n\r\nfunction ReadableStreamGetNumReadRequests(stream) {\r\n  return stream._reader._readRequests.length;\r\n}\r\n\r\nfunction ReadableStreamHasBYOBReader(stream) {\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamBYOBReader(reader) === false) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamHasDefaultReader(stream) {\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === false) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// Readers\r\n\r\nclass ReadableStreamDefaultReader {\r\n  constructor(stream) {\r\n    if (IsReadableStream(stream) === false) {\r\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\r\n    }\r\n    if (IsReadableStreamLocked(stream) === true) {\r\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n    }\r\n\r\n    ReadableStreamReaderGenericInitialize(this, stream);\r\n\r\n    this._readRequests = [];\r\n  }\r\n\r\n  get closed() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('cancel'));\r\n    }\r\n\r\n    return ReadableStreamReaderGenericCancel(this, reason);\r\n  }\r\n\r\n  read() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('read'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('read from'));\r\n    }\r\n\r\n    return ReadableStreamDefaultReaderRead(this);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      throw defaultReaderBrandCheckException('releaseLock');\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (this._readRequests.length > 0) {\r\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\r\n    }\r\n\r\n    ReadableStreamReaderGenericRelease(this);\r\n  }\r\n}\r\n\r\nclass ReadableStreamBYOBReader {\r\n  constructor(stream) {\r\n    if (!IsReadableStream(stream)) {\r\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\r\n          'byte source');\r\n    }\r\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\r\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\r\n          'source');\r\n    }\r\n    if (IsReadableStreamLocked(stream)) {\r\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n    }\r\n\r\n    ReadableStreamReaderGenericInitialize(this, stream);\r\n\r\n    this._readIntoRequests = [];\r\n  }\r\n\r\n  get closed() {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('cancel'));\r\n    }\r\n\r\n    return ReadableStreamReaderGenericCancel(this, reason);\r\n  }\r\n\r\n  read(view) {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('read'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('read from'));\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(view)) {\r\n      return Promise.reject(new TypeError('view must be an array buffer view'));\r\n    }\r\n\r\n    if (IsDetachedBuffer(view.buffer) === true) {\r\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\r\n    }\r\n\r\n    if (view.byteLength === 0) {\r\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\r\n    }\r\n\r\n    return ReadableStreamBYOBReaderRead(this, view);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      throw byobReaderBrandCheckException('releaseLock');\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (this._readIntoRequests.length > 0) {\r\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\r\n    }\r\n\r\n    ReadableStreamReaderGenericRelease(this);\r\n  }\r\n}\r\n\r\n// Abstract operations for the readers.\r\n\r\nfunction IsReadableStreamBYOBReader(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamDefaultReader(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\r\n  reader._ownerReadableStream = stream;\r\n  stream._reader = reader;\r\n\r\n  if (stream._state === 'readable') {\r\n    defaultReaderClosedPromiseInitialize(reader);\r\n  } else if (stream._state === 'closed') {\r\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\r\n  } else {\r\n    assert(stream._state === 'errored');\r\n\r\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\r\n    reader._closedPromise.catch(() => {});\r\n  }\r\n}\r\n\r\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\r\n// check.\r\n\r\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\r\n  const stream = reader._ownerReadableStream;\r\n  assert(stream !== undefined);\r\n  return ReadableStreamCancel(stream, reason);\r\n}\r\n\r\nfunction ReadableStreamReaderGenericRelease(reader) {\r\n  assert(reader._ownerReadableStream !== undefined);\r\n  assert(reader._ownerReadableStream._reader === reader);\r\n\r\n  if (reader._ownerReadableStream._state === 'readable') {\r\n    defaultReaderClosedPromiseReject(\r\n        reader,\r\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\r\n  } else {\r\n    defaultReaderClosedPromiseResetToRejected(\r\n        reader,\r\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\r\n  }\r\n  reader._closedPromise.catch(() => {});\r\n\r\n  reader._ownerReadableStream._reader = undefined;\r\n  reader._ownerReadableStream = undefined;\r\n}\r\n\r\nfunction ReadableStreamBYOBReaderRead(reader, view) {\r\n  const stream = reader._ownerReadableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  // Controllers must implement this.\r\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\r\n}\r\n\r\nfunction ReadableStreamDefaultReaderRead(reader) {\r\n  const stream = reader._ownerReadableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'closed') {\r\n    return Promise.resolve(CreateIterResultObject(undefined, true));\r\n  }\r\n\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(stream._state === 'readable');\r\n\r\n  return stream._readableStreamController[PullSteps]();\r\n}\r\n\r\n// Controllers\r\n\r\nclass ReadableStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError();\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\r\n  }\r\n\r\n  close() {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('close');\r\n    }\r\n\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\r\n      throw new TypeError('The stream is not in a state that permits close');\r\n    }\r\n\r\n    ReadableStreamDefaultControllerClose(this);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\r\n      throw new TypeError('The stream is not in a state that permits enqueue');\r\n    }\r\n\r\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(e) {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('error');\r\n    }\r\n\r\n    ReadableStreamDefaultControllerError(this, e);\r\n  }\r\n\r\n  [CancelSteps](reason) {\r\n    ResetQueue(this);\r\n    return this._cancelAlgorithm(reason);\r\n  }\r\n\r\n  [PullSteps]() {\r\n    const stream = this._controlledReadableStream;\r\n\r\n    if (this._queue.length > 0) {\r\n      const chunk = DequeueValue(this);\r\n\r\n      if (this._closeRequested === true && this._queue.length === 0) {\r\n        ReadableStreamClose(stream);\r\n      } else {\r\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n      }\r\n\r\n      return Promise.resolve(CreateIterResultObject(chunk, false));\r\n    }\r\n\r\n    const pendingPromise = ReadableStreamAddReadRequest(stream);\r\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n    return pendingPromise;\r\n  }\r\n}\r\n\r\n// Abstract operations for the ReadableStreamDefaultController.\r\n\r\nfunction IsReadableStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\r\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\r\n  if (shouldPull === false) {\r\n    return undefined;\r\n  }\r\n\r\n  if (controller._pulling === true) {\r\n    controller._pullAgain = true;\r\n    return undefined;\r\n  }\r\n\r\n  assert(controller._pullAgain === false);\r\n\r\n  controller._pulling = true;\r\n\r\n  const pullPromise = controller._pullAlgorithm();\r\n  pullPromise.then(\r\n    () => {\r\n      controller._pulling = false;\r\n\r\n      if (controller._pullAgain === true) {\r\n        controller._pullAgain = false;\r\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n      }\r\n      return undefined;\r\n    },\r\n    e => {\r\n      ReadableStreamDefaultControllerError(controller, e);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\r\n    return false;\r\n  }\r\n\r\n  if (controller._started === false) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\r\n  if (desiredSize > 0) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\r\n\r\nfunction ReadableStreamDefaultControllerClose(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\r\n\r\n  controller._closeRequested = true;\r\n\r\n  if (controller._queue.length === 0) {\r\n    ReadableStreamClose(stream);\r\n  }\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\r\n\r\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\r\n  } else {\r\n    let chunkSize;\r\n    try {\r\n      chunkSize = controller._strategySizeAlgorithm(chunk);\r\n    } catch (chunkSizeE) {\r\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\r\n      throw chunkSizeE;\r\n    }\r\n\r\n    try {\r\n      EnqueueValueWithSize(controller, chunk, chunkSize);\r\n    } catch (enqueueE) {\r\n      ReadableStreamDefaultControllerError(controller, enqueueE);\r\n      throw enqueueE;\r\n    }\r\n  }\r\n\r\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerError(controller, e) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return;\r\n  }\r\n\r\n  ResetQueue(controller);\r\n\r\n  ReadableStreamError(stream, e);\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored') {\r\n    return null;\r\n  }\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\n// This is used in the implementation of TransformStream.\r\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\r\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\r\n  const state = controller._controlledReadableStream._state;\r\n\r\n  if (controller._closeRequested === false && state === 'readable') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction SetUpReadableStreamDefaultController(\r\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\r\n  assert(stream._readableStreamController === undefined);\r\n\r\n  controller._controlledReadableStream = stream;\r\n\r\n  controller._queue = undefined;\r\n  controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._started = false;\r\n  controller._closeRequested = false;\r\n  controller._pullAgain = false;\r\n  controller._pulling = false;\r\n\r\n  controller._strategySizeAlgorithm = sizeAlgorithm;\r\n  controller._strategyHWM = highWaterMark;\r\n\r\n  controller._pullAlgorithm = pullAlgorithm;\r\n  controller._cancelAlgorithm = cancelAlgorithm;\r\n\r\n  stream._readableStreamController = controller;\r\n\r\n  const startResult = startAlgorithm();\r\n  Promise.resolve(startResult).then(\r\n    () => {\r\n      controller._started = true;\r\n\r\n      assert(controller._pulling === false);\r\n      assert(controller._pullAgain === false);\r\n\r\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n    },\r\n    r => {\r\n      ReadableStreamDefaultControllerError(controller, r);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\r\n                                                                  sizeAlgorithm) {\r\n  assert(underlyingSource !== undefined);\r\n\r\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\r\n  }\r\n\r\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\r\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\r\n\r\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\r\n                                       highWaterMark, sizeAlgorithm);\r\n}\r\n\r\nclass ReadableStreamBYOBRequest {\r\n  constructor() {\r\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\r\n  }\r\n\r\n  get view() {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('view');\r\n    }\r\n\r\n    return this._view;\r\n  }\r\n\r\n  respond(bytesWritten) {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('respond');\r\n    }\r\n\r\n    if (this._associatedReadableByteStreamController === undefined) {\r\n      throw new TypeError('This BYOB request has been invalidated');\r\n    }\r\n\r\n    if (IsDetachedBuffer(this._view.buffer) === true) {\r\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\r\n  }\r\n\r\n  respondWithNewView(view) {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('respond');\r\n    }\r\n\r\n    if (this._associatedReadableByteStreamController === undefined) {\r\n      throw new TypeError('This BYOB request has been invalidated');\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(view)) {\r\n      throw new TypeError('You can only respond with array buffer views');\r\n    }\r\n\r\n    if (IsDetachedBuffer(view.buffer) === true) {\r\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\r\n  }\r\n}\r\n\r\nclass ReadableByteStreamController {\r\n  constructor() {\r\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\r\n  }\r\n\r\n  get byobRequest() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('byobRequest');\r\n    }\r\n\r\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\r\n      const firstDescriptor = this._pendingPullIntos[0];\r\n      const view = new Uint8Array(firstDescriptor.buffer,\r\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\r\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\r\n\r\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\r\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\r\n      this._byobRequest = byobRequest;\r\n    }\r\n\r\n    return this._byobRequest;\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    return ReadableByteStreamControllerGetDesiredSize(this);\r\n  }\r\n\r\n  close() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('close');\r\n    }\r\n\r\n    if (this._closeRequested === true) {\r\n      throw new TypeError('The stream has already been closed; do not close it again!');\r\n    }\r\n\r\n    const state = this._controlledReadableByteStream._state;\r\n    if (state !== 'readable') {\r\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\r\n    }\r\n\r\n    ReadableByteStreamControllerClose(this);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    if (this._closeRequested === true) {\r\n      throw new TypeError('stream is closed or draining');\r\n    }\r\n\r\n    const state = this._controlledReadableByteStream._state;\r\n    if (state !== 'readable') {\r\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(chunk)) {\r\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\r\n    }\r\n\r\n    if (IsDetachedBuffer(chunk.buffer) === true) {\r\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\r\n    }\r\n\r\n    ReadableByteStreamControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(e) {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('error');\r\n    }\r\n\r\n    ReadableByteStreamControllerError(this, e);\r\n  }\r\n\r\n  [CancelSteps](reason) {\r\n    if (this._pendingPullIntos.length > 0) {\r\n      const firstDescriptor = this._pendingPullIntos[0];\r\n      firstDescriptor.bytesFilled = 0;\r\n    }\r\n\r\n    ResetQueue(this);\r\n\r\n    return this._cancelAlgorithm(reason);\r\n  }\r\n\r\n  [PullSteps]() {\r\n    const stream = this._controlledReadableByteStream;\r\n    assert(ReadableStreamHasDefaultReader(stream) === true);\r\n\r\n    if (this._queueTotalSize > 0) {\r\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\r\n\r\n      const entry = this._queue.shift();\r\n      this._queueTotalSize -= entry.byteLength;\r\n\r\n      ReadableByteStreamControllerHandleQueueDrain(this);\r\n\r\n      let view;\r\n      try {\r\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\r\n      } catch (viewE) {\r\n        return Promise.reject(viewE);\r\n      }\r\n\r\n      return Promise.resolve(CreateIterResultObject(view, false));\r\n    }\r\n\r\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\r\n    if (autoAllocateChunkSize !== undefined) {\r\n      let buffer;\r\n      try {\r\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\r\n      } catch (bufferE) {\r\n        return Promise.reject(bufferE);\r\n      }\r\n\r\n      const pullIntoDescriptor = {\r\n        buffer,\r\n        byteOffset: 0,\r\n        byteLength: autoAllocateChunkSize,\r\n        bytesFilled: 0,\r\n        elementSize: 1,\r\n        ctor: Uint8Array,\r\n        readerType: 'default'\r\n      };\r\n\r\n      this._pendingPullIntos.push(pullIntoDescriptor);\r\n    }\r\n\r\n    const promise = ReadableStreamAddReadRequest(stream);\r\n\r\n    ReadableByteStreamControllerCallPullIfNeeded(this);\r\n\r\n    return promise;\r\n  }\r\n}\r\n\r\n// Abstract operations for the ReadableByteStreamController.\r\n\r\nfunction IsReadableByteStreamController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamBYOBRequest(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\r\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\r\n  if (shouldPull === false) {\r\n    return undefined;\r\n  }\r\n\r\n  if (controller._pulling === true) {\r\n    controller._pullAgain = true;\r\n    return undefined;\r\n  }\r\n\r\n  assert(controller._pullAgain === false);\r\n\r\n  controller._pulling = true;\r\n\r\n  // TODO: Test controller argument\r\n  const pullPromise = controller._pullAlgorithm();\r\n  pullPromise.then(\r\n    () => {\r\n      controller._pulling = false;\r\n\r\n      if (controller._pullAgain === true) {\r\n        controller._pullAgain = false;\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n      }\r\n    },\r\n    e => {\r\n      ReadableByteStreamControllerError(controller, e);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  controller._pendingPullIntos = [];\r\n}\r\n\r\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\r\n  assert(stream._state !== 'errored');\r\n\r\n  let done = false;\r\n  if (stream._state === 'closed') {\r\n    assert(pullIntoDescriptor.bytesFilled === 0);\r\n    done = true;\r\n  }\r\n\r\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n  if (pullIntoDescriptor.readerType === 'default') {\r\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\r\n  } else {\r\n    assert(pullIntoDescriptor.readerType === 'byob');\r\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\r\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\r\n  const elementSize = pullIntoDescriptor.elementSize;\r\n\r\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\r\n  assert(bytesFilled % elementSize === 0);\r\n\r\n  return new pullIntoDescriptor.ctor(\r\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\r\n}\r\n\r\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\r\n  controller._queue.push({ buffer, byteOffset, byteLength });\r\n  controller._queueTotalSize += byteLength;\r\n}\r\n\r\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\r\n  const elementSize = pullIntoDescriptor.elementSize;\r\n\r\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\r\n\r\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\r\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\r\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\r\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\r\n\r\n  let totalBytesToCopyRemaining = maxBytesToCopy;\r\n  let ready = false;\r\n  if (maxAlignedBytes > currentAlignedBytes) {\r\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\r\n    ready = true;\r\n  }\r\n\r\n  const queue = controller._queue;\r\n\r\n  while (totalBytesToCopyRemaining > 0) {\r\n    const headOfQueue = queue[0];\r\n\r\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\r\n\r\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\r\n\r\n    if (headOfQueue.byteLength === bytesToCopy) {\r\n      queue.shift();\r\n    } else {\r\n      headOfQueue.byteOffset += bytesToCopy;\r\n      headOfQueue.byteLength -= bytesToCopy;\r\n    }\r\n    controller._queueTotalSize -= bytesToCopy;\r\n\r\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\r\n\r\n    totalBytesToCopyRemaining -= bytesToCopy;\r\n  }\r\n\r\n  if (ready === false) {\r\n    assert(controller._queueTotalSize === 0);\r\n    assert(pullIntoDescriptor.bytesFilled > 0);\r\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\r\n  }\r\n\r\n  return ready;\r\n}\r\n\r\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\r\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\r\n\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  pullIntoDescriptor.bytesFilled += size;\r\n}\r\n\r\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\r\n  assert(controller._controlledReadableByteStream._state === 'readable');\r\n\r\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\r\n    ReadableStreamClose(controller._controlledReadableByteStream);\r\n  } else {\r\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\r\n  if (controller._byobRequest === undefined) {\r\n    return;\r\n  }\r\n\r\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\r\n  controller._byobRequest._view = undefined;\r\n  controller._byobRequest = undefined;\r\n}\r\n\r\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\r\n  assert(controller._closeRequested === false);\r\n\r\n  while (controller._pendingPullIntos.length > 0) {\r\n    if (controller._queueTotalSize === 0) {\r\n      return;\r\n    }\r\n\r\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\r\n\r\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\r\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n\r\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\r\n        controller._controlledReadableByteStream,\r\n        pullIntoDescriptor\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerPullInto(controller, view) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  let elementSize = 1;\r\n  if (view.constructor !== DataView) {\r\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\r\n  }\r\n\r\n  const ctor = view.constructor;\r\n\r\n  const buffer = TransferArrayBuffer(view.buffer);\r\n  const pullIntoDescriptor = {\r\n    buffer,\r\n    byteOffset: view.byteOffset,\r\n    byteLength: view.byteLength,\r\n    bytesFilled: 0,\r\n    elementSize,\r\n    ctor,\r\n    readerType: 'byob'\r\n  };\r\n\r\n  if (controller._pendingPullIntos.length > 0) {\r\n    controller._pendingPullIntos.push(pullIntoDescriptor);\r\n\r\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\r\n    // - No change happens on desiredSize\r\n    // - The source has already been notified of that there's at least 1 pending read(view)\r\n\r\n    return ReadableStreamAddReadIntoRequest(stream);\r\n  }\r\n\r\n  if (stream._state === 'closed') {\r\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\r\n    return Promise.resolve(CreateIterResultObject(emptyView, true));\r\n  }\r\n\r\n  if (controller._queueTotalSize > 0) {\r\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\r\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n\r\n      ReadableByteStreamControllerHandleQueueDrain(controller);\r\n\r\n      return Promise.resolve(CreateIterResultObject(filledView, false));\r\n    }\r\n\r\n    if (controller._closeRequested === true) {\r\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n      ReadableByteStreamControllerError(controller, e);\r\n\r\n      return Promise.reject(e);\r\n    }\r\n  }\r\n\r\n  controller._pendingPullIntos.push(pullIntoDescriptor);\r\n\r\n  const promise = ReadableStreamAddReadIntoRequest(stream);\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\r\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\r\n\r\n  assert(firstDescriptor.bytesFilled === 0);\r\n\r\n  const stream = controller._controlledReadableByteStream;\r\n  if (ReadableStreamHasBYOBReader(stream) === true) {\r\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\r\n    }\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\r\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\r\n    throw new RangeError('bytesWritten out of range');\r\n  }\r\n\r\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\r\n\r\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\r\n    // TODO: Figure out whether we should detach the buffer or not here.\r\n    return;\r\n  }\r\n\r\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n\r\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\r\n  if (remainderSize > 0) {\r\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\r\n  }\r\n\r\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\r\n  pullIntoDescriptor.bytesFilled -= remainderSize;\r\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\r\n\r\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\r\n  const firstDescriptor = controller._pendingPullIntos[0];\r\n\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state === 'closed') {\r\n    if (bytesWritten !== 0) {\r\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\r\n  } else {\r\n    assert(stream._state === 'readable');\r\n\r\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\r\n  }\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\r\n  const descriptor = controller._pendingPullIntos.shift();\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  return descriptor;\r\n}\r\n\r\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return false;\r\n  }\r\n\r\n  if (controller._closeRequested === true) {\r\n    return false;\r\n  }\r\n\r\n  if (controller._started === false) {\r\n    return false;\r\n  }\r\n\r\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\r\n\r\nfunction ReadableByteStreamControllerClose(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  assert(controller._closeRequested === false);\r\n  assert(stream._state === 'readable');\r\n\r\n  if (controller._queueTotalSize > 0) {\r\n    controller._closeRequested = true;\r\n\r\n    return;\r\n  }\r\n\r\n  if (controller._pendingPullIntos.length > 0) {\r\n    const firstPendingPullInto = controller._pendingPullIntos[0];\r\n    if (firstPendingPullInto.bytesFilled > 0) {\r\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n      ReadableByteStreamControllerError(controller, e);\r\n\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  ReadableStreamClose(stream);\r\n}\r\n\r\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  assert(controller._closeRequested === false);\r\n  assert(stream._state === 'readable');\r\n\r\n  const buffer = chunk.buffer;\r\n  const byteOffset = chunk.byteOffset;\r\n  const byteLength = chunk.byteLength;\r\n  const transferredBuffer = TransferArrayBuffer(buffer);\r\n\r\n  if (ReadableStreamHasDefaultReader(stream) === true) {\r\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\r\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n    } else {\r\n      assert(controller._queue.length === 0);\r\n\r\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\r\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\r\n    }\r\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\r\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n  } else {\r\n    assert(IsReadableStreamLocked(stream) === false);\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n  }\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerError(controller, e) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return;\r\n  }\r\n\r\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\r\n\r\n  ResetQueue(controller);\r\n  ReadableStreamError(stream, e);\r\n}\r\n\r\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored') {\r\n    return null;\r\n  }\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\r\n  bytesWritten = Number(bytesWritten);\r\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\r\n    throw new RangeError('bytesWritten must be a finite');\r\n  }\r\n\r\n  assert(controller._pendingPullIntos.length > 0);\r\n\r\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\r\n  assert(controller._pendingPullIntos.length > 0);\r\n\r\n  const firstDescriptor = controller._pendingPullIntos[0];\r\n\r\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\r\n    throw new RangeError('The region specified by view does not match byobRequest');\r\n  }\r\n  if (firstDescriptor.byteLength !== view.byteLength) {\r\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\r\n  }\r\n\r\n  firstDescriptor.buffer = view.buffer;\r\n\r\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\r\n}\r\n\r\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\r\n                                           highWaterMark, autoAllocateChunkSize) {\r\n  assert(stream._readableStreamController === undefined);\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\r\n    assert(autoAllocateChunkSize > 0);\r\n  }\r\n\r\n  controller._controlledReadableByteStream = stream;\r\n\r\n  controller._pullAgain = false;\r\n  controller._pulling = false;\r\n\r\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\r\n\r\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\r\n  controller._queue = controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._closeRequested = false;\r\n  controller._started = false;\r\n\r\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n  controller._pullAlgorithm = pullAlgorithm;\r\n  controller._cancelAlgorithm = cancelAlgorithm;\r\n\r\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\r\n\r\n  controller._pendingPullIntos = [];\r\n\r\n  stream._readableStreamController = controller;\r\n\r\n  const startResult = startAlgorithm();\r\n  Promise.resolve(startResult).then(\r\n      () => {\r\n        controller._started = true;\r\n\r\n        assert(controller._pulling === false);\r\n        assert(controller._pullAgain === false);\r\n\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n      },\r\n      r => {\r\n        ReadableByteStreamControllerError(controller, r);\r\n      }\r\n  )\r\n      .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\r\n  assert(underlyingByteSource !== undefined);\r\n\r\n  const controller = Object.create(ReadableByteStreamController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\r\n  }\r\n\r\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\r\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\r\n\r\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\r\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\r\n    }\r\n  }\r\n\r\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\r\n                                    autoAllocateChunkSize);\r\n}\r\n\r\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\r\n  assert(IsReadableByteStreamController(controller) === true);\r\n  assert(typeof view === 'object');\r\n  assert(ArrayBuffer.isView(view) === true);\r\n  assert(IsDetachedBuffer(view.buffer) === false);\r\n  request._associatedReadableByteStreamController = controller;\r\n  request._view = view;\r\n}\r\n\r\n// Helper functions for the ReadableStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\r\n}\r\n\r\n// Helper functions for the readers.\r\n\r\nfunction readerLockException(name) {\r\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultReader.\r\n\r\nfunction defaultReaderBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitialize(reader) {\r\n  reader._closedPromise = new Promise((resolve, reject) => {\r\n    reader._closedPromise_resolve = resolve;\r\n    reader._closedPromise_reject = reject;\r\n  });\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\r\n  reader._closedPromise = Promise.reject(reason);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\r\n  reader._closedPromise = Promise.resolve(undefined);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseReject(reader, reason) {\r\n  assert(reader._closedPromise_resolve !== undefined);\r\n  assert(reader._closedPromise_reject !== undefined);\r\n\r\n  reader._closedPromise_reject(reason);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\r\n  assert(reader._closedPromise_resolve === undefined);\r\n  assert(reader._closedPromise_reject === undefined);\r\n\r\n  reader._closedPromise = Promise.reject(reason);\r\n}\r\n\r\nfunction defaultReaderClosedPromiseResolve(reader) {\r\n  assert(reader._closedPromise_resolve !== undefined);\r\n  assert(reader._closedPromise_reject !== undefined);\r\n\r\n  reader._closedPromise_resolve(undefined);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultReader.\r\n\r\nfunction byobReaderBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultController.\r\n\r\nfunction defaultControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\r\n}\r\n\r\n// Helper functions for the ReadableStreamBYOBRequest.\r\n\r\nfunction byobRequestBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\r\n}\r\n\r\n// Helper functions for the ReadableByteStreamController.\r\n\r\nfunction byteStreamControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\r\n}\r\n\r\n// Helper function for ReadableStream pipeThrough\r\n\r\nfunction ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\r\n  try {\r\n    // This relies on the brand-check that is enforced by Promise.prototype.then(). As with the rest of the reference\r\n    // implementation, it doesn't attempt to do the right thing if someone has modified the global environment.\r\n    Promise.prototype.then.call(promise, undefined, () => {});\r\n  } catch (e) {\r\n    // The brand check failed, therefore the internal slot is not present and there's nothing further to do.\r\n  }\r\n}\r\n","'use strict';\r\nconst { createDataProperty } = require('./helpers.js');\r\n\r\nmodule.exports = class ByteLengthQueuingStrategy {\r\n  constructor({ highWaterMark }) {\r\n    createDataProperty(this, 'highWaterMark', highWaterMark);\r\n  }\r\n\r\n  size(chunk) {\r\n    return chunk.byteLength;\r\n  }\r\n};\r\n","'use strict';\r\nconst { createDataProperty } = require('./helpers.js');\r\n\r\nmodule.exports = class CountQueuingStrategy {\r\n  constructor({ highWaterMark }) {\r\n    createDataProperty(this, 'highWaterMark', highWaterMark);\r\n  }\r\n\r\n  size() {\r\n    return 1;\r\n  }\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\r\n// and do not appear in the standard text.\r\nconst verbose = require('debug')('streams:transform-stream:verbose');\r\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\r\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\r\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\r\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\r\n        ReadableStreamDefaultControllerHasBackpressure,\r\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\r\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\r\n\r\n// Class TransformStream\r\n\r\nclass TransformStream {\r\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\r\n    const readableType = transformer.readableType;\r\n\r\n    if (readableType !== undefined) {\r\n      throw new RangeError('Invalid readable type specified');\r\n    }\r\n\r\n    const writableType = transformer.writableType;\r\n\r\n    if (writableType !== undefined) {\r\n      throw new RangeError('Invalid writable type specified');\r\n    }\r\n\r\n    const writableSizeFunction = writableStrategy.size;\r\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\r\n    let writableHighWaterMark = writableStrategy.highWaterMark;\r\n    if (writableHighWaterMark === undefined) {\r\n      writableHighWaterMark = 1;\r\n    }\r\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\r\n\r\n    const readableSizeFunction = readableStrategy.size;\r\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\r\n    let readableHighWaterMark = readableStrategy.highWaterMark;\r\n    if (readableHighWaterMark === undefined) {\r\n      readableHighWaterMark = 0;\r\n    }\r\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\r\n\r\n    let startPromise_resolve;\r\n    const startPromise = new Promise(resolve => {\r\n      startPromise_resolve = resolve;\r\n    });\r\n\r\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\r\n                              readableSizeAlgorithm);\r\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\r\n\r\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\r\n    startPromise_resolve(startResult);\r\n  }\r\n\r\n  get readable() {\r\n    if (IsTransformStream(this) === false) {\r\n      throw streamBrandCheckException('readable');\r\n    }\r\n\r\n    return this._readable;\r\n  }\r\n\r\n  get writable() {\r\n    if (IsTransformStream(this) === false) {\r\n      throw streamBrandCheckException('writable');\r\n    }\r\n\r\n    return this._writable;\r\n  }\r\n}\r\n\r\n// Transform Stream Abstract Operations\r\n\r\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\r\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\r\n                               readableSizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(writableHighWaterMark));\r\n  assert(IsNonNegativeNumber(readableHighWaterMark));\r\n\r\n  const stream = Object.create(TransformStream.prototype);\r\n\r\n  let startPromise_resolve;\r\n  const startPromise = new Promise(resolve => {\r\n    startPromise_resolve = resolve;\r\n  });\r\n\r\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\r\n                            readableSizeAlgorithm);\r\n\r\n  const controller = Object.create(TransformStreamDefaultController.prototype);\r\n\r\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\r\n\r\n  const startResult = startAlgorithm();\r\n  startPromise_resolve(startResult);\r\n  return stream;\r\n}\r\n\r\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\r\n                                   readableHighWaterMark, readableSizeAlgorithm) {\r\n  function startAlgorithm() {\r\n    return startPromise;\r\n  }\r\n\r\n  function writeAlgorithm(chunk) {\r\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\r\n  }\r\n\r\n  function abortAlgorithm(reason) {\r\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\r\n  }\r\n\r\n  function closeAlgorithm() {\r\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\r\n  }\r\n\r\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\r\n                                          writableHighWaterMark, writableSizeAlgorithm);\r\n\r\n  function pullAlgorithm() {\r\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\r\n  }\r\n\r\n  function cancelAlgorithm(reason) {\r\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\r\n    return Promise.resolve();\r\n  }\r\n\r\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\r\n                                          readableSizeAlgorithm);\r\n\r\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\r\n  stream._backpressure = undefined;\r\n  stream._backpressureChangePromise = undefined;\r\n  stream._backpressureChangePromise_resolve = undefined;\r\n  TransformStreamSetBackpressure(stream, true);\r\n\r\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\r\n  stream._transformStreamController = undefined;\r\n}\r\n\r\nfunction IsTransformStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// This is a no-op if both sides are already errored.\r\nfunction TransformStreamError(stream, e) {\r\n  verbose('TransformStreamError()');\r\n\r\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\r\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\r\n}\r\n\r\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\r\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\r\n  if (stream._backpressure === true) {\r\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\r\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\r\n    // _backpressure is set.\r\n    TransformStreamSetBackpressure(stream, false);\r\n  }\r\n}\r\n\r\nfunction TransformStreamSetBackpressure(stream, backpressure) {\r\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\r\n\r\n  // Passes also when called during construction.\r\n  assert(stream._backpressure !== backpressure);\r\n\r\n  if (stream._backpressureChangePromise !== undefined) {\r\n    stream._backpressureChangePromise_resolve();\r\n  }\r\n\r\n  stream._backpressureChangePromise = new Promise(resolve => {\r\n    stream._backpressureChangePromise_resolve = resolve;\r\n  });\r\n\r\n  stream._backpressure = backpressure;\r\n}\r\n\r\n// Class TransformStreamDefaultController\r\n\r\nclass TransformStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\r\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    TransformStreamDefaultControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(reason) {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('error');\r\n    }\r\n\r\n    TransformStreamDefaultControllerError(this, reason);\r\n  }\r\n\r\n  terminate() {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('terminate');\r\n    }\r\n\r\n    TransformStreamDefaultControllerTerminate(this);\r\n  }\r\n}\r\n\r\n// Transform Stream Default Controller Abstract Operations\r\n\r\nfunction IsTransformStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\r\n  assert(IsTransformStream(stream) === true);\r\n  assert(stream._transformStreamController === undefined);\r\n\r\n  controller._controlledTransformStream = stream;\r\n  stream._transformStreamController = controller;\r\n\r\n  controller._transformAlgorithm = transformAlgorithm;\r\n  controller._flushAlgorithm = flushAlgorithm;\r\n}\r\n\r\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\r\n  assert(transformer !== undefined);\r\n\r\n  const controller = Object.create(TransformStreamDefaultController.prototype);\r\n\r\n  let transformAlgorithm = chunk => {\r\n    try {\r\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\r\n      return Promise.resolve();\r\n    } catch (transformResultE) {\r\n      return Promise.reject(transformResultE);\r\n    }\r\n  };\r\n  const transformMethod = transformer.transform;\r\n  if (transformMethod !== undefined) {\r\n    if (typeof transformMethod !== 'function') {\r\n      throw new TypeError('transform is not a method');\r\n    }\r\n    transformAlgorithm = chunk => {\r\n      const transformPromise = PromiseCall(transformMethod, transformer, [chunk, controller]);\r\n      return transformPromise.catch(e => {\r\n        TransformStreamError(stream, e);\r\n        throw e;\r\n      });\r\n    };\r\n  }\r\n\r\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\r\n\r\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\r\n}\r\n\r\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\r\n  verbose('TransformStreamDefaultControllerEnqueue()');\r\n\r\n  const stream = controller._controlledTransformStream;\r\n  const readableController = stream._readable._readableStreamController;\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\r\n    throw new TypeError('Readable side is not in a state that permits enqueue');\r\n  }\r\n\r\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\r\n  // accept TransformStreamDefaultControllerEnqueue() calls.\r\n\r\n  try {\r\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\r\n  } catch (e) {\r\n    // This happens when readableStrategy.size() throws.\r\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\r\n\r\n    throw stream._readable._storedError;\r\n  }\r\n\r\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\r\n  if (backpressure !== stream._backpressure) {\r\n    assert(backpressure === true);\r\n    TransformStreamSetBackpressure(stream, true);\r\n  }\r\n}\r\n\r\nfunction TransformStreamDefaultControllerError(controller, e) {\r\n  TransformStreamError(controller._controlledTransformStream, e);\r\n}\r\n\r\nfunction TransformStreamDefaultControllerTerminate(controller) {\r\n  verbose('TransformStreamDefaultControllerTerminate()');\r\n\r\n  const stream = controller._controlledTransformStream;\r\n  const readableController = stream._readable._readableStreamController;\r\n\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\r\n    ReadableStreamDefaultControllerClose(readableController);\r\n  }\r\n\r\n  const error = new TypeError('TransformStream terminated');\r\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\r\n}\r\n\r\n// TransformStreamDefaultSink Algorithms\r\n\r\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\r\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\r\n\r\n  assert(stream._writable._state === 'writable');\r\n\r\n  const controller = stream._transformStreamController;\r\n\r\n  if (stream._backpressure === true) {\r\n    const backpressureChangePromise = stream._backpressureChangePromise;\r\n    assert(backpressureChangePromise !== undefined);\r\n    return backpressureChangePromise\r\n        .then(() => {\r\n          const writable = stream._writable;\r\n          const state = writable._state;\r\n          if (state === 'erroring') {\r\n            throw writable._storedError;\r\n          }\r\n          assert(state === 'writable');\r\n          return controller._transformAlgorithm(chunk);\r\n        });\r\n  }\r\n\r\n  return controller._transformAlgorithm(chunk);\r\n}\r\n\r\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\r\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\r\n  // errored.\r\n  TransformStreamError(stream, reason);\r\n  return Promise.resolve();\r\n}\r\n\r\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\r\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\r\n\r\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\r\n  const readable = stream._readable;\r\n\r\n  const flushPromise = stream._transformStreamController._flushAlgorithm();\r\n  // Return a promise that is fulfilled with undefined on success.\r\n  return flushPromise.then(() => {\r\n    if (readable._state === 'errored') {\r\n      throw readable._storedError;\r\n    }\r\n    const readableController = readable._readableStreamController;\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\r\n      ReadableStreamDefaultControllerClose(readableController);\r\n    }\r\n  }).catch(r => {\r\n    TransformStreamError(stream, r);\r\n    throw readable._storedError;\r\n  });\r\n}\r\n\r\n// TransformStreamDefaultSource Algorithms\r\n\r\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\r\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\r\n\r\n  // Invariant. Enforced by the promises returned by start() and pull().\r\n  assert(stream._backpressure === true);\r\n\r\n  assert(stream._backpressureChangePromise !== undefined);\r\n\r\n  TransformStreamSetBackpressure(stream, false);\r\n\r\n  // Prevent the next pull() call until there is backpressure.\r\n  return stream._backpressureChangePromise;\r\n}\r\n\r\nmodule.exports = { CreateTransformStream, TransformStream };\r\n\r\n// Helper functions for the TransformStreamDefaultController.\r\n\r\nfunction defaultControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\r\n}\r\n\r\n// Helper functions for the TransformStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(\r\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\r\n}\r\n","import {\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  ReadableStream,\n  TransformStream,\n  WritableStream\n} from './ponyfill';\nimport { globals } from './utils';\n\n// Export\nexport * from './ponyfill';\n\nconst exports = {\n  ReadableStream,\n  WritableStream,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  TransformStream\n};\n\n// Add classes to global scope\nif (typeof globals !== 'undefined') {\n  Object.assign(globals, exports);\n}\n"],"names":["NumberIsInteger","Number","isInteger","value","isFinite","Math","floor","FakeSymbol","Symbol","iterator","description","noop","globals","self","window","global","NumberIsNaN","isNaN","x","isFakeDetached","Call","F","V","args","TypeError","Function","prototype","apply","call","PromiseCall","Promise","resolve","reject","o","p","v","defineProperty","elements","slice","dest","destOffset","src","srcOffset","n","Uint8Array","set","done","obj","exports","IsNonNegativeNumber","Infinity","Number.isNaN","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","fullArgs","arg","concat","O","P","transferredIshVersion","highWaterMark","RangeError","size","chunk","assert","AssertionError","e","IsFiniteNonNegativeNumber","require$$0","pair","container","_queue","shift","_queueTotalSize","push","CreateAlgorithmFromUnderlyingMethod","require$$1","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","typeIsObject","rethrowAssertionErrorRejection","require$$2","DequeueValue","require$$3","EnqueueValueWithSize","PeekQueueValue","ResetQueue","AbortSteps","ErrorSteps","WritableStream","underlyingSink","this","type","sizeAlgorithm","stream","controller","Object","create","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","abort","reason","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","getWriter","AcquireWritableStreamDefaultWriter","startAlgorithm","writer","_ownerWritableStream","state","_state","WritableStreamCloseQueuedOrInFlight","_storedError","WritableStreamDefaultWriterClose","WritableStreamDefaultWriter","InitializeWritableStream","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","_promise","wasAlreadyErroring","promise","WritableStreamDealWithRejection","error","WritableStreamStartErroring","WritableStreamHasOperationMarkedInFlight","_started","WritableStreamFinishErroring","storedError","_reject","abortRequest","_wasAlreadyErroring","_reason","then","_resolve","WritableStreamFinishInFlightClose","_closedPromise_resolve","_closedPromise_reject","_closedPromiseState","WritableStreamRejectCloseAndClosedPromiseIfNeeded","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","_readyPromise","_readyPromise_resolve","_readyPromise_reject","_readyPromiseState","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterAbort","close","releaseLock","write","WritableStreamDefaultWriterWrite","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","closeRequest","WritableStreamDefaultWriterEnsureClosedPromiseRejected","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamDefaultWriterRelease","releasedError","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerGetChunkSize","writeRequest","WritableStreamAddWriteRequest","writeRecord","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","IsWritableStreamDefaultController","_abortAlgorithm","SetUpWritableStreamDefaultController","_strategyHWM","_writeAlgorithm","_closeAlgorithm","startResult","r","WritableStreamDefaultControllerAdvanceQueueIfNeeded","length","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerError","name","defaultWriterClosedPromiseInitialize","defaultWriterClosedPromiseReject","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterReadyPromiseResolve","ArrayBufferCopy","CreateIterResultObject","IsDetachedBuffer","TransferArrayBuffer","createArrayFromList","WritableStreamDefaultWriterCloseWithErrorPropagation","CancelSteps","PullSteps","ReadableStream","underlyingSource","String","underlyingByteSource","ReadableByteStreamController","pullAlgorithm","cancelAlgorithm","autoAllocateChunkSize","Number.isInteger","ReadableStreamDefaultController","cancel","IsReadableStream","IsReadableStreamLocked","ReadableStreamCancel","getReader","mode","AcquireReadableStreamDefaultReader","ReadableStreamBYOBReader","AcquireReadableStreamBYOBReader","pipeThrough","options","writable","readable","pipeTo","preventClose","preventAbort","preventCancel","Boolean","reader","shuttingDown","currentWrite","_this","action","destClosed","waitForWritesToFinish","oldCurrentWrite","isOrBecomesErrored","shutdownWithAction","originalIsError","originalError","doTheRest","finalize","newError","shutdown","isError","pipeLoop","ReadableStreamDefaultReaderRead","err","tee","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","closedOrErrored","canceled1","canceled2","cancelPromise","result","_readableStreamController","value1","value2","CreateReadableStream","compositeReason","cancelResult","ReadableStreamTee","_disturbed","ReadableStreamDefaultControllerShouldCallPull","ReadableStreamDefaultReader","InitializeReadableStream","_reader","ReadableStreamAddReadIntoRequest","readIntoRequest","_readIntoRequests","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamClose","IsReadableStreamDefaultReader","ReadableStreamError","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","IsReadableStreamBYOBReader","ReadableStreamHasDefaultReader","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","read","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","_controlledReadableByteStream","elementSize","constructor","DataView","BYTES_PER_ELEMENT","ctor","pullIntoDescriptor","byteOffset","_pendingPullIntos","emptyView","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","_closeRequested","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","ReadableStreamReaderGenericInitialize","ReadableStreamReaderGenericRelease","IsReadableStreamDefaultController","defaultControllerBrandCheckException","ReadableStreamDefaultControllerCanCloseOrEnqueue","enqueue","ReadableStreamDefaultControllerEnqueue","_cancelAlgorithm","_controlledReadableStream","pendingPromise","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCallPullIfNeeded","_pulling","_pullAlgorithm","_pullAgain","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerError","SetUpReadableStreamDefaultController","ReadableStreamBYOBRequest","respond","bytesWritten","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_associatedReadableByteStreamController","_view","respondWithNewView","firstDescriptor","bytesFilled","byteStreamControllerBrandCheckException","firstPendingPullInto","transferredBuffer","transferredView","entry","viewE","_autoAllocateChunkSize","bufferE","_byobRequest","byobRequest","request","ReadableByteStreamControllerGetDesiredSize","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerCommitPullIntoDescriptor","readerType","ReadableByteStreamControllerEnqueueChunkToQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerHandleQueueDrain","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerShiftPendingPullInto","remainderSize","end","remainder","descriptor","ReadableByteStreamControllerError","SetUpReadableByteStreamController","defaultReaderClosedPromiseReject","createDataProperty","ReadableStreamDefaultControllerHasBackpressure","CreateWritableStream","TransformStream","transformer","writableStrategy","readableStrategy","readableType","writableType","writableSizeFunction","writableSizeAlgorithm","writableHighWaterMark","startPromise_resolve","readableSizeFunction","readableSizeAlgorithm","readableHighWaterMark","TransformStreamDefaultController","transformAlgorithm","transformResultE","transformMethod","transform","transformPromise","flushAlgorithm","_transformStreamController","IsTransformStream","_readable","_writable","InitializeTransformStream","startPromise","backpressureChangePromise","_backpressureChangePromise","_transformAlgorithm","TransformStreamDefaultSinkWriteAlgorithm","_flushAlgorithm","readableController","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSourcePullAlgorithm","_backpressureChangePromise_resolve","TransformStreamError","TransformStreamErrorWritableAndUnblockWrite","TransformStreamSetBackpressure","IsTransformStreamDefaultController","_controlledTransformStream","terminate","SetUpTransformStreamDefaultController","TransformStreamDefaultControllerEnqueue"],"mappings":"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"}