"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:e=>`Symbol(${e})`;function t(){}const o=Number.isNaN||function(e){return e!=e};function n(e,r){return e(r={exports:{}},r.exports),r.exports}var a=n(function(e,t){const n=r('is "detached" for our purposes');function a(e,r,t){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,r,t)}function i(e,r,t){try{return Promise.resolve(a(e,r,t))}catch(e){return Promise.reject(e)}}t.typeIsObject=(e=>"object"==typeof e&&null!==e||"function"==typeof e),t.createDataProperty=((e,r,t)=>{Object.defineProperty(e,r,{value:t,writable:!0,enumerable:!0,configurable:!0})}),t.createArrayFromList=(e=>e.slice()),t.ArrayBufferCopy=((e,r,t,o,n)=>{new Uint8Array(e).set(new Uint8Array(t,o,n),r)}),t.CreateIterResultObject=((e,r)=>{const t={};return Object.defineProperty(t,"value",{value:e,enumerable:!0,writable:!0,configurable:!0}),Object.defineProperty(t,"done",{value:r,enumerable:!0,writable:!0,configurable:!0}),t}),t.IsFiniteNonNegativeNumber=(e=>!1!==t.IsNonNegativeNumber(e)&&e!==1/0),t.IsNonNegativeNumber=(e=>"number"==typeof e&&(!o(e)&&!(e<0))),t.Call=a,t.CreateAlgorithmFromUnderlyingMethod=((e,r,t,o)=>{const n=e[r];if(void 0!==n){if("function"!=typeof n)throw new TypeError(`${n} is not a method`);switch(t){case 0:return()=>i(n,e,o);case 1:return r=>{const t=[r].concat(o);return i(n,e,t)}}}return()=>Promise.resolve()}),t.InvokeOrNoop=((e,r,t)=>{const o=e[r];if(void 0!==o)return a(o,e,t)}),t.PromiseCall=i,t.TransferArrayBuffer=(e=>{const r=e.slice();return Object.defineProperty(e,"byteLength",{get:()=>0}),e[n]=!0,r}),t.IsDetachedBuffer=(e=>n in e),t.ValidateAndNormalizeHighWaterMark=(e=>{if(e=Number(e),o(e)||e<0)throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");return e}),t.MakeSizeAlgorithmFromSizeFunction=(e=>{if(void 0===e)return()=>1;if("function"!=typeof e)throw new TypeError("size property of a queuing strategy must be a function");return r=>e(r)})}),i=a.typeIsObject,s=a.createDataProperty,l=a.createArrayFromList,c=a.ArrayBufferCopy,u=a.CreateIterResultObject,d=a.IsFiniteNonNegativeNumber,f=a.IsNonNegativeNumber,m=a.Call,_=a.CreateAlgorithmFromUnderlyingMethod,h=a.InvokeOrNoop,b=a.PromiseCall,y=a.TransferArrayBuffer,p=a.IsDetachedBuffer,w=a.ValidateAndNormalizeHighWaterMark,S=a.MakeSizeAlgorithmFromSizeFunction,g={default:a,__moduleExports:a,typeIsObject:i,createDataProperty:s,createArrayFromList:l,ArrayBufferCopy:c,CreateIterResultObject:u,IsFiniteNonNegativeNumber:d,IsNonNegativeNumber:f,Call:m,CreateAlgorithmFromUnderlyingMethod:_,InvokeOrNoop:h,PromiseCall:b,TransferArrayBuffer:y,IsDetachedBuffer:p,ValidateAndNormalizeHighWaterMark:w,MakeSizeAlgorithmFromSizeFunction:S};function v(){}v.AssertionError=t;var R={default:v},P=R&&v||R,q=e=>{e&&e instanceof P.AssertionError&&setTimeout(()=>{throw e},0)},C={rethrowAssertionErrorRejection:q},T={default:C,__moduleExports:C,rethrowAssertionErrorRejection:q},j=g&&a||g;const{IsFiniteNonNegativeNumber:E}=j;var W=e=>{const r=e._queue.shift();return e._queueTotalSize-=r.size,e._queueTotalSize<0&&(e._queueTotalSize=0),r.value},A=(e,r,t)=>{if(t=Number(t),!E(t))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:r,size:t}),e._queueTotalSize+=t},O=e=>{return e._queue[0].value},B=e=>{e._queue=[],e._queueTotalSize=0},z={DequeueValue:W,EnqueueValueWithSize:A,PeekQueueValue:O,ResetQueue:B},k={default:z,__moduleExports:z,DequeueValue:W,EnqueueValueWithSize:A,PeekQueueValue:O,ResetQueue:B},I={default:t},F=I&&t||I,D=T&&C||T,N=k&&z||k;const M=F("streams:writable-stream:verbose"),{CreateAlgorithmFromUnderlyingMethod:L,InvokeOrNoop:V,ValidateAndNormalizeHighWaterMark:Y,IsNonNegativeNumber:x,MakeSizeAlgorithmFromSizeFunction:$,typeIsObject:H}=j,{rethrowAssertionErrorRejection:Q}=D,{DequeueValue:U,EnqueueValueWithSize:G,PeekQueueValue:J,ResetQueue:K}=N,X=r("[[AbortSteps]]"),Z=r("[[ErrorSteps]]");class WritableStream{constructor(e={},{size:r,highWaterMark:t=1}={}){if(oe(this),void 0!==e.type)throw new RangeError("Invalid type is specified");const o=$(r);Oe(this,e,t=Y(t),o)}get locked(){if(!1===ne(this))throw Ye("locked");return ae(this)}abort(e){return!1===ne(this)?Promise.reject(Ye("abort")):!0===ae(this)?Promise.reject(new TypeError("Cannot abort a stream that already has a writer")):ie(this,e)}getWriter(){if(!1===ne(this))throw Ye("getWriter");return re(this)}}var ee={AcquireWritableStreamDefaultWriter:re,CreateWritableStream:te,IsWritableStream:ne,IsWritableStreamLocked:ae,WritableStream:WritableStream,WritableStreamAbort:ie,WritableStreamDefaultControllerErrorIfNeeded:De,WritableStreamDefaultWriterCloseWithErrorPropagation:Pe,WritableStreamDefaultWriterRelease:je,WritableStreamDefaultWriterWrite:Ee,WritableStreamCloseQueuedOrInFlight:he};function re(e){return new WritableStreamDefaultWriter(e)}function te(e,r,t,o,n=1,a=(()=>1)){const i=Object.create(WritableStream.prototype);return oe(i),Ae(i,Object.create(WritableStreamDefaultController.prototype),e,r,t,o,n,a),i}function oe(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=[],e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function ne(e){return!!H(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")}function ae(e){return void 0!==e._writer}function ie(e,r){const t=e._state;if("closed"===t||"errored"===t)return Promise.resolve(void 0);if(void 0!==e._pendingAbortRequest)return e._pendingAbortRequest._promise;let o=!1;"erroring"===t&&(o=!0,r=void 0);const n=new Promise((t,n)=>{e._pendingAbortRequest={_resolve:t,_reject:n,_reason:r,_wasAlreadyErroring:o}});return e._pendingAbortRequest._promise=n,!1===o&&ce(e,r),n}function se(e){return new Promise((r,t)=>{const o={_resolve:r,_reject:t};e._writeRequests.push(o)})}function le(e,r){"writable"!==e._state?ue(e):ce(e,r)}function ce(e,r){const t=e._writableStreamController;e._state="erroring",e._storedError=r;const o=e._writer;void 0!==o&&Ce(o,r),!1===be(e)&&!0===t._started&&ue(e)}function ue(e){e._state="errored",e._writableStreamController[Z]();const r=e._storedError;for(const t of e._writeRequests)t._reject(r);if(e._writeRequests=[],void 0===e._pendingAbortRequest)return void we(e);const t=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,!0===t._wasAlreadyErroring)return t._reject(r),void we(e);e._writableStreamController[X](t._reason).then(()=>{t._resolve(),we(e)},r=>{t._reject(r),we(e)})}function de(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0}function fe(e,r){e._inFlightWriteRequest._reject(r),e._inFlightWriteRequest=void 0,le(e,r)}function me(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,"erroring"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const r=e._writer;void 0!==r&&Ke(r)}function _e(e,r){e._inFlightCloseRequest._reject(r),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(r),e._pendingAbortRequest=void 0),le(e,r)}function he(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function be(e){return void 0!==e._inFlightWriteRequest||void 0!==e._inFlightCloseRequest}function ye(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0}function pe(e){e._inFlightWriteRequest=e._writeRequests.shift()}function we(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const r=e._writer;void 0!==r&&(Ge(r,e._storedError),r._closedPromise.catch(()=>{}))}function Se(e,r){const t=e._writer;void 0!==t&&r!==e._backpressure&&(!0===r?tr(t):nr(t)),e._backpressure=r}class WritableStreamDefaultWriter{constructor(e){if(!1===ne(e))throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");if(!0===ae(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const r=e._state;if("writable"===r)!1===he(e)&&!0===e._backpressure?Xe(this):er(this),He(this);else if("erroring"===r)Ze(this,e._storedError),this._readyPromise.catch(()=>{}),He(this);else if("closed"===r)er(this),Ue(this);else{const r=e._storedError;Ze(this,r),this._readyPromise.catch(()=>{}),Qe(this,r),this._closedPromise.catch(()=>{})}}get closed(){return!1===ge(this)?Promise.reject(xe("closed")):this._closedPromise}get desiredSize(){if(!1===ge(this))throw xe("desiredSize");if(void 0===this._ownerWritableStream)throw $e("desiredSize");return Te(this)}get ready(){return!1===ge(this)?Promise.reject(xe("ready")):this._readyPromise}abort(e){return!1===ge(this)?Promise.reject(xe("abort")):void 0===this._ownerWritableStream?Promise.reject($e("abort")):ve(this,e)}close(){if(!1===ge(this))return Promise.reject(xe("close"));const e=this._ownerWritableStream;return void 0===e?Promise.reject($e("close")):!0===he(e)?Promise.reject(new TypeError("cannot close an already-closing stream")):Re(this)}releaseLock(){if(!1===ge(this))throw xe("releaseLock");void 0!==this._ownerWritableStream&&je(this)}write(e){return!1===ge(this)?Promise.reject(xe("write")):void 0===this._ownerWritableStream?Promise.reject($e("write to")):Ee(this,e)}}function ge(e){return!!H(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")}function ve(e,r){return ie(e._ownerWritableStream,r)}function Re(e){const r=e._ownerWritableStream,t=r._state;if("closed"===t||"errored"===t)return Promise.reject(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const o=new Promise((e,t)=>{const o={_resolve:e,_reject:t};r._closeRequest=o});return!0===r._backpressure&&"writable"===t&&nr(e),Be(r._writableStreamController),o}function Pe(e){const r=e._ownerWritableStream,t=r._state;return!0===he(r)||"closed"===t?Promise.resolve():"errored"===t?Promise.reject(r._storedError):Re(e)}function qe(e,r){"pending"===e._closedPromiseState?Ge(e,r):Je(e,r),e._closedPromise.catch(()=>{})}function Ce(e,r){"pending"===e._readyPromiseState?rr(e,r):or(e,r),e._readyPromise.catch(()=>{})}function Te(e){const r=e._ownerWritableStream,t=r._state;return"errored"===t||"erroring"===t?null:"closed"===t?0:ke(r._writableStreamController)}function je(e){const r=e._ownerWritableStream,t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");Ce(e,t),qe(e,t),r._writer=void 0,e._ownerWritableStream=void 0}function Ee(e,r){const t=e._ownerWritableStream,o=t._writableStreamController,n=ze(o,r);if(t!==e._ownerWritableStream)return Promise.reject($e("write to"));const a=t._state;if("errored"===a)return Promise.reject(t._storedError);if(!0===he(t)||"closed"===a)return Promise.reject(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===a)return Promise.reject(t._storedError);const i=se(t);return Ie(o,r,n),i}class WritableStreamDefaultController{constructor(){throw new TypeError("WritableStreamDefaultController cannot be constructed explicitly")}error(e){if(!1===We(this))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");"writable"===this._controlledWritableStream._state&&Ve(this,e)}[X](e){return this._abortAlgorithm(e)}[Z](){K(this)}}function We(e){return!!H(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream")}function Ae(e,r,t,o,n,a,i,s){r._controlledWritableStream=e,e._writableStreamController=r,r._queue=void 0,r._queueTotalSize=void 0,K(r),r._started=!1,r._strategySizeAlgorithm=s,r._strategyHWM=i,r._writeAlgorithm=o,r._closeAlgorithm=n,r._abortAlgorithm=a;const l=Le(r);Se(e,l);const c=t();Promise.resolve(c).then(()=>{r._started=!0,Fe(r)},t=>{r._started=!0,le(e,t)}).catch(Q)}function Oe(e,r,t,o){const n=Object.create(WritableStreamDefaultController.prototype);const a=L(r,"write",1,[n]),i=L(r,"close",0,[]),s=L(r,"abort",1,[]);Ae(e,n,function(){return V(r,"start",[n])},a,i,s,t,o)}function Be(e){G(e,"close",0),Fe(e)}function ze(e,r){try{return e._strategySizeAlgorithm(r)}catch(r){return De(e,r),1}}function ke(e){return e._strategyHWM-e._queueTotalSize}function Ie(e,r,t){const o={chunk:r};try{G(e,o,t)}catch(r){return void De(e,r)}const n=e._controlledWritableStream;if(!1===he(n)&&"writable"===n._state){Se(n,Le(e))}Fe(e)}function Fe(e){const r=e._controlledWritableStream;if(!1===e._started)return;if(void 0!==r._inFlightWriteRequest)return;const t=r._state;if("closed"===t||"errored"===t)return;if("erroring"===t)return void ue(r);if(0===e._queue.length)return;const o=J(e);"close"===o?Ne(e):Me(e,o.chunk)}function De(e,r){"writable"===e._controlledWritableStream._state&&Ve(e,r)}function Ne(e){const r=e._controlledWritableStream;ye(r),U(e),e._closeAlgorithm().then(()=>{me(r)},e=>{_e(r,e)}).catch(Q)}function Me(e,r){const t=e._controlledWritableStream;pe(t),e._writeAlgorithm(r).then(()=>{de(t);const r=t._state;if(U(e),!1===he(t)&&"writable"===r){const r=Le(e);Se(t,r)}Fe(e)},e=>{fe(t,e)}).catch(Q)}function Le(e){return ke(e)<=0}function Ve(e,r){ce(e._controlledWritableStream,r)}function Ye(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function xe(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function $e(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function He(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t,e._closedPromiseState="pending"})}function Qe(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}function Ue(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}function Ge(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}function Je(e,r){e._closedPromise=Promise.reject(r),e._closedPromiseState="rejected"}function Ke(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}function Xe(e){e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}function Ze(e,r){e._readyPromise=Promise.reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}function er(e){e._readyPromise=Promise.resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}function rr(e,r){e._readyPromise_reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}function tr(e){e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}function or(e,r){e._readyPromise=Promise.reject(r),e._readyPromiseState="rejected"}function nr(e){e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}var ar=ee.WritableStream;const{ArrayBufferCopy:ir,CreateAlgorithmFromUnderlyingMethod:sr,CreateIterResultObject:lr,IsFiniteNonNegativeNumber:cr,InvokeOrNoop:ur,IsDetachedBuffer:dr,TransferArrayBuffer:fr,ValidateAndNormalizeHighWaterMark:mr,IsNonNegativeNumber:_r,MakeSizeAlgorithmFromSizeFunction:hr,createArrayFromList:br,typeIsObject:yr}=j,{rethrowAssertionErrorRejection:pr}=D,{DequeueValue:wr,EnqueueValueWithSize:Sr,ResetQueue:gr}=N,{AcquireWritableStreamDefaultWriter:vr,IsWritableStream:Rr,IsWritableStreamLocked:Pr,WritableStreamAbort:qr,WritableStreamDefaultWriterCloseWithErrorPropagation:Cr,WritableStreamDefaultWriterRelease:Tr,WritableStreamDefaultWriterWrite:jr,WritableStreamCloseQueuedOrInFlight:Er}=ee,Wr=r("[[CancelSteps]]"),Ar=r("[[PullSteps]]");class ReadableStream{constructor(e={},{size:r,highWaterMark:t}={}){Fr(this);const o=e.type;if("bytes"===String(o)){if(void 0===t&&(t=0),t=mr(t),void 0!==r)throw new RangeError("The strategy for a byte stream cannot have a size function");Vt(this,e,t)}else{if(void 0!==o)throw new RangeError("Invalid type is specified");void 0===t&&(t=1),bt(this,e,t=mr(t),hr(r))}}get locked(){if(!1===Dr(this))throw xt("locked");return Mr(this)}cancel(e){return!1===Dr(this)?Promise.reject(xt("cancel")):!0===Mr(this)?Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")):xr(this,e)}getReader({mode:e}={}){if(!1===Dr(this))throw xt("getReader");if(void 0===e)return zr(this);if("byob"===(e=String(e)))return Br(this);throw new RangeError("Invalid mode is specified")}pipeThrough({writable:e,readable:r},t){if(void 0===e||void 0===r)throw new TypeError("readable and writable arguments must be defined");return oo(this.pipeTo(e,t)),r}pipeTo(e,{preventClose:r,preventAbort:t,preventCancel:o}={}){if(!1===Dr(this))return Promise.reject(xt("pipeTo"));if(!1===Rr(e))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));if(r=Boolean(r),t=Boolean(t),o=Boolean(o),!0===Mr(this))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));if(!0===Pr(e))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));const n=zr(this),a=vr(e);let i=!1,s=Promise.resolve();return new Promise((l,c)=>{if(d(this,n._closedPromise,r=>{!1===t?f(()=>qr(e,r),!0,r):m(!0,r)}),d(e,a._closedPromise,e=>{!1===o?f(()=>xr(this,e),!0,e):m(!0,e)}),function(e,r,t){"closed"===e._state?t():r.then(t).catch(pr)}(this,n._closedPromise,()=>{!1===r?f(()=>Cr(a)):m()}),!0===Er(e)||"closed"===e._state){const e=new TypeError("the destination writable stream closed before all data could be piped to it");!1===o?f(()=>xr(this,e),!0,e):m(!0,e)}function u(){const e=s;return s.then(()=>e!==s?u():void 0)}function d(e,r,t){"errored"===e._state?t(e._storedError):r.catch(t).catch(pr)}function f(r,t,o){function n(){r().then(()=>_(t,o),e=>_(!0,e)).catch(pr)}!0!==i&&(i=!0,"writable"===e._state&&!1===Er(e)?u().then(n):n())}function m(r,t){!0!==i&&(i=!0,"writable"===e._state&&!1===Er(e)?u().then(()=>_(r,t)).catch(pr):_(r,t))}function _(e,r){Tr(a),ot(n),e?c(r):l(void 0)}(function e(){return!0===i?Promise.resolve():a._readyPromise.then(()=>at(n).then(({value:e,done:r})=>{!0!==r&&(s=jr(a,e).catch(()=>{}))})).then(e)})().catch(e=>{s=Promise.resolve(),pr(e)})})}tee(){if(!1===Dr(this))throw xt("tee");const e=Lr(this,!1);return br(e)}}var Or={CreateReadableByteStream:Ir,CreateReadableStream:kr,ReadableStream:ReadableStream,IsReadableStreamDisturbed:Nr,ReadableStreamDefaultControllerClose:ct,ReadableStreamDefaultControllerEnqueue:ut,ReadableStreamDefaultControllerError:dt,ReadableStreamDefaultControllerGetDesiredSize:ft,ReadableStreamDefaultControllerHasBackpressure:mt,ReadableStreamDefaultControllerCanCloseOrEnqueue:_t};function Br(e){return new ReadableStreamBYOBReader(e)}function zr(e){return new ReadableStreamDefaultReader(e)}function kr(e,r,t,o=1,n=(()=>1)){const a=Object.create(ReadableStream.prototype);return Fr(a),ht(a,Object.create(ReadableStreamDefaultController.prototype),e,r,t,o,n),a}function Ir(e,r,t,o=0,n){const a=Object.create(ReadableStream.prototype);return Fr(a),Lt(a,Object.create(ReadableByteStreamController.prototype),e,r,t,o,n),a}function Fr(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function Dr(e){return!!yr(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")}function Nr(e){return e._disturbed}function Mr(e){return void 0!==e._reader}function Lr(e,r){const t=zr(e);let o,n,a,i,s,l=!1,c=!1,u=!1;const d=new Promise(e=>{s=e});function f(){return at(t).then(e=>{const r=e.value;if(!0===e.done&&!1===l&&(!1===c&&ct(a._readableStreamController),!1===u&&ct(i._readableStreamController),l=!0),!0===l)return;const t=r,o=r;!1===c&&ut(a._readableStreamController,t),!1===u&&ut(i._readableStreamController,o)})}function m(){}return a=kr(m,f,function(r){if(c=!0,o=r,!0===u){const r=br([o,n]),t=xr(e,r);s(t)}return d}),i=kr(m,f,function(r){if(u=!0,n=r,!0===c){const r=br([o,n]),t=xr(e,r);s(t)}return d}),t._closedPromise.catch(e=>{!0!==l&&(dt(a._readableStreamController,e),dt(i._readableStreamController,e),l=!0)}),[a,i]}function Vr(e){return new Promise((r,t)=>{const o={_resolve:r,_reject:t};e._reader._readIntoRequests.push(o)})}function Yr(e){return new Promise((r,t)=>{const o={_resolve:r,_reject:t};e._reader._readRequests.push(o)})}function xr(e,r){if(e._disturbed=!0,"closed"===e._state)return Promise.resolve(void 0);if("errored"===e._state)return Promise.reject(e._storedError);return $r(e),e._readableStreamController[Wr](r).then(()=>void 0)}function $r(e){e._state="closed";const r=e._reader;if(void 0!==r){if(!0===et(r)){for(const{_resolve:e}of r._readRequests)e(lr(void 0,!0));r._readRequests=[]}Xt(r)}}function Hr(e,r){e._state="errored",e._storedError=r;const t=e._reader;if(void 0!==t){if(!0===et(t)){for(const e of t._readRequests)e._reject(r);t._readRequests=[]}else{for(const e of t._readIntoRequests)e._reject(r);t._readIntoRequests=[]}Jt(t,r),t._closedPromise.catch(()=>{})}}function Qr(e,r,t){e._reader._readIntoRequests.shift()._resolve(lr(r,t))}function Ur(e,r,t){e._reader._readRequests.shift()._resolve(lr(r,t))}function Gr(e){return e._reader._readIntoRequests.length}function Jr(e){return e._reader._readRequests.length}function Kr(e){const r=e._reader;return void 0!==r&&!1!==Zr(r)}function Xr(e){const r=e._reader;return void 0!==r&&!1!==et(r)}class ReadableStreamDefaultReader{constructor(e){if(!1===Dr(e))throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");if(!0===Mr(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");rt(this,e),this._readRequests=[]}get closed(){return!1===et(this)?Promise.reject(Ht("closed")):this._closedPromise}cancel(e){return!1===et(this)?Promise.reject(Ht("cancel")):void 0===this._ownerReadableStream?Promise.reject($t("cancel")):tt(this,e)}read(){return!1===et(this)?Promise.reject(Ht("read")):void 0===this._ownerReadableStream?Promise.reject($t("read from")):at(this)}releaseLock(){if(!1===et(this))throw Ht("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ot(this)}}}class ReadableStreamBYOBReader{constructor(e){if(!Dr(e))throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");if(!1===yt(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");if(Mr(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");rt(this,e),this._readIntoRequests=[]}get closed(){return Zr(this)?this._closedPromise:Promise.reject(Zt("closed"))}cancel(e){return Zr(this)?void 0===this._ownerReadableStream?Promise.reject($t("cancel")):tt(this,e):Promise.reject(Zt("cancel"))}read(e){return Zr(this)?void 0===this._ownerReadableStream?Promise.reject($t("read from")):ArrayBuffer.isView(e)?!0===dr(e.buffer)?Promise.reject(new TypeError("Cannot read into a view onto a detached ArrayBuffer")):0===e.byteLength?Promise.reject(new TypeError("view must have non-zero byteLength")):nt(this,e):Promise.reject(new TypeError("view must be an array buffer view")):Promise.reject(Zt("read"))}releaseLock(){if(!Zr(this))throw Zt("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ot(this)}}}function Zr(e){return!!yr(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")}function et(e){return!!yr(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")}function rt(e,r){e._ownerReadableStream=r,r._reader=e,"readable"===r._state?Qt(e):"closed"===r._state?Gt(e):(Ut(e,r._storedError),e._closedPromise.catch(()=>{}))}function tt(e,r){return xr(e._ownerReadableStream,r)}function ot(e){"readable"===e._ownerReadableStream._state?Jt(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):Kt(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._closedPromise.catch(()=>{}),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function nt(e,r){const t=e._ownerReadableStream;return t._disturbed=!0,"errored"===t._state?Promise.reject(t._storedError):Et(t._readableStreamController,r)}function at(e){const r=e._ownerReadableStream;return r._disturbed=!0,"closed"===r._state?Promise.resolve(lr(void 0,!0)):"errored"===r._state?Promise.reject(r._storedError):r._readableStreamController[Ar]()}class ReadableStreamDefaultController{constructor(){throw new TypeError}get desiredSize(){if(!1===it(this))throw eo("desiredSize");return ft(this)}close(){if(!1===it(this))throw eo("close");if(!1===_t(this))throw new TypeError("The stream is not in a state that permits close");ct(this)}enqueue(e){if(!1===it(this))throw eo("enqueue");if(!1===_t(this))throw new TypeError("The stream is not in a state that permits enqueue");return ut(this,e)}error(e){if(!1===it(this))throw eo("error");dt(this,e)}[Wr](e){return gr(this),this._cancelAlgorithm(e)}[Ar](){const e=this._controlledReadableStream;if(this._queue.length>0){const r=wr(this);return!0===this._closeRequested&&0===this._queue.length?$r(e):st(this),Promise.resolve(lr(r,!1))}const r=Yr(e);return st(this),r}}function it(e){return!!yr(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")}function st(e){!1!==lt(e)&&(!0!==e._pulling?(e._pulling=!0,e._pullAlgorithm().then(()=>{if(e._pulling=!1,!0===e._pullAgain)return e._pullAgain=!1,st(e)},r=>{dt(e,r)}).catch(pr)):e._pullAgain=!0)}function lt(e){const r=e._controlledReadableStream;return!1!==_t(e)&&(!1!==e._started&&(!0===Mr(r)&&Jr(r)>0||ft(e)>0))}function ct(e){const r=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&$r(r)}function ut(e,r){const t=e._controlledReadableStream;if(!0===Mr(t)&&Jr(t)>0)Ur(t,r,!1);else{let t;try{t=e._strategySizeAlgorithm(r)}catch(r){throw dt(e,r),r}try{Sr(e,r,t)}catch(r){throw dt(e,r),r}}st(e)}function dt(e,r){const t=e._controlledReadableStream;"readable"===t._state&&(gr(e),Hr(t,r))}function ft(e){const r=e._controlledReadableStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function mt(e){return!0!==lt(e)}function _t(e){const r=e._controlledReadableStream._state;return!1===e._closeRequested&&"readable"===r}function ht(e,r,t,o,n,a,i){r._controlledReadableStream=e,r._queue=void 0,r._queueTotalSize=void 0,gr(r),r._started=!1,r._closeRequested=!1,r._pullAgain=!1,r._pulling=!1,r._strategySizeAlgorithm=i,r._strategyHWM=a,r._pullAlgorithm=o,r._cancelAlgorithm=n,e._readableStreamController=r;const s=t();Promise.resolve(s).then(()=>{r._started=!0,st(r)},e=>{dt(r,e)}).catch(pr)}function bt(e,r,t,o){const n=Object.create(ReadableStreamDefaultController.prototype);const a=sr(r,"pull",0,[n]),i=sr(r,"cancel",1,[]);ht(e,n,function(){return ur(r,"start",[n])},a,i,t,o)}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("ReadableStreamBYOBRequest cannot be used directly")}get view(){if(!1===pt(this))throw ro("view");return this._view}respond(e){if(!1===pt(this))throw ro("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!0===dr(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");Nt(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!1===pt(this))throw ro("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(!0===dr(e.buffer))throw new TypeError("The supplied view's buffer has been detached and so cannot be used as a response");Mt(this._associatedReadableByteStreamController,e)}}class ReadableByteStreamController{constructor(){throw new TypeError("ReadableByteStreamController constructor cannot be used directly")}get byobRequest(){if(!1===yt(this))throw to("byobRequest");if(void 0===this._byobRequest&&this._pendingPullIntos.length>0){const e=this._pendingPullIntos[0],r=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled),t=Object.create(ReadableStreamBYOBRequest.prototype);Yt(t,this,r),this._byobRequest=t}return this._byobRequest}get desiredSize(){if(!1===yt(this))throw to("desiredSize");return Dt(this)}close(){if(!1===yt(this))throw to("close");if(!0===this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if("readable"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);kt(this)}enqueue(e){if(!1===yt(this))throw to("enqueue");if(!0===this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if("readable"!==r)throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);if(!ArrayBuffer.isView(e))throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");if(!0===dr(e.buffer))throw new TypeError("Cannot enqueue a view onto a detached ArrayBuffer");It(this,e)}error(e){if(!1===yt(this))throw to("error");Ft(this,e)}[Wr](e){if(this._pendingPullIntos.length>0){this._pendingPullIntos[0].bytesFilled=0}return gr(this),this._cancelAlgorithm(e)}[Ar](){const e=this._controlledReadableByteStream;if(this._queueTotalSize>0){const e=this._queue.shift();let r;this._queueTotalSize-=e.byteLength,Ct(this);try{r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}catch(e){return Promise.reject(e)}return Promise.resolve(lr(r,!1))}const r=this._autoAllocateChunkSize;if(void 0!==r){let e;try{e=new ArrayBuffer(r)}catch(e){return Promise.reject(e)}const t={buffer:e,byteOffset:0,byteLength:r,bytesFilled:0,elementSize:1,ctor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(t)}const t=Yr(e);return wt(this),t}}function yt(e){return!!yr(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")}function pt(e){return!!yr(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")}function wt(e){!1!==zt(e)&&(!0!==e._pulling?(e._pulling=!0,e._pullAlgorithm().then(()=>{e._pulling=!1,!0===e._pullAgain&&(e._pullAgain=!1,wt(e))},r=>{Ft(e,r)}).catch(pr)):e._pullAgain=!0)}function St(e){Tt(e),e._pendingPullIntos=[]}function gt(e,r){let t=!1;"closed"===e._state&&(t=!0);const o=vt(r);"default"===r.readerType?Ur(e,o,t):Qr(e,o,t)}function vt(e){const r=e.bytesFilled,t=e.elementSize;return new e.ctor(e.buffer,e.byteOffset,r/t)}function Rt(e,r,t,o){e._queue.push({buffer:r,byteOffset:t,byteLength:o}),e._queueTotalSize+=o}function Pt(e,r){const t=r.elementSize,o=r.bytesFilled-r.bytesFilled%t,n=Math.min(e._queueTotalSize,r.byteLength-r.bytesFilled),a=r.bytesFilled+n,i=a-a%t;let s=n,l=!1;i>o&&(s=i-r.bytesFilled,l=!0);const c=e._queue;for(;s>0;){const t=c[0],o=Math.min(s,t.byteLength),n=r.byteOffset+r.bytesFilled;ir(r.buffer,n,t.buffer,t.byteOffset,o),t.byteLength===o?c.shift():(t.byteOffset+=o,t.byteLength-=o),e._queueTotalSize-=o,qt(e,o,r),s-=o}return l}function qt(e,r,t){Tt(e),t.bytesFilled+=r}function Ct(e){0===e._queueTotalSize&&!0===e._closeRequested?$r(e._controlledReadableByteStream):wt(e)}function Tt(e){void 0!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=void 0,e._byobRequest=void 0)}function jt(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const r=e._pendingPullIntos[0];!0===Pt(e,r)&&(Bt(e),gt(e._controlledReadableByteStream,r))}}function Et(e,r){const t=e._controlledReadableByteStream;let o=1;r.constructor!==DataView&&(o=r.constructor.BYTES_PER_ELEMENT);const n=r.constructor,a={buffer:fr(r.buffer),byteOffset:r.byteOffset,byteLength:r.byteLength,bytesFilled:0,elementSize:o,ctor:n,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(a),Vr(t);if("closed"===t._state){const e=new r.constructor(a.buffer,a.byteOffset,0);return Promise.resolve(lr(e,!0))}if(e._queueTotalSize>0){if(!0===Pt(e,a)){const r=vt(a);return Ct(e),Promise.resolve(lr(r,!1))}if(!0===e._closeRequested){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");return Ft(e,r),Promise.reject(r)}}e._pendingPullIntos.push(a);const i=Vr(t);return wt(e),i}function Wt(e,r){r.buffer=fr(r.buffer);const t=e._controlledReadableByteStream;if(!0===Kr(t))for(;Gr(t)>0;){gt(t,Bt(e))}}function At(e,r,t){if(t.bytesFilled+r>t.byteLength)throw new RangeError("bytesWritten out of range");if(qt(e,r,t),t.bytesFilled<t.elementSize)return;Bt(e);const o=t.bytesFilled%t.elementSize;if(o>0){const r=t.byteOffset+t.bytesFilled,n=t.buffer.slice(r-o,r);Rt(e,n,0,n.byteLength)}t.buffer=fr(t.buffer),t.bytesFilled-=o,gt(e._controlledReadableByteStream,t),jt(e)}function Ot(e,r){const t=e._pendingPullIntos[0];if("closed"===e._controlledReadableByteStream._state){if(0!==r)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");Wt(e,t)}else At(e,r,t);wt(e)}function Bt(e){const r=e._pendingPullIntos.shift();return Tt(e),r}function zt(e){const r=e._controlledReadableByteStream;return"readable"===r._state&&(!0!==e._closeRequested&&(!1!==e._started&&(!0===Xr(r)&&Jr(r)>0||(!0===Kr(r)&&Gr(r)>0||Dt(e)>0))))}function kt(e){const r=e._controlledReadableByteStream;if(e._queueTotalSize>0)e._closeRequested=!0;else{if(e._pendingPullIntos.length>0){if(e._pendingPullIntos[0].bytesFilled>0){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");throw Ft(e,r),r}}$r(r)}}function It(e,r){const t=e._controlledReadableByteStream,o=r.buffer,n=r.byteOffset,a=r.byteLength,i=fr(o);if(!0===Xr(t))if(0===Jr(t))Rt(e,i,n,a);else{Ur(t,new Uint8Array(i,n,a),!1)}else!0===Kr(t)?(Rt(e,i,n,a),jt(e)):Rt(e,i,n,a);wt(e)}function Ft(e,r){const t=e._controlledReadableByteStream;"readable"===t._state&&(St(e),gr(e),Hr(t,r))}function Dt(e){const r=e._controlledReadableByteStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function Nt(e,r){if(r=Number(r),!1===cr(r))throw new RangeError("bytesWritten must be a finite");Ot(e,r)}function Mt(e,r){const t=e._pendingPullIntos[0];if(t.byteOffset+t.bytesFilled!==r.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.byteLength!==r.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");t.buffer=r.buffer,Ot(e,r.byteLength)}function Lt(e,r,t,o,n,a,i){r._controlledReadableByteStream=e,r._pullAgain=!1,r._pulling=!1,St(r),r._queue=r._queueTotalSize=void 0,gr(r),r._closeRequested=!1,r._started=!1,r._strategyHWM=mr(a),r._pullAlgorithm=o,r._cancelAlgorithm=n,r._autoAllocateChunkSize=i,r._pendingPullIntos=[],e._readableStreamController=r;const s=t();Promise.resolve(s).then(()=>{r._started=!0,wt(r)},e=>{Ft(r,e)}).catch(pr)}function Vt(r,t,o){const n=Object.create(ReadableByteStreamController.prototype);const a=sr(t,"pull",0,[n]),i=sr(t,"cancel",1,[]),s=t.autoAllocateChunkSize;if(void 0!==s&&(!1===e(s)||s<=0))throw new RangeError("autoAllocateChunkSize must be a positive integer");Lt(r,n,function(){return ur(t,"start",[n])},a,i,o,s)}function Yt(e,r,t){e._associatedReadableByteStreamController=r,e._view=t}function xt(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function $t(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function Ht(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}function Qt(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t})}function Ut(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function Gt(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function Jt(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function Kt(e,r){e._closedPromise=Promise.reject(r)}function Xt(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function Zt(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function eo(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function ro(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function to(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function oo(e){try{Promise.prototype.then.call(e,void 0,()=>{})}catch(e){}}var no=Or.ReadableStream;const{createDataProperty:ao}=j;var io=class ByteLengthQueuingStrategy{constructor({highWaterMark:e}){ao(this,"highWaterMark",e)}size(e){return e.byteLength}};const{createDataProperty:so}=j;var lo=class CountQueuingStrategy{constructor({highWaterMark:e}){so(this,"highWaterMark",e)}size(){return 1}};const co=F("streams:transform-stream:verbose"),{InvokeOrNoop:uo,CreateAlgorithmFromUnderlyingMethod:fo,PromiseCall:mo,typeIsObject:_o,ValidateAndNormalizeHighWaterMark:ho,IsNonNegativeNumber:bo,MakeSizeAlgorithmFromSizeFunction:yo}=j,{CreateReadableStream:po,ReadableStreamDefaultControllerClose:wo,ReadableStreamDefaultControllerEnqueue:So,ReadableStreamDefaultControllerError:go,ReadableStreamDefaultControllerGetDesiredSize:vo,ReadableStreamDefaultControllerHasBackpressure:Ro,ReadableStreamDefaultControllerCanCloseOrEnqueue:Po}=Or,{CreateWritableStream:qo,WritableStreamDefaultControllerErrorIfNeeded:Co}=ee;class TransformStream{constructor(e={},r={},t={}){if(void 0!==e.readableType)throw new RangeError("Invalid readable type specified");if(void 0!==e.writableType)throw new RangeError("Invalid writable type specified");const o=r.size,n=yo(o);let a=r.highWaterMark;void 0===a&&(a=1),a=ho(a);const i=t.size,s=yo(i);let l,c=t.highWaterMark;void 0===c&&(c=0),c=ho(c),jo(this,new Promise(e=>{l=e}),a,n,c,s),ko(this,e);const u=uo(e,"start",[this._transformStreamController]);l(u)}get readable(){if(!1===Eo(this))throw $o("readable");return this._readable}get writable(){if(!1===Eo(this))throw $o("writable");return this._writable}}function To(e,r,t,o=1,n=(()=>1),a=0,i=(()=>1)){const s=Object.create(TransformStream.prototype);let l;jo(s,new Promise(e=>{l=e}),o,n,a,i),zo(s,Object.create(TransformStreamDefaultController.prototype),r,t);const c=e();return l(c),s}function jo(e,r,t,o,n,a){function i(){return r}e._writable=qo(i,function(r){return No(e,r)},function(){return Lo(e)},function(r){return Mo(e,r)},t,o),e._readable=po(i,function(){return Vo(e)},function(r){return Ao(e,r),Promise.resolve()},n,a),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,Oo(e,!0),e._transformStreamController=void 0}function Eo(e){return!!_o(e)&&!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")}function Wo(e,r){go(e._readable._readableStreamController,r),Ao(e,r)}function Ao(e,r){Co(e._writable._writableStreamController,r),!0===e._backpressure&&Oo(e,!1)}function Oo(e,r){void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=new Promise(r=>{e._backpressureChangePromise_resolve=r}),e._backpressure=r}class TransformStreamDefaultController{constructor(){throw new TypeError("TransformStreamDefaultController instances cannot be created directly")}get desiredSize(){if(!1===Bo(this))throw xo("desiredSize");const e=this._controlledTransformStream._readable._readableStreamController;return vo(e)}enqueue(e){if(!1===Bo(this))throw xo("enqueue");Io(this,e)}error(e){if(!1===Bo(this))throw xo("error");Fo(this,e)}terminate(){if(!1===Bo(this))throw xo("terminate");Do(this)}}function Bo(e){return!!_o(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")}function zo(e,r,t,o){r._controlledTransformStream=e,e._transformStreamController=r,r._transformAlgorithm=t,r._flushAlgorithm=o}function ko(e,r){const t=Object.create(TransformStreamDefaultController.prototype);let o=e=>{try{return Io(t,e),Promise.resolve()}catch(e){return Promise.reject(e)}};const n=r.transform;if(void 0!==n){if("function"!=typeof n)throw new TypeError("transform is not a method");o=(o=>{return mo(n,r,[o,t]).catch(r=>{throw Wo(e,r),r})})}const a=fo(r,"flush",0,[t]);zo(e,t,o,a)}function Io(e,r){const t=e._controlledTransformStream,o=t._readable._readableStreamController;if(!1===Po(o))throw new TypeError("Readable side is not in a state that permits enqueue");try{So(o,r)}catch(e){throw Ao(t,e),t._readable._storedError}Ro(o)!==t._backpressure&&Oo(t,!0)}function Fo(e,r){Wo(e._controlledTransformStream,r)}function Do(e){const r=e._controlledTransformStream,t=r._readable._readableStreamController;!0===Po(t)&&wo(t),Ao(r,new TypeError("TransformStream terminated"))}function No(e,r){const t=e._transformStreamController;if(!0===e._backpressure){return e._backpressureChangePromise.then(()=>{const o=e._writable;if("erroring"===o._state)throw o._storedError;return t._transformAlgorithm(r)})}return t._transformAlgorithm(r)}function Mo(e,r){return Wo(e,r),Promise.resolve()}function Lo(e){const r=e._readable;return e._transformStreamController._flushAlgorithm().then(()=>{if("errored"===r._state)throw r._storedError;const e=r._readableStreamController;!0===Po(e)&&wo(e)}).catch(t=>{throw Wo(e,t),r._storedError})}function Vo(e){return Oo(e,!1),e._backpressureChangePromise}var Yo={CreateTransformStream:To,TransformStream:TransformStream};function xo(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function $o(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}var Ho=Yo.TransformStream;exports.ReadableStream=no,exports.WritableStream=ar,exports.ByteLengthQueuingStrategy=io,exports.CountQueuingStrategy=lo,exports.TransformStream=Ho;
//# sourceMappingURL=ponyfill.es6.cjs.min.js.map
