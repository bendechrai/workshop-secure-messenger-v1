{"version":3,"file":"polyfill.umd.js","sources":["../src/stub/number-isinteger.js","../src/stub/symbol.js","../src/utils.js","../src/stub/number-isnan.js","../spec/reference-implementation/lib/helpers.js","../src/stub/assert.js","../spec/reference-implementation/lib/utils.js","../spec/reference-implementation/lib/queue-with-sizes.js","../spec/reference-implementation/lib/writable-stream.js","../spec/reference-implementation/lib/readable-stream.js","../spec/reference-implementation/lib/byte-length-queuing-strategy.js","../spec/reference-implementation/lib/count-queuing-strategy.js","../spec/reference-implementation/lib/transform-stream.js","../src/polyfill.js"],"sourcesContent":["// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\nexport default NumberIsInteger;\n","const FakeSymbol = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n  Symbol :\n  description => `Symbol(${description})`;\n\nexport default FakeSymbol;\n","export function noop() {\n  // do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\r\n\r\nfunction IsPropertyKey(argument) {\r\n  return typeof argument === 'string' || typeof argument === 'symbol';\r\n}\r\n\r\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\r\n\r\nexports.createDataProperty = (o, p, v) => {\r\n  assert(exports.typeIsObject(o));\r\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\r\n};\r\n\r\nexports.createArrayFromList = elements => {\r\n  // We use arrays to represent lists, so this is basically a no-op.\r\n  // Do a slice though just in case we happen to depend on the unique-ness.\r\n  return elements.slice();\r\n};\r\n\r\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\r\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\r\n};\r\n\r\nexports.CreateIterResultObject = (value, done) => {\r\n  assert(typeof done === 'boolean');\r\n  const obj = {};\r\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\r\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\r\n  return obj;\r\n};\r\n\r\nexports.IsFiniteNonNegativeNumber = v => {\r\n  if (exports.IsNonNegativeNumber(v) === false) {\r\n    return false;\r\n  }\r\n\r\n  if (v === Infinity) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexports.IsNonNegativeNumber = v => {\r\n  if (typeof v !== 'number') {\r\n    return false;\r\n  }\r\n\r\n  if (Number.isNaN(v)) {\r\n    return false;\r\n  }\r\n\r\n  if (v < 0) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction Call(F, V, args) {\r\n  if (typeof F !== 'function') {\r\n    throw new TypeError('Argument is not a function');\r\n  }\r\n\r\n  return Function.prototype.apply.call(F, V, args);\r\n}\r\n\r\nexports.Call = Call;\r\n\r\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\r\n  assert(underlyingObject !== undefined);\r\n  assert(IsPropertyKey(methodName));\r\n  assert(algoArgCount === 0 || algoArgCount === 1);\r\n  assert(Array.isArray(extraArgs));\r\n  const method = underlyingObject[methodName];\r\n  if (method !== undefined) {\r\n    if (typeof method !== 'function') {\r\n      throw new TypeError(`${method} is not a method`);\r\n    }\r\n    switch (algoArgCount) {\r\n      case 0: {\r\n        return () => {\r\n          return PromiseCall(method, underlyingObject, extraArgs);\r\n        };\r\n      }\r\n\r\n      case 1: {\r\n        return arg => {\r\n          const fullArgs = [arg].concat(extraArgs);\r\n          return PromiseCall(method, underlyingObject, fullArgs);\r\n        };\r\n      }\r\n    }\r\n  }\r\n  return () => Promise.resolve();\r\n};\r\n\r\nexports.InvokeOrNoop = (O, P, args) => {\r\n  assert(O !== undefined);\r\n  assert(IsPropertyKey(P));\r\n  assert(Array.isArray(args));\r\n\r\n  const method = O[P];\r\n  if (method === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  return Call(method, O, args);\r\n};\r\n\r\nfunction PromiseCall(F, V, args) {\r\n  assert(typeof F === 'function');\r\n  assert(V !== undefined);\r\n  assert(Array.isArray(args));\r\n  try {\r\n    return Promise.resolve(Call(F, V, args));\r\n  } catch (value) {\r\n    return Promise.reject(value);\r\n  }\r\n}\r\n\r\nexports.PromiseCall = PromiseCall;\r\n\r\n// Not implemented correctly\r\nexports.TransferArrayBuffer = O => {\r\n  assert(!exports.IsDetachedBuffer(O));\r\n  const transferredIshVersion = O.slice();\r\n\r\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\r\n  // ArrayBuffer and checking if its byteLength starts returning 0.\r\n  Object.defineProperty(O, 'byteLength', {\r\n    get() {\r\n      return 0;\r\n    }\r\n  });\r\n  O[isFakeDetached] = true;\r\n\r\n  return transferredIshVersion;\r\n};\r\n\r\n// Not implemented correctly\r\nexports.IsDetachedBuffer = O => {\r\n  return isFakeDetached in O;\r\n};\r\n\r\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\r\n  highWaterMark = Number(highWaterMark);\r\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\r\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\r\n  }\r\n\r\n  return highWaterMark;\r\n};\r\n\r\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\r\n  if (size === undefined) {\r\n    return () => 1;\r\n  }\r\n  if (typeof size !== 'function') {\r\n    throw new TypeError('size property of a queuing strategy must be a function');\r\n  }\r\n  return chunk => size(chunk);\r\n};\r\n","import { noop } from '../utils';\n\nexport default function assert() {\n  // do nothing\n}\n\nassert.AssertionError = noop;\n","'use strict';\r\nconst assert = require('assert');\r\n\r\nexports.rethrowAssertionErrorRejection = e => {\r\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\r\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\r\n  // expect any errors, but assertion errors are always problematic.\r\n  if (e && e instanceof assert.AssertionError) {\r\n    setTimeout(() => {\r\n      throw e;\r\n    }, 0);\r\n  }\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\r\n\r\nexports.DequeueValue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n  assert(container._queue.length > 0);\r\n\r\n  const pair = container._queue.shift();\r\n  container._queueTotalSize -= pair.size;\r\n  if (container._queueTotalSize < 0) {\r\n    container._queueTotalSize = 0;\r\n  }\r\n\r\n  return pair.value;\r\n};\r\n\r\nexports.EnqueueValueWithSize = (container, value, size) => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n\r\n  size = Number(size);\r\n  if (!IsFiniteNonNegativeNumber(size)) {\r\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\r\n  }\r\n\r\n  container._queue.push({ value, size });\r\n  container._queueTotalSize += size;\r\n};\r\n\r\nexports.PeekQueueValue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n  assert(container._queue.length > 0);\r\n\r\n  const pair = container._queue[0];\r\n  return pair.value;\r\n};\r\n\r\nexports.ResetQueue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n\r\n  container._queue = [];\r\n  container._queueTotalSize = 0;\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\r\n// and do not appear in the standard text.\r\nconst verbose = require('debug')('streams:writable-stream:verbose');\r\n\r\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\r\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\r\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\r\n\r\nconst AbortSteps = Symbol('[[AbortSteps]]');\r\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\r\n\r\nclass WritableStream {\r\n  constructor(underlyingSink = {}, { size, highWaterMark = 1 } = {}) {\r\n    InitializeWritableStream(this);\r\n\r\n    const type = underlyingSink.type;\r\n\r\n    if (type !== undefined) {\r\n      throw new RangeError('Invalid type is specified');\r\n    }\r\n\r\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\r\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\r\n  }\r\n\r\n  get locked() {\r\n    if (IsWritableStream(this) === false) {\r\n      throw streamBrandCheckException('locked');\r\n    }\r\n\r\n    return IsWritableStreamLocked(this);\r\n  }\r\n\r\n  abort(reason) {\r\n    if (IsWritableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('abort'));\r\n    }\r\n\r\n    if (IsWritableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\r\n    }\r\n\r\n    return WritableStreamAbort(this, reason);\r\n  }\r\n\r\n  getWriter() {\r\n    if (IsWritableStream(this) === false) {\r\n      throw streamBrandCheckException('getWriter');\r\n    }\r\n\r\n    return AcquireWritableStreamDefaultWriter(this);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  AcquireWritableStreamDefaultWriter,\r\n  CreateWritableStream,\r\n  IsWritableStream,\r\n  IsWritableStreamLocked,\r\n  WritableStream,\r\n  WritableStreamAbort,\r\n  WritableStreamDefaultControllerErrorIfNeeded,\r\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\r\n  WritableStreamDefaultWriterRelease,\r\n  WritableStreamDefaultWriterWrite,\r\n  WritableStreamCloseQueuedOrInFlight\r\n};\r\n\r\n// Abstract operations for the WritableStream.\r\n\r\nfunction AcquireWritableStreamDefaultWriter(stream) {\r\n  return new WritableStreamDefaultWriter(stream);\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\r\n                              sizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n\r\n  const stream = Object.create(WritableStream.prototype);\r\n  InitializeWritableStream(stream);\r\n\r\n  const controller = Object.create(WritableStreamDefaultController.prototype);\r\n\r\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\r\n  return stream;\r\n}\r\n\r\nfunction InitializeWritableStream(stream) {\r\n  stream._state = 'writable';\r\n\r\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\r\n  // 'erroring' or 'errored'. May be set to an undefined value.\r\n  stream._storedError = undefined;\r\n\r\n  stream._writer = undefined;\r\n\r\n  // Initialize to undefined first because the constructor of the controller checks this\r\n  // variable to validate the caller.\r\n  stream._writableStreamController = undefined;\r\n\r\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\r\n  // producer without waiting for the queued writes to finish.\r\n  stream._writeRequests = [];\r\n\r\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\r\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\r\n  stream._inFlightWriteRequest = undefined;\r\n\r\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\r\n  // has been detached.\r\n  stream._closeRequest = undefined;\r\n\r\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\r\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\r\n  stream._pendingAbortRequest = undefined;\r\n\r\n  // The backpressure signal set by the controller.\r\n  stream._backpressure = false;\r\n}\r\n\r\nfunction IsWritableStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsWritableStreamLocked(stream) {\r\n  assert(IsWritableStream(stream) === true);\r\n\r\n  if (stream._writer === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamAbort(stream, reason) {\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return Promise.resolve(undefined);\r\n  }\r\n  if (stream._pendingAbortRequest !== undefined) {\r\n    return stream._pendingAbortRequest._promise;\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  let wasAlreadyErroring = false;\r\n  if (state === 'erroring') {\r\n    wasAlreadyErroring = true;\r\n    // reason will not be used, so don't keep a reference to it.\r\n    reason = undefined;\r\n  }\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    stream._pendingAbortRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject,\r\n      _reason: reason,\r\n      _wasAlreadyErroring: wasAlreadyErroring\r\n    };\r\n  });\r\n  stream._pendingAbortRequest._promise = promise;\r\n\r\n  if (wasAlreadyErroring === false) {\r\n    WritableStreamStartErroring(stream, reason);\r\n  }\r\n\r\n  return promise;\r\n}\r\n\r\n// WritableStream API exposed for controllers.\r\n\r\nfunction WritableStreamAddWriteRequest(stream) {\r\n  assert(IsWritableStreamLocked(stream) === true);\r\n  assert(stream._state === 'writable');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const writeRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._writeRequests.push(writeRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction WritableStreamDealWithRejection(stream, error) {\r\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\r\n  const state = stream._state;\r\n\r\n  if (state === 'writable') {\r\n    WritableStreamStartErroring(stream, error);\r\n    return;\r\n  }\r\n\r\n  assert(state === 'erroring');\r\n  WritableStreamFinishErroring(stream);\r\n}\r\n\r\nfunction WritableStreamStartErroring(stream, reason) {\r\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\r\n  assert(stream._storedError === undefined);\r\n  assert(stream._state === 'writable');\r\n\r\n  const controller = stream._writableStreamController;\r\n  assert(controller !== undefined);\r\n\r\n  stream._state = 'erroring';\r\n  stream._storedError = reason;\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\r\n  }\r\n\r\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\r\n    WritableStreamFinishErroring(stream);\r\n  }\r\n}\r\n\r\nfunction WritableStreamFinishErroring(stream) {\r\n  verbose('WritableStreamFinishErroring()');\r\n  assert(stream._state === 'erroring');\r\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\r\n  stream._state = 'errored';\r\n  stream._writableStreamController[ErrorSteps]();\r\n\r\n  const storedError = stream._storedError;\r\n  for (const writeRequest of stream._writeRequests) {\r\n    writeRequest._reject(storedError);\r\n  }\r\n  stream._writeRequests = [];\r\n\r\n  if (stream._pendingAbortRequest === undefined) {\r\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n    return;\r\n  }\r\n\r\n  const abortRequest = stream._pendingAbortRequest;\r\n  stream._pendingAbortRequest = undefined;\r\n\r\n  if (abortRequest._wasAlreadyErroring === true) {\r\n    abortRequest._reject(storedError);\r\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n    return;\r\n  }\r\n\r\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\r\n  promise.then(\r\n      () => {\r\n        abortRequest._resolve();\r\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n      },\r\n      reason => {\r\n        abortRequest._reject(reason);\r\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n      });\r\n}\r\n\r\nfunction WritableStreamFinishInFlightWrite(stream) {\r\n  assert(stream._inFlightWriteRequest !== undefined);\r\n  stream._inFlightWriteRequest._resolve(undefined);\r\n  stream._inFlightWriteRequest = undefined;\r\n}\r\n\r\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\r\n  assert(stream._inFlightWriteRequest !== undefined);\r\n  stream._inFlightWriteRequest._reject(error);\r\n  stream._inFlightWriteRequest = undefined;\r\n\r\n  assert(stream._state === 'writable' || stream._state === 'erroring');\r\n\r\n  WritableStreamDealWithRejection(stream, error);\r\n}\r\n\r\nfunction WritableStreamFinishInFlightClose(stream) {\r\n  assert(stream._inFlightCloseRequest !== undefined);\r\n  stream._inFlightCloseRequest._resolve(undefined);\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  const state = stream._state;\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  if (state === 'erroring') {\r\n    // The error was too late to do anything, so it is ignored.\r\n    stream._storedError = undefined;\r\n    if (stream._pendingAbortRequest !== undefined) {\r\n      stream._pendingAbortRequest._resolve();\r\n      stream._pendingAbortRequest = undefined;\r\n    }\r\n  }\r\n\r\n  stream._state = 'closed';\r\n\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    defaultWriterClosedPromiseResolve(writer);\r\n  }\r\n\r\n  assert(stream._pendingAbortRequest === undefined);\r\n  assert(stream._storedError === undefined);\r\n}\r\n\r\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\r\n  assert(stream._inFlightCloseRequest !== undefined);\r\n  stream._inFlightCloseRequest._reject(error);\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  assert(stream._state === 'writable' || stream._state === 'erroring');\r\n\r\n  // Never execute sink abort() after sink close().\r\n  if (stream._pendingAbortRequest !== undefined) {\r\n    stream._pendingAbortRequest._reject(error);\r\n    stream._pendingAbortRequest = undefined;\r\n  }\r\n  WritableStreamDealWithRejection(stream, error);\r\n}\r\n\r\n// TODO(ricea): Fix alphabetical order.\r\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\r\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\r\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\r\n    return false;\r\n  }\r\n\r\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\r\n  assert(stream._inFlightCloseRequest === undefined);\r\n  assert(stream._closeRequest !== undefined);\r\n  stream._inFlightCloseRequest = stream._closeRequest;\r\n  stream._closeRequest = undefined;\r\n}\r\n\r\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\r\n  assert(stream._inFlightWriteRequest === undefined);\r\n  assert(stream._writeRequests.length !== 0);\r\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\r\n}\r\n\r\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\r\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\r\n  assert(stream._state === 'errored');\r\n  if (stream._closeRequest !== undefined) {\r\n    assert(stream._inFlightCloseRequest === undefined);\r\n\r\n    stream._closeRequest._reject(stream._storedError);\r\n    stream._closeRequest = undefined;\r\n  }\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\r\n    writer._closedPromise.catch(() => {});\r\n  }\r\n}\r\n\r\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\r\n  assert(stream._state === 'writable');\r\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\r\n\r\n  const writer = stream._writer;\r\n  if (writer !== undefined && backpressure !== stream._backpressure) {\r\n    if (backpressure === true) {\r\n      defaultWriterReadyPromiseReset(writer);\r\n    } else {\r\n      assert(backpressure === false);\r\n\r\n      defaultWriterReadyPromiseResolve(writer);\r\n    }\r\n  }\r\n\r\n  stream._backpressure = backpressure;\r\n}\r\n\r\nclass WritableStreamDefaultWriter {\r\n  constructor(stream) {\r\n    if (IsWritableStream(stream) === false) {\r\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\r\n    }\r\n    if (IsWritableStreamLocked(stream) === true) {\r\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\r\n    }\r\n\r\n    this._ownerWritableStream = stream;\r\n    stream._writer = this;\r\n\r\n    const state = stream._state;\r\n\r\n    if (state === 'writable') {\r\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\r\n        defaultWriterReadyPromiseInitialize(this);\r\n      } else {\r\n        defaultWriterReadyPromiseInitializeAsResolved(this);\r\n      }\r\n\r\n      defaultWriterClosedPromiseInitialize(this);\r\n    } else if (state === 'erroring') {\r\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\r\n      this._readyPromise.catch(() => {});\r\n      defaultWriterClosedPromiseInitialize(this);\r\n    } else if (state === 'closed') {\r\n      defaultWriterReadyPromiseInitializeAsResolved(this);\r\n      defaultWriterClosedPromiseInitializeAsResolved(this);\r\n    } else {\r\n      assert(state === 'errored');\r\n\r\n      const storedError = stream._storedError;\r\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\r\n      this._readyPromise.catch(() => {});\r\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\r\n      this._closedPromise.catch(() => {});\r\n    }\r\n  }\r\n\r\n  get closed() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      throw defaultWriterBrandCheckException('desiredSize');\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      throw defaultWriterLockException('desiredSize');\r\n    }\r\n\r\n    return WritableStreamDefaultWriterGetDesiredSize(this);\r\n  }\r\n\r\n  get ready() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\r\n    }\r\n\r\n    return this._readyPromise;\r\n  }\r\n\r\n  abort(reason) {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('abort'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterAbort(this, reason);\r\n  }\r\n\r\n  close() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('close'));\r\n    }\r\n\r\n    const stream = this._ownerWritableStream;\r\n\r\n    if (stream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('close'));\r\n    }\r\n\r\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\r\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterClose(this);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      throw defaultWriterBrandCheckException('releaseLock');\r\n    }\r\n\r\n    const stream = this._ownerWritableStream;\r\n\r\n    if (stream === undefined) {\r\n      return;\r\n    }\r\n\r\n    assert(stream._writer !== undefined);\r\n\r\n    WritableStreamDefaultWriterRelease(this);\r\n  }\r\n\r\n  write(chunk) {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('write'));\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('write to'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterWrite(this, chunk);\r\n  }\r\n}\r\n\r\n// Abstract operations for the WritableStreamDefaultWriter.\r\n\r\nfunction IsWritableStreamDefaultWriter(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\r\n\r\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  return WritableStreamAbort(stream, reason);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterClose(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return Promise.reject(new TypeError(\r\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const closeRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._closeRequest = closeRequest;\r\n  });\r\n\r\n  if (stream._backpressure === true && state === 'writable') {\r\n    defaultWriterReadyPromiseResolve(writer);\r\n  }\r\n\r\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\r\n\r\n  return promise;\r\n}\r\n\r\n\r\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const state = stream._state;\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\r\n    return Promise.resolve();\r\n  }\r\n\r\n  if (state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  return WritableStreamDefaultWriterClose(writer);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\r\n  if (writer._closedPromiseState === 'pending') {\r\n    defaultWriterClosedPromiseReject(writer, error);\r\n  } else {\r\n    defaultWriterClosedPromiseResetToRejected(writer, error);\r\n  }\r\n  writer._closedPromise.catch(() => {});\r\n}\r\n\r\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\r\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\r\n  if (writer._readyPromiseState === 'pending') {\r\n    defaultWriterReadyPromiseReject(writer, error);\r\n  } else {\r\n    defaultWriterReadyPromiseResetToRejected(writer, error);\r\n  }\r\n  writer._readyPromise.catch(() => {});\r\n}\r\n\r\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored' || state === 'erroring') {\r\n    return null;\r\n  }\r\n\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterRelease(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n  assert(stream !== undefined);\r\n  assert(stream._writer === writer);\r\n\r\n  const releasedError = new TypeError(\r\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\r\n\r\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\r\n\r\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\r\n  // rejected until afterwards. This means that simply testing state will not work.\r\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\r\n\r\n  stream._writer = undefined;\r\n  writer._ownerWritableStream = undefined;\r\n}\r\n\r\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const controller = stream._writableStreamController;\r\n\r\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\r\n\r\n  if (stream !== writer._ownerWritableStream) {\r\n    return Promise.reject(defaultWriterLockException('write to'));\r\n  }\r\n\r\n  const state = stream._state;\r\n  if (state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\r\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\r\n  }\r\n  if (state === 'erroring') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(state === 'writable');\r\n\r\n  const promise = WritableStreamAddWriteRequest(stream);\r\n\r\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\r\n\r\n  return promise;\r\n}\r\n\r\nclass WritableStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\r\n  }\r\n\r\n  error(e) {\r\n    if (IsWritableStreamDefaultController(this) === false) {\r\n      throw new TypeError(\r\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\r\n    }\r\n    const state = this._controlledWritableStream._state;\r\n    if (state !== 'writable') {\r\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\r\n      // just treat it as a no-op.\r\n      return;\r\n    }\r\n\r\n    WritableStreamDefaultControllerError(this, e);\r\n  }\r\n\r\n  [AbortSteps](reason) {\r\n    return this._abortAlgorithm(reason);\r\n  }\r\n\r\n  [ErrorSteps]() {\r\n    ResetQueue(this);\r\n  }\r\n}\r\n\r\n// Abstract operations implementing interface required by the WritableStream.\r\n\r\nfunction IsWritableStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\r\n  assert(IsWritableStream(stream) === true);\r\n  assert(stream._writableStreamController === undefined);\r\n\r\n  controller._controlledWritableStream = stream;\r\n  stream._writableStreamController = controller;\r\n\r\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\r\n  controller._queue = undefined;\r\n  controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._started = false;\r\n\r\n  controller._strategySizeAlgorithm = sizeAlgorithm;\r\n  controller._strategyHWM = highWaterMark;\r\n\r\n  controller._writeAlgorithm = writeAlgorithm;\r\n  controller._closeAlgorithm = closeAlgorithm;\r\n  controller._abortAlgorithm = abortAlgorithm;\r\n\r\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n  WritableStreamUpdateBackpressure(stream, backpressure);\r\n\r\n  const startResult = startAlgorithm();\r\n  const startPromise = Promise.resolve(startResult);\r\n  startPromise.then(\r\n      () => {\r\n        assert(stream._state === 'writable' || stream._state === 'erroring');\r\n        controller._started = true;\r\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n      },\r\n      r => {\r\n        assert(stream._state === 'writable' || stream._state === 'erroring');\r\n        controller._started = true;\r\n        WritableStreamDealWithRejection(stream, r);\r\n      }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\r\n  assert(underlyingSink !== undefined);\r\n\r\n  const controller = Object.create(WritableStreamDefaultController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\r\n  }\r\n\r\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\r\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\r\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\r\n\r\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerClose(controller) {\r\n  EnqueueValueWithSize(controller, 'close', 0);\r\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\r\n  try {\r\n    return controller._strategySizeAlgorithm(chunk);\r\n  } catch (chunkSizeE) {\r\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\r\n    return 1;\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\r\n  const writeRecord = { chunk };\r\n\r\n  try {\r\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\r\n  } catch (enqueueE) {\r\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\r\n    return;\r\n  }\r\n\r\n  const stream = controller._controlledWritableStream;\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\r\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n    WritableStreamUpdateBackpressure(stream, backpressure);\r\n  }\r\n\r\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n}\r\n\r\n// Abstract operations for the WritableStreamDefaultController.\r\n\r\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\r\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  if (controller._started === false) {\r\n    return;\r\n  }\r\n\r\n  if (stream._inFlightWriteRequest !== undefined) {\r\n    return;\r\n  }\r\n\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return;\r\n  }\r\n  if (state === 'erroring') {\r\n    WritableStreamFinishErroring(stream);\r\n    return;\r\n  }\r\n\r\n  if (controller._queue.length === 0) {\r\n    return;\r\n  }\r\n\r\n  const writeRecord = PeekQueueValue(controller);\r\n  if (writeRecord === 'close') {\r\n    WritableStreamDefaultControllerProcessClose(controller);\r\n  } else {\r\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\r\n  if (controller._controlledWritableStream._state === 'writable') {\r\n    WritableStreamDefaultControllerError(controller, error);\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerProcessClose(controller) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  WritableStreamMarkCloseRequestInFlight(stream);\r\n\r\n  DequeueValue(controller);\r\n  assert(controller._queue.length === 0);\r\n\r\n  const sinkClosePromise = controller._closeAlgorithm();\r\n  sinkClosePromise.then(\r\n    () => {\r\n      WritableStreamFinishInFlightClose(stream);\r\n    },\r\n    reason => {\r\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\r\n\r\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\r\n  sinkWritePromise.then(\r\n    () => {\r\n      WritableStreamFinishInFlightWrite(stream);\r\n\r\n      const state = stream._state;\r\n      assert(state === 'writable' || state === 'erroring');\r\n\r\n      DequeueValue(controller);\r\n\r\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\r\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n        WritableStreamUpdateBackpressure(stream, backpressure);\r\n      }\r\n\r\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n    },\r\n    reason => {\r\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\r\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\r\n  return desiredSize <= 0;\r\n}\r\n\r\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\r\n\r\nfunction WritableStreamDefaultControllerError(controller, error) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  assert(stream._state === 'writable');\r\n\r\n  WritableStreamStartErroring(stream, error);\r\n}\r\n\r\n// Helper functions for the WritableStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\r\n}\r\n\r\n// Helper functions for the WritableStreamDefaultWriter.\r\n\r\nfunction defaultWriterBrandCheckException(name) {\r\n  return new TypeError(\r\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\r\n}\r\n\r\nfunction defaultWriterLockException(name) {\r\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitialize(writer) {\r\n  writer._closedPromise = new Promise((resolve, reject) => {\r\n    writer._closedPromise_resolve = resolve;\r\n    writer._closedPromise_reject = reject;\r\n    writer._closedPromiseState = 'pending';\r\n  });\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\r\n  writer._closedPromise = Promise.reject(reason);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\r\n  writer._closedPromise = Promise.resolve(undefined);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'resolved';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseReject(writer, reason) {\r\n  assert(writer._closedPromise_resolve !== undefined);\r\n  assert(writer._closedPromise_reject !== undefined);\r\n  assert(writer._closedPromiseState === 'pending');\r\n\r\n  writer._closedPromise_reject(reason);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\r\n  assert(writer._closedPromise_resolve === undefined);\r\n  assert(writer._closedPromise_reject === undefined);\r\n  assert(writer._closedPromiseState !== 'pending');\r\n\r\n  writer._closedPromise = Promise.reject(reason);\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseResolve(writer) {\r\n  assert(writer._closedPromise_resolve !== undefined);\r\n  assert(writer._closedPromise_reject !== undefined);\r\n  assert(writer._closedPromiseState === 'pending');\r\n\r\n  writer._closedPromise_resolve(undefined);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'resolved';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitialize(writer) {\r\n  verbose('defaultWriterReadyPromiseInitialize()');\r\n  writer._readyPromise = new Promise((resolve, reject) => {\r\n    writer._readyPromise_resolve = resolve;\r\n    writer._readyPromise_reject = reject;\r\n  });\r\n  writer._readyPromiseState = 'pending';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\r\n  writer._readyPromise = Promise.reject(reason);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\r\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\r\n  writer._readyPromise = Promise.resolve(undefined);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'fulfilled';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseReject(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\r\n  assert(writer._readyPromise_resolve !== undefined);\r\n  assert(writer._readyPromise_reject !== undefined);\r\n\r\n  writer._readyPromise_reject(reason);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseReset(writer) {\r\n  verbose('defaultWriterReadyPromiseReset()');\r\n  assert(writer._readyPromise_resolve === undefined);\r\n  assert(writer._readyPromise_reject === undefined);\r\n\r\n  writer._readyPromise = new Promise((resolve, reject) => {\r\n    writer._readyPromise_resolve = resolve;\r\n    writer._readyPromise_reject = reject;\r\n  });\r\n  writer._readyPromiseState = 'pending';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\r\n  assert(writer._readyPromise_resolve === undefined);\r\n  assert(writer._readyPromise_reject === undefined);\r\n\r\n  writer._readyPromise = Promise.reject(reason);\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseResolve(writer) {\r\n  verbose('defaultWriterReadyPromiseResolve()');\r\n  assert(writer._readyPromise_resolve !== undefined);\r\n  assert(writer._readyPromise_reject !== undefined);\r\n\r\n  writer._readyPromise_resolve(undefined);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'fulfilled';\r\n}\r\n","'use strict';\r\nconst assert = require('better-assert');\r\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, CreateIterResultObject, IsFiniteNonNegativeNumber,\r\n        InvokeOrNoop, IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject } = require('./helpers.js');\r\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\r\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\r\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\r\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\r\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\r\n      require('./writable-stream.js');\r\n\r\nconst CancelSteps = Symbol('[[CancelSteps]]');\r\nconst PullSteps = Symbol('[[PullSteps]]');\r\n\r\nclass ReadableStream {\r\n  constructor(underlyingSource = {}, { size, highWaterMark } = {}) {\r\n    InitializeReadableStream(this);\r\n    const type = underlyingSource.type;\r\n    const typeString = String(type);\r\n    if (typeString === 'bytes') {\r\n      if (highWaterMark === undefined) {\r\n        highWaterMark = 0;\r\n      }\r\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n      if (size !== undefined) {\r\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\r\n      }\r\n\r\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\r\n    } else if (type === undefined) {\r\n      if (highWaterMark === undefined) {\r\n        highWaterMark = 1;\r\n      }\r\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\r\n\r\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\r\n    } else {\r\n      throw new RangeError('Invalid type is specified');\r\n    }\r\n  }\r\n\r\n  get locked() {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('locked');\r\n    }\r\n\r\n    return IsReadableStreamLocked(this);\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (IsReadableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (IsReadableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\r\n    }\r\n\r\n    return ReadableStreamCancel(this, reason);\r\n  }\r\n\r\n  getReader({ mode } = {}) {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('getReader');\r\n    }\r\n\r\n    if (mode === undefined) {\r\n      return AcquireReadableStreamDefaultReader(this);\r\n    }\r\n\r\n    mode = String(mode);\r\n\r\n    if (mode === 'byob') {\r\n      return AcquireReadableStreamBYOBReader(this);\r\n    }\r\n\r\n    throw new RangeError('Invalid mode is specified');\r\n  }\r\n\r\n  pipeThrough({ writable, readable }, options) {\r\n    if (writable === undefined || readable === undefined) {\r\n      throw new TypeError('readable and writable arguments must be defined');\r\n    }\r\n\r\n    const promise = this.pipeTo(writable, options);\r\n\r\n    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\r\n\r\n    return readable;\r\n  }\r\n\r\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\r\n    if (IsReadableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('pipeTo'));\r\n    }\r\n    if (IsWritableStream(dest) === false) {\r\n      return Promise.reject(\r\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\r\n    }\r\n\r\n    preventClose = Boolean(preventClose);\r\n    preventAbort = Boolean(preventAbort);\r\n    preventCancel = Boolean(preventCancel);\r\n\r\n    if (IsReadableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\r\n    }\r\n    if (IsWritableStreamLocked(dest) === true) {\r\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\r\n    }\r\n\r\n    const reader = AcquireReadableStreamDefaultReader(this);\r\n    const writer = AcquireWritableStreamDefaultWriter(dest);\r\n\r\n    let shuttingDown = false;\r\n\r\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\r\n    let currentWrite = Promise.resolve();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      // Using reader and writer, read all chunks from this and write them to dest\r\n      // - Backpressure must be enforced\r\n      // - Shutdown must stop all activity\r\n      function pipeLoop() {\r\n        if (shuttingDown === true) {\r\n          return Promise.resolve();\r\n        }\r\n\r\n        return writer._readyPromise.then(() => {\r\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\r\n            if (done === true) {\r\n              return;\r\n            }\r\n\r\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\r\n          });\r\n        })\r\n        .then(pipeLoop);\r\n      }\r\n\r\n      // Errors must be propagated forward\r\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\r\n        if (preventAbort === false) {\r\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\r\n        } else {\r\n          shutdown(true, storedError);\r\n        }\r\n      });\r\n\r\n      // Errors must be propagated backward\r\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\r\n        if (preventCancel === false) {\r\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\r\n        } else {\r\n          shutdown(true, storedError);\r\n        }\r\n      });\r\n\r\n      // Closing must be propagated forward\r\n      isOrBecomesClosed(this, reader._closedPromise, () => {\r\n        if (preventClose === false) {\r\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\r\n        } else {\r\n          shutdown();\r\n        }\r\n      });\r\n\r\n      // Closing must be propagated backward\r\n      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\r\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\r\n\r\n        if (preventCancel === false) {\r\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\r\n        } else {\r\n          shutdown(true, destClosed);\r\n        }\r\n      }\r\n\r\n      pipeLoop().catch(err => {\r\n        currentWrite = Promise.resolve();\r\n        rethrowAssertionErrorRejection(err);\r\n      });\r\n\r\n      function waitForWritesToFinish() {\r\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\r\n        // for that too.\r\n        const oldCurrentWrite = currentWrite;\r\n        return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\r\n      }\r\n\r\n      function isOrBecomesErrored(stream, promise, action) {\r\n        if (stream._state === 'errored') {\r\n          action(stream._storedError);\r\n        } else {\r\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function isOrBecomesClosed(stream, promise, action) {\r\n        if (stream._state === 'closed') {\r\n          action();\r\n        } else {\r\n          promise.then(action).catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function shutdownWithAction(action, originalIsError, originalError) {\r\n        if (shuttingDown === true) {\r\n          return;\r\n        }\r\n        shuttingDown = true;\r\n\r\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\r\n          waitForWritesToFinish().then(doTheRest);\r\n        } else {\r\n          doTheRest();\r\n        }\r\n\r\n        function doTheRest() {\r\n          action().then(\r\n            () => finalize(originalIsError, originalError),\r\n            newError => finalize(true, newError)\r\n          )\r\n          .catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function shutdown(isError, error) {\r\n        if (shuttingDown === true) {\r\n          return;\r\n        }\r\n        shuttingDown = true;\r\n\r\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\r\n          waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\r\n        } else {\r\n          finalize(isError, error);\r\n        }\r\n      }\r\n\r\n      function finalize(isError, error) {\r\n        WritableStreamDefaultWriterRelease(writer);\r\n        ReadableStreamReaderGenericRelease(reader);\r\n\r\n        if (isError) {\r\n          reject(error);\r\n        } else {\r\n          resolve(undefined);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  tee() {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('tee');\r\n    }\r\n\r\n    const branches = ReadableStreamTee(this, false);\r\n    return createArrayFromList(branches);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  CreateReadableByteStream,\r\n  CreateReadableStream,\r\n  ReadableStream,\r\n  IsReadableStreamDisturbed,\r\n  ReadableStreamDefaultControllerClose,\r\n  ReadableStreamDefaultControllerEnqueue,\r\n  ReadableStreamDefaultControllerError,\r\n  ReadableStreamDefaultControllerGetDesiredSize,\r\n  ReadableStreamDefaultControllerHasBackpressure,\r\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\r\n};\r\n\r\n// Abstract operations for the ReadableStream.\r\n\r\nfunction AcquireReadableStreamBYOBReader(stream) {\r\n  return new ReadableStreamBYOBReader(stream);\r\n}\r\n\r\nfunction AcquireReadableStreamDefaultReader(stream) {\r\n  return new ReadableStreamDefaultReader(stream);\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\r\n                              sizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n\r\n  const stream = Object.create(ReadableStream.prototype);\r\n  InitializeReadableStream(stream);\r\n\r\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\r\n\r\n  SetUpReadableStreamDefaultController(\r\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\r\n  );\r\n\r\n  return stream;\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\r\n                                  autoAllocateChunkSize = undefined) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\r\n    assert(autoAllocateChunkSize > 0);\r\n  }\r\n\r\n  const stream = Object.create(ReadableStream.prototype);\r\n  InitializeReadableStream(stream);\r\n\r\n  const controller = Object.create(ReadableByteStreamController.prototype);\r\n\r\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\r\n                                    autoAllocateChunkSize);\r\n\r\n  return stream;\r\n}\r\n\r\nfunction InitializeReadableStream(stream) {\r\n  stream._state = 'readable';\r\n  stream._reader = undefined;\r\n  stream._storedError = undefined;\r\n  stream._disturbed = false;\r\n}\r\n\r\nfunction IsReadableStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamDisturbed(stream) {\r\n  assert(IsReadableStream(stream) === true);\r\n\r\n  return stream._disturbed;\r\n}\r\n\r\nfunction IsReadableStreamLocked(stream) {\r\n  assert(IsReadableStream(stream) === true);\r\n\r\n  if (stream._reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamTee(stream, cloneForBranch2) {\r\n  assert(IsReadableStream(stream) === true);\r\n  assert(typeof cloneForBranch2 === 'boolean');\r\n\r\n  const reader = AcquireReadableStreamDefaultReader(stream);\r\n\r\n  let closedOrErrored = false;\r\n  let canceled1 = false;\r\n  let canceled2 = false;\r\n  let reason1;\r\n  let reason2;\r\n  let branch1;\r\n  let branch2;\r\n\r\n  let resolveCancelPromise;\r\n  const cancelPromise = new Promise(resolve => {\r\n    resolveCancelPromise = resolve;\r\n  });\r\n\r\n  function pullAlgorithm() {\r\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\r\n      assert(typeIsObject(result));\r\n      const value = result.value;\r\n      const done = result.done;\r\n      assert(typeof done === 'boolean');\r\n\r\n      if (done === true && closedOrErrored === false) {\r\n        if (canceled1 === false) {\r\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\r\n        }\r\n        if (canceled2 === false) {\r\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\r\n        }\r\n        closedOrErrored = true;\r\n      }\r\n\r\n      if (closedOrErrored === true) {\r\n        return;\r\n      }\r\n\r\n      const value1 = value;\r\n      const value2 = value;\r\n\r\n      // There is no way to access the cloning code right now in the reference implementation.\r\n      // If we add one then we'll need an implementation for serializable objects.\r\n      // if (canceled2 === false && cloneForBranch2 === true) {\r\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\r\n      // }\r\n\r\n      if (canceled1 === false) {\r\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\r\n      }\r\n\r\n      if (canceled2 === false) {\r\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\r\n      }\r\n    });\r\n  }\r\n\r\n  function cancel1Algorithm(reason) {\r\n    canceled1 = true;\r\n    reason1 = reason;\r\n    if (canceled2 === true) {\r\n      const compositeReason = createArrayFromList([reason1, reason2]);\r\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n      resolveCancelPromise(cancelResult);\r\n    }\r\n    return cancelPromise;\r\n  }\r\n\r\n  function cancel2Algorithm(reason) {\r\n    canceled2 = true;\r\n    reason2 = reason;\r\n    if (canceled1 === true) {\r\n      const compositeReason = createArrayFromList([reason1, reason2]);\r\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n      resolveCancelPromise(cancelResult);\r\n    }\r\n    return cancelPromise;\r\n  }\r\n\r\n  function startAlgorithm() {}\r\n\r\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\r\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\r\n\r\n  reader._closedPromise.catch(r => {\r\n    if (closedOrErrored === true) {\r\n      return;\r\n    }\r\n\r\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\r\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\r\n    closedOrErrored = true;\r\n  });\r\n\r\n  return [branch1, branch2];\r\n}\r\n\r\n// ReadableStream API exposed for controllers.\r\n\r\nfunction ReadableStreamAddReadIntoRequest(stream) {\r\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\r\n  assert(stream._state === 'readable' || stream._state === 'closed');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const readIntoRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._reader._readIntoRequests.push(readIntoRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableStreamAddReadRequest(stream) {\r\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\r\n  assert(stream._state === 'readable');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const readRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._reader._readRequests.push(readRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableStreamCancel(stream, reason) {\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'closed') {\r\n    return Promise.resolve(undefined);\r\n  }\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  ReadableStreamClose(stream);\r\n\r\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\r\n  return sourceCancelPromise.then(() => undefined);\r\n}\r\n\r\nfunction ReadableStreamClose(stream) {\r\n  assert(stream._state === 'readable');\r\n\r\n  stream._state = 'closed';\r\n\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === true) {\r\n    for (const { _resolve } of reader._readRequests) {\r\n      _resolve(CreateIterResultObject(undefined, true));\r\n    }\r\n    reader._readRequests = [];\r\n  }\r\n\r\n  defaultReaderClosedPromiseResolve(reader);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamError(stream, e) {\r\n  assert(IsReadableStream(stream) === true);\r\n  assert(stream._state === 'readable');\r\n\r\n  stream._state = 'errored';\r\n  stream._storedError = e;\r\n\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === true) {\r\n    for (const readRequest of reader._readRequests) {\r\n      readRequest._reject(e);\r\n    }\r\n\r\n    reader._readRequests = [];\r\n  } else {\r\n    assert(IsReadableStreamBYOBReader(reader));\r\n\r\n    for (const readIntoRequest of reader._readIntoRequests) {\r\n      readIntoRequest._reject(e);\r\n    }\r\n\r\n    reader._readIntoRequests = [];\r\n  }\r\n\r\n  defaultReaderClosedPromiseReject(reader, e);\r\n  reader._closedPromise.catch(() => {});\r\n}\r\n\r\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\r\n  const reader = stream._reader;\r\n\r\n  assert(reader._readIntoRequests.length > 0);\r\n\r\n  const readIntoRequest = reader._readIntoRequests.shift();\r\n  readIntoRequest._resolve(CreateIterResultObject(chunk, done));\r\n}\r\n\r\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\r\n  const reader = stream._reader;\r\n\r\n  assert(reader._readRequests.length > 0);\r\n\r\n  const readRequest = reader._readRequests.shift();\r\n  readRequest._resolve(CreateIterResultObject(chunk, done));\r\n}\r\n\r\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\r\n  return stream._reader._readIntoRequests.length;\r\n}\r\n\r\nfunction ReadableStreamGetNumReadRequests(stream) {\r\n  return stream._reader._readRequests.length;\r\n}\r\n\r\nfunction ReadableStreamHasBYOBReader(stream) {\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamBYOBReader(reader) === false) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamHasDefaultReader(stream) {\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === false) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// Readers\r\n\r\nclass ReadableStreamDefaultReader {\r\n  constructor(stream) {\r\n    if (IsReadableStream(stream) === false) {\r\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\r\n    }\r\n    if (IsReadableStreamLocked(stream) === true) {\r\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n    }\r\n\r\n    ReadableStreamReaderGenericInitialize(this, stream);\r\n\r\n    this._readRequests = [];\r\n  }\r\n\r\n  get closed() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('cancel'));\r\n    }\r\n\r\n    return ReadableStreamReaderGenericCancel(this, reason);\r\n  }\r\n\r\n  read() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('read'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('read from'));\r\n    }\r\n\r\n    return ReadableStreamDefaultReaderRead(this);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      throw defaultReaderBrandCheckException('releaseLock');\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (this._readRequests.length > 0) {\r\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\r\n    }\r\n\r\n    ReadableStreamReaderGenericRelease(this);\r\n  }\r\n}\r\n\r\nclass ReadableStreamBYOBReader {\r\n  constructor(stream) {\r\n    if (!IsReadableStream(stream)) {\r\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\r\n          'byte source');\r\n    }\r\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\r\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\r\n          'source');\r\n    }\r\n    if (IsReadableStreamLocked(stream)) {\r\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n    }\r\n\r\n    ReadableStreamReaderGenericInitialize(this, stream);\r\n\r\n    this._readIntoRequests = [];\r\n  }\r\n\r\n  get closed() {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('cancel'));\r\n    }\r\n\r\n    return ReadableStreamReaderGenericCancel(this, reason);\r\n  }\r\n\r\n  read(view) {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('read'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('read from'));\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(view)) {\r\n      return Promise.reject(new TypeError('view must be an array buffer view'));\r\n    }\r\n\r\n    if (IsDetachedBuffer(view.buffer) === true) {\r\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\r\n    }\r\n\r\n    if (view.byteLength === 0) {\r\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\r\n    }\r\n\r\n    return ReadableStreamBYOBReaderRead(this, view);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      throw byobReaderBrandCheckException('releaseLock');\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (this._readIntoRequests.length > 0) {\r\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\r\n    }\r\n\r\n    ReadableStreamReaderGenericRelease(this);\r\n  }\r\n}\r\n\r\n// Abstract operations for the readers.\r\n\r\nfunction IsReadableStreamBYOBReader(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamDefaultReader(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\r\n  reader._ownerReadableStream = stream;\r\n  stream._reader = reader;\r\n\r\n  if (stream._state === 'readable') {\r\n    defaultReaderClosedPromiseInitialize(reader);\r\n  } else if (stream._state === 'closed') {\r\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\r\n  } else {\r\n    assert(stream._state === 'errored');\r\n\r\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\r\n    reader._closedPromise.catch(() => {});\r\n  }\r\n}\r\n\r\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\r\n// check.\r\n\r\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\r\n  const stream = reader._ownerReadableStream;\r\n  assert(stream !== undefined);\r\n  return ReadableStreamCancel(stream, reason);\r\n}\r\n\r\nfunction ReadableStreamReaderGenericRelease(reader) {\r\n  assert(reader._ownerReadableStream !== undefined);\r\n  assert(reader._ownerReadableStream._reader === reader);\r\n\r\n  if (reader._ownerReadableStream._state === 'readable') {\r\n    defaultReaderClosedPromiseReject(\r\n        reader,\r\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\r\n  } else {\r\n    defaultReaderClosedPromiseResetToRejected(\r\n        reader,\r\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\r\n  }\r\n  reader._closedPromise.catch(() => {});\r\n\r\n  reader._ownerReadableStream._reader = undefined;\r\n  reader._ownerReadableStream = undefined;\r\n}\r\n\r\nfunction ReadableStreamBYOBReaderRead(reader, view) {\r\n  const stream = reader._ownerReadableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  // Controllers must implement this.\r\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\r\n}\r\n\r\nfunction ReadableStreamDefaultReaderRead(reader) {\r\n  const stream = reader._ownerReadableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'closed') {\r\n    return Promise.resolve(CreateIterResultObject(undefined, true));\r\n  }\r\n\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(stream._state === 'readable');\r\n\r\n  return stream._readableStreamController[PullSteps]();\r\n}\r\n\r\n// Controllers\r\n\r\nclass ReadableStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError();\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\r\n  }\r\n\r\n  close() {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('close');\r\n    }\r\n\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\r\n      throw new TypeError('The stream is not in a state that permits close');\r\n    }\r\n\r\n    ReadableStreamDefaultControllerClose(this);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\r\n      throw new TypeError('The stream is not in a state that permits enqueue');\r\n    }\r\n\r\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(e) {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('error');\r\n    }\r\n\r\n    ReadableStreamDefaultControllerError(this, e);\r\n  }\r\n\r\n  [CancelSteps](reason) {\r\n    ResetQueue(this);\r\n    return this._cancelAlgorithm(reason);\r\n  }\r\n\r\n  [PullSteps]() {\r\n    const stream = this._controlledReadableStream;\r\n\r\n    if (this._queue.length > 0) {\r\n      const chunk = DequeueValue(this);\r\n\r\n      if (this._closeRequested === true && this._queue.length === 0) {\r\n        ReadableStreamClose(stream);\r\n      } else {\r\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n      }\r\n\r\n      return Promise.resolve(CreateIterResultObject(chunk, false));\r\n    }\r\n\r\n    const pendingPromise = ReadableStreamAddReadRequest(stream);\r\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n    return pendingPromise;\r\n  }\r\n}\r\n\r\n// Abstract operations for the ReadableStreamDefaultController.\r\n\r\nfunction IsReadableStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\r\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\r\n  if (shouldPull === false) {\r\n    return undefined;\r\n  }\r\n\r\n  if (controller._pulling === true) {\r\n    controller._pullAgain = true;\r\n    return undefined;\r\n  }\r\n\r\n  assert(controller._pullAgain === false);\r\n\r\n  controller._pulling = true;\r\n\r\n  const pullPromise = controller._pullAlgorithm();\r\n  pullPromise.then(\r\n    () => {\r\n      controller._pulling = false;\r\n\r\n      if (controller._pullAgain === true) {\r\n        controller._pullAgain = false;\r\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n      }\r\n      return undefined;\r\n    },\r\n    e => {\r\n      ReadableStreamDefaultControllerError(controller, e);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\r\n    return false;\r\n  }\r\n\r\n  if (controller._started === false) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\r\n  if (desiredSize > 0) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\r\n\r\nfunction ReadableStreamDefaultControllerClose(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\r\n\r\n  controller._closeRequested = true;\r\n\r\n  if (controller._queue.length === 0) {\r\n    ReadableStreamClose(stream);\r\n  }\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\r\n\r\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\r\n  } else {\r\n    let chunkSize;\r\n    try {\r\n      chunkSize = controller._strategySizeAlgorithm(chunk);\r\n    } catch (chunkSizeE) {\r\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\r\n      throw chunkSizeE;\r\n    }\r\n\r\n    try {\r\n      EnqueueValueWithSize(controller, chunk, chunkSize);\r\n    } catch (enqueueE) {\r\n      ReadableStreamDefaultControllerError(controller, enqueueE);\r\n      throw enqueueE;\r\n    }\r\n  }\r\n\r\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerError(controller, e) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return;\r\n  }\r\n\r\n  ResetQueue(controller);\r\n\r\n  ReadableStreamError(stream, e);\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored') {\r\n    return null;\r\n  }\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\n// This is used in the implementation of TransformStream.\r\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\r\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\r\n  const state = controller._controlledReadableStream._state;\r\n\r\n  if (controller._closeRequested === false && state === 'readable') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction SetUpReadableStreamDefaultController(\r\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\r\n  assert(stream._readableStreamController === undefined);\r\n\r\n  controller._controlledReadableStream = stream;\r\n\r\n  controller._queue = undefined;\r\n  controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._started = false;\r\n  controller._closeRequested = false;\r\n  controller._pullAgain = false;\r\n  controller._pulling = false;\r\n\r\n  controller._strategySizeAlgorithm = sizeAlgorithm;\r\n  controller._strategyHWM = highWaterMark;\r\n\r\n  controller._pullAlgorithm = pullAlgorithm;\r\n  controller._cancelAlgorithm = cancelAlgorithm;\r\n\r\n  stream._readableStreamController = controller;\r\n\r\n  const startResult = startAlgorithm();\r\n  Promise.resolve(startResult).then(\r\n    () => {\r\n      controller._started = true;\r\n\r\n      assert(controller._pulling === false);\r\n      assert(controller._pullAgain === false);\r\n\r\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n    },\r\n    r => {\r\n      ReadableStreamDefaultControllerError(controller, r);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\r\n                                                                  sizeAlgorithm) {\r\n  assert(underlyingSource !== undefined);\r\n\r\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\r\n  }\r\n\r\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\r\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\r\n\r\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\r\n                                       highWaterMark, sizeAlgorithm);\r\n}\r\n\r\nclass ReadableStreamBYOBRequest {\r\n  constructor() {\r\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\r\n  }\r\n\r\n  get view() {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('view');\r\n    }\r\n\r\n    return this._view;\r\n  }\r\n\r\n  respond(bytesWritten) {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('respond');\r\n    }\r\n\r\n    if (this._associatedReadableByteStreamController === undefined) {\r\n      throw new TypeError('This BYOB request has been invalidated');\r\n    }\r\n\r\n    if (IsDetachedBuffer(this._view.buffer) === true) {\r\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\r\n  }\r\n\r\n  respondWithNewView(view) {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('respond');\r\n    }\r\n\r\n    if (this._associatedReadableByteStreamController === undefined) {\r\n      throw new TypeError('This BYOB request has been invalidated');\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(view)) {\r\n      throw new TypeError('You can only respond with array buffer views');\r\n    }\r\n\r\n    if (IsDetachedBuffer(view.buffer) === true) {\r\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\r\n  }\r\n}\r\n\r\nclass ReadableByteStreamController {\r\n  constructor() {\r\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\r\n  }\r\n\r\n  get byobRequest() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('byobRequest');\r\n    }\r\n\r\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\r\n      const firstDescriptor = this._pendingPullIntos[0];\r\n      const view = new Uint8Array(firstDescriptor.buffer,\r\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\r\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\r\n\r\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\r\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\r\n      this._byobRequest = byobRequest;\r\n    }\r\n\r\n    return this._byobRequest;\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    return ReadableByteStreamControllerGetDesiredSize(this);\r\n  }\r\n\r\n  close() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('close');\r\n    }\r\n\r\n    if (this._closeRequested === true) {\r\n      throw new TypeError('The stream has already been closed; do not close it again!');\r\n    }\r\n\r\n    const state = this._controlledReadableByteStream._state;\r\n    if (state !== 'readable') {\r\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\r\n    }\r\n\r\n    ReadableByteStreamControllerClose(this);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    if (this._closeRequested === true) {\r\n      throw new TypeError('stream is closed or draining');\r\n    }\r\n\r\n    const state = this._controlledReadableByteStream._state;\r\n    if (state !== 'readable') {\r\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(chunk)) {\r\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\r\n    }\r\n\r\n    if (IsDetachedBuffer(chunk.buffer) === true) {\r\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\r\n    }\r\n\r\n    ReadableByteStreamControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(e) {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('error');\r\n    }\r\n\r\n    ReadableByteStreamControllerError(this, e);\r\n  }\r\n\r\n  [CancelSteps](reason) {\r\n    if (this._pendingPullIntos.length > 0) {\r\n      const firstDescriptor = this._pendingPullIntos[0];\r\n      firstDescriptor.bytesFilled = 0;\r\n    }\r\n\r\n    ResetQueue(this);\r\n\r\n    return this._cancelAlgorithm(reason);\r\n  }\r\n\r\n  [PullSteps]() {\r\n    const stream = this._controlledReadableByteStream;\r\n    assert(ReadableStreamHasDefaultReader(stream) === true);\r\n\r\n    if (this._queueTotalSize > 0) {\r\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\r\n\r\n      const entry = this._queue.shift();\r\n      this._queueTotalSize -= entry.byteLength;\r\n\r\n      ReadableByteStreamControllerHandleQueueDrain(this);\r\n\r\n      let view;\r\n      try {\r\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\r\n      } catch (viewE) {\r\n        return Promise.reject(viewE);\r\n      }\r\n\r\n      return Promise.resolve(CreateIterResultObject(view, false));\r\n    }\r\n\r\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\r\n    if (autoAllocateChunkSize !== undefined) {\r\n      let buffer;\r\n      try {\r\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\r\n      } catch (bufferE) {\r\n        return Promise.reject(bufferE);\r\n      }\r\n\r\n      const pullIntoDescriptor = {\r\n        buffer,\r\n        byteOffset: 0,\r\n        byteLength: autoAllocateChunkSize,\r\n        bytesFilled: 0,\r\n        elementSize: 1,\r\n        ctor: Uint8Array,\r\n        readerType: 'default'\r\n      };\r\n\r\n      this._pendingPullIntos.push(pullIntoDescriptor);\r\n    }\r\n\r\n    const promise = ReadableStreamAddReadRequest(stream);\r\n\r\n    ReadableByteStreamControllerCallPullIfNeeded(this);\r\n\r\n    return promise;\r\n  }\r\n}\r\n\r\n// Abstract operations for the ReadableByteStreamController.\r\n\r\nfunction IsReadableByteStreamController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamBYOBRequest(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\r\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\r\n  if (shouldPull === false) {\r\n    return undefined;\r\n  }\r\n\r\n  if (controller._pulling === true) {\r\n    controller._pullAgain = true;\r\n    return undefined;\r\n  }\r\n\r\n  assert(controller._pullAgain === false);\r\n\r\n  controller._pulling = true;\r\n\r\n  // TODO: Test controller argument\r\n  const pullPromise = controller._pullAlgorithm();\r\n  pullPromise.then(\r\n    () => {\r\n      controller._pulling = false;\r\n\r\n      if (controller._pullAgain === true) {\r\n        controller._pullAgain = false;\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n      }\r\n    },\r\n    e => {\r\n      ReadableByteStreamControllerError(controller, e);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  controller._pendingPullIntos = [];\r\n}\r\n\r\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\r\n  assert(stream._state !== 'errored');\r\n\r\n  let done = false;\r\n  if (stream._state === 'closed') {\r\n    assert(pullIntoDescriptor.bytesFilled === 0);\r\n    done = true;\r\n  }\r\n\r\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n  if (pullIntoDescriptor.readerType === 'default') {\r\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\r\n  } else {\r\n    assert(pullIntoDescriptor.readerType === 'byob');\r\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\r\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\r\n  const elementSize = pullIntoDescriptor.elementSize;\r\n\r\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\r\n  assert(bytesFilled % elementSize === 0);\r\n\r\n  return new pullIntoDescriptor.ctor(\r\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\r\n}\r\n\r\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\r\n  controller._queue.push({ buffer, byteOffset, byteLength });\r\n  controller._queueTotalSize += byteLength;\r\n}\r\n\r\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\r\n  const elementSize = pullIntoDescriptor.elementSize;\r\n\r\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\r\n\r\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\r\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\r\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\r\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\r\n\r\n  let totalBytesToCopyRemaining = maxBytesToCopy;\r\n  let ready = false;\r\n  if (maxAlignedBytes > currentAlignedBytes) {\r\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\r\n    ready = true;\r\n  }\r\n\r\n  const queue = controller._queue;\r\n\r\n  while (totalBytesToCopyRemaining > 0) {\r\n    const headOfQueue = queue[0];\r\n\r\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\r\n\r\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\r\n\r\n    if (headOfQueue.byteLength === bytesToCopy) {\r\n      queue.shift();\r\n    } else {\r\n      headOfQueue.byteOffset += bytesToCopy;\r\n      headOfQueue.byteLength -= bytesToCopy;\r\n    }\r\n    controller._queueTotalSize -= bytesToCopy;\r\n\r\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\r\n\r\n    totalBytesToCopyRemaining -= bytesToCopy;\r\n  }\r\n\r\n  if (ready === false) {\r\n    assert(controller._queueTotalSize === 0);\r\n    assert(pullIntoDescriptor.bytesFilled > 0);\r\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\r\n  }\r\n\r\n  return ready;\r\n}\r\n\r\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\r\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\r\n\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  pullIntoDescriptor.bytesFilled += size;\r\n}\r\n\r\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\r\n  assert(controller._controlledReadableByteStream._state === 'readable');\r\n\r\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\r\n    ReadableStreamClose(controller._controlledReadableByteStream);\r\n  } else {\r\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\r\n  if (controller._byobRequest === undefined) {\r\n    return;\r\n  }\r\n\r\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\r\n  controller._byobRequest._view = undefined;\r\n  controller._byobRequest = undefined;\r\n}\r\n\r\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\r\n  assert(controller._closeRequested === false);\r\n\r\n  while (controller._pendingPullIntos.length > 0) {\r\n    if (controller._queueTotalSize === 0) {\r\n      return;\r\n    }\r\n\r\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\r\n\r\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\r\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n\r\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\r\n        controller._controlledReadableByteStream,\r\n        pullIntoDescriptor\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerPullInto(controller, view) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  let elementSize = 1;\r\n  if (view.constructor !== DataView) {\r\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\r\n  }\r\n\r\n  const ctor = view.constructor;\r\n\r\n  const buffer = TransferArrayBuffer(view.buffer);\r\n  const pullIntoDescriptor = {\r\n    buffer,\r\n    byteOffset: view.byteOffset,\r\n    byteLength: view.byteLength,\r\n    bytesFilled: 0,\r\n    elementSize,\r\n    ctor,\r\n    readerType: 'byob'\r\n  };\r\n\r\n  if (controller._pendingPullIntos.length > 0) {\r\n    controller._pendingPullIntos.push(pullIntoDescriptor);\r\n\r\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\r\n    // - No change happens on desiredSize\r\n    // - The source has already been notified of that there's at least 1 pending read(view)\r\n\r\n    return ReadableStreamAddReadIntoRequest(stream);\r\n  }\r\n\r\n  if (stream._state === 'closed') {\r\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\r\n    return Promise.resolve(CreateIterResultObject(emptyView, true));\r\n  }\r\n\r\n  if (controller._queueTotalSize > 0) {\r\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\r\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n\r\n      ReadableByteStreamControllerHandleQueueDrain(controller);\r\n\r\n      return Promise.resolve(CreateIterResultObject(filledView, false));\r\n    }\r\n\r\n    if (controller._closeRequested === true) {\r\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n      ReadableByteStreamControllerError(controller, e);\r\n\r\n      return Promise.reject(e);\r\n    }\r\n  }\r\n\r\n  controller._pendingPullIntos.push(pullIntoDescriptor);\r\n\r\n  const promise = ReadableStreamAddReadIntoRequest(stream);\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\r\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\r\n\r\n  assert(firstDescriptor.bytesFilled === 0);\r\n\r\n  const stream = controller._controlledReadableByteStream;\r\n  if (ReadableStreamHasBYOBReader(stream) === true) {\r\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\r\n    }\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\r\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\r\n    throw new RangeError('bytesWritten out of range');\r\n  }\r\n\r\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\r\n\r\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\r\n    // TODO: Figure out whether we should detach the buffer or not here.\r\n    return;\r\n  }\r\n\r\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n\r\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\r\n  if (remainderSize > 0) {\r\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\r\n  }\r\n\r\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\r\n  pullIntoDescriptor.bytesFilled -= remainderSize;\r\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\r\n\r\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\r\n  const firstDescriptor = controller._pendingPullIntos[0];\r\n\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state === 'closed') {\r\n    if (bytesWritten !== 0) {\r\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\r\n  } else {\r\n    assert(stream._state === 'readable');\r\n\r\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\r\n  }\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\r\n  const descriptor = controller._pendingPullIntos.shift();\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  return descriptor;\r\n}\r\n\r\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return false;\r\n  }\r\n\r\n  if (controller._closeRequested === true) {\r\n    return false;\r\n  }\r\n\r\n  if (controller._started === false) {\r\n    return false;\r\n  }\r\n\r\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\r\n\r\nfunction ReadableByteStreamControllerClose(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  assert(controller._closeRequested === false);\r\n  assert(stream._state === 'readable');\r\n\r\n  if (controller._queueTotalSize > 0) {\r\n    controller._closeRequested = true;\r\n\r\n    return;\r\n  }\r\n\r\n  if (controller._pendingPullIntos.length > 0) {\r\n    const firstPendingPullInto = controller._pendingPullIntos[0];\r\n    if (firstPendingPullInto.bytesFilled > 0) {\r\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n      ReadableByteStreamControllerError(controller, e);\r\n\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  ReadableStreamClose(stream);\r\n}\r\n\r\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  assert(controller._closeRequested === false);\r\n  assert(stream._state === 'readable');\r\n\r\n  const buffer = chunk.buffer;\r\n  const byteOffset = chunk.byteOffset;\r\n  const byteLength = chunk.byteLength;\r\n  const transferredBuffer = TransferArrayBuffer(buffer);\r\n\r\n  if (ReadableStreamHasDefaultReader(stream) === true) {\r\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\r\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n    } else {\r\n      assert(controller._queue.length === 0);\r\n\r\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\r\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\r\n    }\r\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\r\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n  } else {\r\n    assert(IsReadableStreamLocked(stream) === false);\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n  }\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerError(controller, e) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return;\r\n  }\r\n\r\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\r\n\r\n  ResetQueue(controller);\r\n  ReadableStreamError(stream, e);\r\n}\r\n\r\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored') {\r\n    return null;\r\n  }\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\r\n  bytesWritten = Number(bytesWritten);\r\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\r\n    throw new RangeError('bytesWritten must be a finite');\r\n  }\r\n\r\n  assert(controller._pendingPullIntos.length > 0);\r\n\r\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\r\n  assert(controller._pendingPullIntos.length > 0);\r\n\r\n  const firstDescriptor = controller._pendingPullIntos[0];\r\n\r\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\r\n    throw new RangeError('The region specified by view does not match byobRequest');\r\n  }\r\n  if (firstDescriptor.byteLength !== view.byteLength) {\r\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\r\n  }\r\n\r\n  firstDescriptor.buffer = view.buffer;\r\n\r\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\r\n}\r\n\r\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\r\n                                           highWaterMark, autoAllocateChunkSize) {\r\n  assert(stream._readableStreamController === undefined);\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\r\n    assert(autoAllocateChunkSize > 0);\r\n  }\r\n\r\n  controller._controlledReadableByteStream = stream;\r\n\r\n  controller._pullAgain = false;\r\n  controller._pulling = false;\r\n\r\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\r\n\r\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\r\n  controller._queue = controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._closeRequested = false;\r\n  controller._started = false;\r\n\r\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n  controller._pullAlgorithm = pullAlgorithm;\r\n  controller._cancelAlgorithm = cancelAlgorithm;\r\n\r\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\r\n\r\n  controller._pendingPullIntos = [];\r\n\r\n  stream._readableStreamController = controller;\r\n\r\n  const startResult = startAlgorithm();\r\n  Promise.resolve(startResult).then(\r\n      () => {\r\n        controller._started = true;\r\n\r\n        assert(controller._pulling === false);\r\n        assert(controller._pullAgain === false);\r\n\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n      },\r\n      r => {\r\n        ReadableByteStreamControllerError(controller, r);\r\n      }\r\n  )\r\n      .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\r\n  assert(underlyingByteSource !== undefined);\r\n\r\n  const controller = Object.create(ReadableByteStreamController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\r\n  }\r\n\r\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\r\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\r\n\r\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\r\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\r\n    }\r\n  }\r\n\r\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\r\n                                    autoAllocateChunkSize);\r\n}\r\n\r\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\r\n  assert(IsReadableByteStreamController(controller) === true);\r\n  assert(typeof view === 'object');\r\n  assert(ArrayBuffer.isView(view) === true);\r\n  assert(IsDetachedBuffer(view.buffer) === false);\r\n  request._associatedReadableByteStreamController = controller;\r\n  request._view = view;\r\n}\r\n\r\n// Helper functions for the ReadableStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\r\n}\r\n\r\n// Helper functions for the readers.\r\n\r\nfunction readerLockException(name) {\r\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultReader.\r\n\r\nfunction defaultReaderBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitialize(reader) {\r\n  reader._closedPromise = new Promise((resolve, reject) => {\r\n    reader._closedPromise_resolve = resolve;\r\n    reader._closedPromise_reject = reject;\r\n  });\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\r\n  reader._closedPromise = Promise.reject(reason);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\r\n  reader._closedPromise = Promise.resolve(undefined);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseReject(reader, reason) {\r\n  assert(reader._closedPromise_resolve !== undefined);\r\n  assert(reader._closedPromise_reject !== undefined);\r\n\r\n  reader._closedPromise_reject(reason);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\r\n  assert(reader._closedPromise_resolve === undefined);\r\n  assert(reader._closedPromise_reject === undefined);\r\n\r\n  reader._closedPromise = Promise.reject(reason);\r\n}\r\n\r\nfunction defaultReaderClosedPromiseResolve(reader) {\r\n  assert(reader._closedPromise_resolve !== undefined);\r\n  assert(reader._closedPromise_reject !== undefined);\r\n\r\n  reader._closedPromise_resolve(undefined);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultReader.\r\n\r\nfunction byobReaderBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultController.\r\n\r\nfunction defaultControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\r\n}\r\n\r\n// Helper functions for the ReadableStreamBYOBRequest.\r\n\r\nfunction byobRequestBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\r\n}\r\n\r\n// Helper functions for the ReadableByteStreamController.\r\n\r\nfunction byteStreamControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\r\n}\r\n\r\n// Helper function for ReadableStream pipeThrough\r\n\r\nfunction ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\r\n  try {\r\n    // This relies on the brand-check that is enforced by Promise.prototype.then(). As with the rest of the reference\r\n    // implementation, it doesn't attempt to do the right thing if someone has modified the global environment.\r\n    Promise.prototype.then.call(promise, undefined, () => {});\r\n  } catch (e) {\r\n    // The brand check failed, therefore the internal slot is not present and there's nothing further to do.\r\n  }\r\n}\r\n","'use strict';\r\nconst { createDataProperty } = require('./helpers.js');\r\n\r\nmodule.exports = class ByteLengthQueuingStrategy {\r\n  constructor({ highWaterMark }) {\r\n    createDataProperty(this, 'highWaterMark', highWaterMark);\r\n  }\r\n\r\n  size(chunk) {\r\n    return chunk.byteLength;\r\n  }\r\n};\r\n","'use strict';\r\nconst { createDataProperty } = require('./helpers.js');\r\n\r\nmodule.exports = class CountQueuingStrategy {\r\n  constructor({ highWaterMark }) {\r\n    createDataProperty(this, 'highWaterMark', highWaterMark);\r\n  }\r\n\r\n  size() {\r\n    return 1;\r\n  }\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\r\n// and do not appear in the standard text.\r\nconst verbose = require('debug')('streams:transform-stream:verbose');\r\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\r\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\r\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\r\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\r\n        ReadableStreamDefaultControllerHasBackpressure,\r\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\r\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\r\n\r\n// Class TransformStream\r\n\r\nclass TransformStream {\r\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\r\n    const readableType = transformer.readableType;\r\n\r\n    if (readableType !== undefined) {\r\n      throw new RangeError('Invalid readable type specified');\r\n    }\r\n\r\n    const writableType = transformer.writableType;\r\n\r\n    if (writableType !== undefined) {\r\n      throw new RangeError('Invalid writable type specified');\r\n    }\r\n\r\n    const writableSizeFunction = writableStrategy.size;\r\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\r\n    let writableHighWaterMark = writableStrategy.highWaterMark;\r\n    if (writableHighWaterMark === undefined) {\r\n      writableHighWaterMark = 1;\r\n    }\r\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\r\n\r\n    const readableSizeFunction = readableStrategy.size;\r\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\r\n    let readableHighWaterMark = readableStrategy.highWaterMark;\r\n    if (readableHighWaterMark === undefined) {\r\n      readableHighWaterMark = 0;\r\n    }\r\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\r\n\r\n    let startPromise_resolve;\r\n    const startPromise = new Promise(resolve => {\r\n      startPromise_resolve = resolve;\r\n    });\r\n\r\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\r\n                              readableSizeAlgorithm);\r\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\r\n\r\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\r\n    startPromise_resolve(startResult);\r\n  }\r\n\r\n  get readable() {\r\n    if (IsTransformStream(this) === false) {\r\n      throw streamBrandCheckException('readable');\r\n    }\r\n\r\n    return this._readable;\r\n  }\r\n\r\n  get writable() {\r\n    if (IsTransformStream(this) === false) {\r\n      throw streamBrandCheckException('writable');\r\n    }\r\n\r\n    return this._writable;\r\n  }\r\n}\r\n\r\n// Transform Stream Abstract Operations\r\n\r\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\r\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\r\n                               readableSizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(writableHighWaterMark));\r\n  assert(IsNonNegativeNumber(readableHighWaterMark));\r\n\r\n  const stream = Object.create(TransformStream.prototype);\r\n\r\n  let startPromise_resolve;\r\n  const startPromise = new Promise(resolve => {\r\n    startPromise_resolve = resolve;\r\n  });\r\n\r\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\r\n                            readableSizeAlgorithm);\r\n\r\n  const controller = Object.create(TransformStreamDefaultController.prototype);\r\n\r\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\r\n\r\n  const startResult = startAlgorithm();\r\n  startPromise_resolve(startResult);\r\n  return stream;\r\n}\r\n\r\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\r\n                                   readableHighWaterMark, readableSizeAlgorithm) {\r\n  function startAlgorithm() {\r\n    return startPromise;\r\n  }\r\n\r\n  function writeAlgorithm(chunk) {\r\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\r\n  }\r\n\r\n  function abortAlgorithm(reason) {\r\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\r\n  }\r\n\r\n  function closeAlgorithm() {\r\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\r\n  }\r\n\r\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\r\n                                          writableHighWaterMark, writableSizeAlgorithm);\r\n\r\n  function pullAlgorithm() {\r\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\r\n  }\r\n\r\n  function cancelAlgorithm(reason) {\r\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\r\n    return Promise.resolve();\r\n  }\r\n\r\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\r\n                                          readableSizeAlgorithm);\r\n\r\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\r\n  stream._backpressure = undefined;\r\n  stream._backpressureChangePromise = undefined;\r\n  stream._backpressureChangePromise_resolve = undefined;\r\n  TransformStreamSetBackpressure(stream, true);\r\n\r\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\r\n  stream._transformStreamController = undefined;\r\n}\r\n\r\nfunction IsTransformStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// This is a no-op if both sides are already errored.\r\nfunction TransformStreamError(stream, e) {\r\n  verbose('TransformStreamError()');\r\n\r\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\r\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\r\n}\r\n\r\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\r\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\r\n  if (stream._backpressure === true) {\r\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\r\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\r\n    // _backpressure is set.\r\n    TransformStreamSetBackpressure(stream, false);\r\n  }\r\n}\r\n\r\nfunction TransformStreamSetBackpressure(stream, backpressure) {\r\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\r\n\r\n  // Passes also when called during construction.\r\n  assert(stream._backpressure !== backpressure);\r\n\r\n  if (stream._backpressureChangePromise !== undefined) {\r\n    stream._backpressureChangePromise_resolve();\r\n  }\r\n\r\n  stream._backpressureChangePromise = new Promise(resolve => {\r\n    stream._backpressureChangePromise_resolve = resolve;\r\n  });\r\n\r\n  stream._backpressure = backpressure;\r\n}\r\n\r\n// Class TransformStreamDefaultController\r\n\r\nclass TransformStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\r\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    TransformStreamDefaultControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(reason) {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('error');\r\n    }\r\n\r\n    TransformStreamDefaultControllerError(this, reason);\r\n  }\r\n\r\n  terminate() {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('terminate');\r\n    }\r\n\r\n    TransformStreamDefaultControllerTerminate(this);\r\n  }\r\n}\r\n\r\n// Transform Stream Default Controller Abstract Operations\r\n\r\nfunction IsTransformStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\r\n  assert(IsTransformStream(stream) === true);\r\n  assert(stream._transformStreamController === undefined);\r\n\r\n  controller._controlledTransformStream = stream;\r\n  stream._transformStreamController = controller;\r\n\r\n  controller._transformAlgorithm = transformAlgorithm;\r\n  controller._flushAlgorithm = flushAlgorithm;\r\n}\r\n\r\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\r\n  assert(transformer !== undefined);\r\n\r\n  const controller = Object.create(TransformStreamDefaultController.prototype);\r\n\r\n  let transformAlgorithm = chunk => {\r\n    try {\r\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\r\n      return Promise.resolve();\r\n    } catch (transformResultE) {\r\n      return Promise.reject(transformResultE);\r\n    }\r\n  };\r\n  const transformMethod = transformer.transform;\r\n  if (transformMethod !== undefined) {\r\n    if (typeof transformMethod !== 'function') {\r\n      throw new TypeError('transform is not a method');\r\n    }\r\n    transformAlgorithm = chunk => {\r\n      const transformPromise = PromiseCall(transformMethod, transformer, [chunk, controller]);\r\n      return transformPromise.catch(e => {\r\n        TransformStreamError(stream, e);\r\n        throw e;\r\n      });\r\n    };\r\n  }\r\n\r\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\r\n\r\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\r\n}\r\n\r\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\r\n  verbose('TransformStreamDefaultControllerEnqueue()');\r\n\r\n  const stream = controller._controlledTransformStream;\r\n  const readableController = stream._readable._readableStreamController;\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\r\n    throw new TypeError('Readable side is not in a state that permits enqueue');\r\n  }\r\n\r\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\r\n  // accept TransformStreamDefaultControllerEnqueue() calls.\r\n\r\n  try {\r\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\r\n  } catch (e) {\r\n    // This happens when readableStrategy.size() throws.\r\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\r\n\r\n    throw stream._readable._storedError;\r\n  }\r\n\r\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\r\n  if (backpressure !== stream._backpressure) {\r\n    assert(backpressure === true);\r\n    TransformStreamSetBackpressure(stream, true);\r\n  }\r\n}\r\n\r\nfunction TransformStreamDefaultControllerError(controller, e) {\r\n  TransformStreamError(controller._controlledTransformStream, e);\r\n}\r\n\r\nfunction TransformStreamDefaultControllerTerminate(controller) {\r\n  verbose('TransformStreamDefaultControllerTerminate()');\r\n\r\n  const stream = controller._controlledTransformStream;\r\n  const readableController = stream._readable._readableStreamController;\r\n\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\r\n    ReadableStreamDefaultControllerClose(readableController);\r\n  }\r\n\r\n  const error = new TypeError('TransformStream terminated');\r\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\r\n}\r\n\r\n// TransformStreamDefaultSink Algorithms\r\n\r\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\r\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\r\n\r\n  assert(stream._writable._state === 'writable');\r\n\r\n  const controller = stream._transformStreamController;\r\n\r\n  if (stream._backpressure === true) {\r\n    const backpressureChangePromise = stream._backpressureChangePromise;\r\n    assert(backpressureChangePromise !== undefined);\r\n    return backpressureChangePromise\r\n        .then(() => {\r\n          const writable = stream._writable;\r\n          const state = writable._state;\r\n          if (state === 'erroring') {\r\n            throw writable._storedError;\r\n          }\r\n          assert(state === 'writable');\r\n          return controller._transformAlgorithm(chunk);\r\n        });\r\n  }\r\n\r\n  return controller._transformAlgorithm(chunk);\r\n}\r\n\r\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\r\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\r\n  // errored.\r\n  TransformStreamError(stream, reason);\r\n  return Promise.resolve();\r\n}\r\n\r\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\r\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\r\n\r\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\r\n  const readable = stream._readable;\r\n\r\n  const flushPromise = stream._transformStreamController._flushAlgorithm();\r\n  // Return a promise that is fulfilled with undefined on success.\r\n  return flushPromise.then(() => {\r\n    if (readable._state === 'errored') {\r\n      throw readable._storedError;\r\n    }\r\n    const readableController = readable._readableStreamController;\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\r\n      ReadableStreamDefaultControllerClose(readableController);\r\n    }\r\n  }).catch(r => {\r\n    TransformStreamError(stream, r);\r\n    throw readable._storedError;\r\n  });\r\n}\r\n\r\n// TransformStreamDefaultSource Algorithms\r\n\r\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\r\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\r\n\r\n  // Invariant. Enforced by the promises returned by start() and pull().\r\n  assert(stream._backpressure === true);\r\n\r\n  assert(stream._backpressureChangePromise !== undefined);\r\n\r\n  TransformStreamSetBackpressure(stream, false);\r\n\r\n  // Prevent the next pull() call until there is backpressure.\r\n  return stream._backpressureChangePromise;\r\n}\r\n\r\nmodule.exports = { CreateTransformStream, TransformStream };\r\n\r\n// Helper functions for the TransformStreamDefaultController.\r\n\r\nfunction defaultControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\r\n}\r\n\r\n// Helper functions for the TransformStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(\r\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\r\n}\r\n","import {\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  ReadableStream,\n  TransformStream,\n  WritableStream\n} from './ponyfill';\nimport { globals } from './utils';\n\n// Export\nexport * from './ponyfill';\n\nconst exports = {\n  ReadableStream,\n  WritableStream,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  TransformStream\n};\n\n// Add classes to global scope\nif (typeof globals !== 'undefined') {\n  Object.assign(globals, exports);\n}\n"],"names":["NumberIsInteger","Number","isInteger","value","isFinite","Math","floor","FakeSymbol","Symbol","iterator","description","noop","getGlobals","self","window","global","undefined","globals","NumberIsNaN","isNaN","x","isFakeDetached","exports","o","p","v","Object","defineProperty","writable","enumerable","configurable","elements","slice","dest","destOffset","src","srcOffset","n","Uint8Array","set","done","obj","IsNonNegativeNumber","Infinity","Number.isNaN","Call","F","V","args","TypeError","Function","prototype","apply","call","underlyingObject","methodName","algoArgCount","extraArgs","method","PromiseCall","fullArgs","arg","concat","Promise","resolve","O","P","reject","transferredIshVersion","get","highWaterMark","RangeError","size","chunk","assert","AssertionError","e","setTimeout","IsFiniteNonNegativeNumber","require$$0","pair","container","_queue","shift","_queueTotalSize","push","verbose","CreateAlgorithmFromUnderlyingMethod","require$$1","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","typeIsObject","rethrowAssertionErrorRejection","require$$2","DequeueValue","require$$3","EnqueueValueWithSize","PeekQueueValue","ResetQueue","AbortSteps","ErrorSteps","WritableStream","underlyingSink","InitializeWritableStream","type","sizeAlgorithm","SetUpWritableStreamDefaultControllerFromUnderlyingSink","abort","reason","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","getWriter","AcquireWritableStreamDefaultWriter","CreateWritableStream","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultWriterCloseWithErrorPropagation","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamCloseQueuedOrInFlight","stream","WritableStreamDefaultWriter","startAlgorithm","writeAlgorithm","closeAlgorithm","abortAlgorithm","create","controller","WritableStreamDefaultController","SetUpWritableStreamDefaultController","_state","_storedError","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","state","_promise","wasAlreadyErroring","promise","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","WritableStreamAddWriteRequest","writeRequest","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","writer","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","_started","storedError","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","then","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamFinishInFlightClose","defaultWriterClosedPromiseResolve","WritableStreamFinishInFlightCloseWithError","WritableStreamMarkCloseRequestInFlight","WritableStreamMarkFirstWriteRequestInFlight","defaultWriterClosedPromiseReject","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseReset","defaultWriterReadyPromiseResolve","_ownerWritableStream","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","_readyPromise","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterAbort","close","WritableStreamDefaultWriterClose","releaseLock","write","WritableStreamDefaultWriterGetDesiredSize","closeRequest","WritableStreamDefaultControllerClose","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","WritableStreamDefaultControllerGetDesiredSize","releasedError","chunkSize","WritableStreamDefaultControllerGetChunkSize","WritableStreamDefaultControllerWrite","IsWritableStreamDefaultController","_controlledWritableStream","WritableStreamDefaultControllerError","_abortAlgorithm","_strategySizeAlgorithm","_strategyHWM","_writeAlgorithm","_closeAlgorithm","WritableStreamDefaultControllerGetBackpressure","startResult","startPromise","WritableStreamDefaultControllerAdvanceQueueIfNeeded","r","chunkSizeE","writeRecord","enqueueE","length","WritableStreamDefaultControllerProcessClose","WritableStreamDefaultControllerProcessWrite","sinkClosePromise","sinkWritePromise","desiredSize","name","_closedPromise_resolve","_closedPromise_reject","_readyPromise_resolve","_readyPromise_reject","ArrayBufferCopy","CreateIterResultObject","IsDetachedBuffer","TransferArrayBuffer","createArrayFromList","CancelSteps","PullSteps","ReadableStream","underlyingSource","InitializeReadableStream","typeString","String","SetUpReadableByteStreamControllerFromUnderlyingSource","SetUpReadableStreamDefaultControllerFromUnderlyingSource","cancel","IsReadableStream","IsReadableStreamLocked","ReadableStreamCancel","getReader","mode","AcquireReadableStreamDefaultReader","AcquireReadableStreamBYOBReader","pipeThrough","options","readable","pipeTo","ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue","preventClose","preventAbort","preventCancel","Boolean","reader","shuttingDown","currentWrite","pipeLoop","ReadableStreamDefaultReaderRead","isOrBecomesErrored","shutdownWithAction","shutdown","isOrBecomesClosed","destClosed","err","waitForWritesToFinish","oldCurrentWrite","action","originalIsError","originalError","doTheRest","finalize","newError","isError","ReadableStreamReaderGenericRelease","tee","branches","ReadableStreamTee","CreateReadableByteStream","CreateReadableStream","IsReadableStreamDisturbed","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerHasBackpressure","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamBYOBReader","ReadableStreamDefaultReader","pullAlgorithm","cancelAlgorithm","ReadableStreamDefaultController","SetUpReadableStreamDefaultController","autoAllocateChunkSize","ReadableByteStreamController","SetUpReadableByteStreamController","_reader","_disturbed","cloneForBranch2","closedOrErrored","canceled1","canceled2","reason1","reason2","branch1","branch2","resolveCancelPromise","cancelPromise","result","_readableStreamController","value1","value2","cancel1Algorithm","compositeReason","cancelResult","cancel2Algorithm","ReadableStreamAddReadIntoRequest","readIntoRequest","_readIntoRequests","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamClose","sourceCancelPromise","IsReadableStreamDefaultReader","defaultReaderClosedPromiseResolve","ReadableStreamError","defaultReaderClosedPromiseReject","ReadableStreamFulfillReadIntoRequest","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","IsReadableStreamBYOBReader","ReadableStreamHasDefaultReader","ReadableStreamReaderGenericInitialize","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","read","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","ReadableStreamBYOBReaderRead","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","defaultReaderClosedPromiseResetToRejected","ReadableByteStreamControllerPullInto","IsReadableStreamDefaultController","defaultControllerBrandCheckException","enqueue","_cancelAlgorithm","_controlledReadableStream","_closeRequested","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","shouldPull","ReadableStreamDefaultControllerShouldCallPull","_pulling","_pullAgain","pullPromise","_pullAlgorithm","ReadableStreamBYOBRequest","respond","bytesWritten","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_associatedReadableByteStreamController","_view","ReadableByteStreamControllerRespond","respondWithNewView","ReadableByteStreamControllerRespondWithNewView","byteStreamControllerBrandCheckException","_controlledReadableByteStream","ReadableByteStreamControllerClose","ReadableByteStreamControllerEnqueue","ReadableByteStreamControllerError","_pendingPullIntos","firstDescriptor","bytesFilled","entry","ReadableByteStreamControllerHandleQueueDrain","byteOffset","viewE","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","elementSize","ctor","readerType","ReadableByteStreamControllerCallPullIfNeeded","_byobRequest","byobRequest","SetUpReadableStreamBYOBRequest","ReadableByteStreamControllerGetDesiredSize","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","ReadableByteStreamControllerEnqueueChunkToQueue","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerShiftPendingPullInto","constructor","DataView","BYTES_PER_ELEMENT","emptyView","ReadableByteStreamControllerRespondInClosedState","ReadableByteStreamControllerRespondInReadableState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInternal","descriptor","firstPendingPullInto","transferredBuffer","transferredView","underlyingByteSource","Number.isInteger","request","createDataProperty","TransformStream","transformer","writableStrategy","readableStrategy","readableType","writableType","writableSizeFunction","writableSizeAlgorithm","writableHighWaterMark","readableSizeFunction","readableSizeAlgorithm","readableHighWaterMark","startPromise_resolve","InitializeTransformStream","SetUpTransformStreamDefaultControllerFromTransformer","_transformStreamController","IsTransformStream","_readable","_writable","CreateTransformStream","transformAlgorithm","flushAlgorithm","TransformStreamDefaultController","SetUpTransformStreamDefaultController","TransformStreamDefaultSinkWriteAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise","_backpressureChangePromise_resolve","TransformStreamSetBackpressure","TransformStreamError","IsTransformStreamDefaultController","TransformStreamDefaultControllerEnqueue","TransformStreamDefaultControllerError","terminate","TransformStreamDefaultControllerTerminate","readableController","_controlledTransformStream","_transformAlgorithm","_flushAlgorithm","transformResultE","transformMethod","transform","transformPromise","backpressureChangePromise","flushPromise","ByteLengthQueuingStrategy","CountQueuingStrategy"],"mappings":"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"}