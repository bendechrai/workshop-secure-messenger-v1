{"version":3,"file":"ponyfill.mjs","sources":["../src/stub/number-isinteger.js","../src/stub/symbol.js","../src/utils.js","../src/stub/number-isnan.js","../spec/reference-implementation/lib/helpers.js","../src/stub/assert.js","../spec/reference-implementation/lib/utils.js","../spec/reference-implementation/lib/queue-with-sizes.js","../spec/reference-implementation/lib/writable-stream.js","../spec/reference-implementation/lib/readable-stream.js","../spec/reference-implementation/lib/byte-length-queuing-strategy.js","../spec/reference-implementation/lib/count-queuing-strategy.js","../spec/reference-implementation/lib/transform-stream.js"],"sourcesContent":["// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\nexport default NumberIsInteger;\n","const FakeSymbol = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n  Symbol :\n  description => `Symbol(${description})`;\n\nexport default FakeSymbol;\n","export function noop() {\n  // do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\r\n\r\nfunction IsPropertyKey(argument) {\r\n  return typeof argument === 'string' || typeof argument === 'symbol';\r\n}\r\n\r\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\r\n\r\nexports.createDataProperty = (o, p, v) => {\r\n  assert(exports.typeIsObject(o));\r\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\r\n};\r\n\r\nexports.createArrayFromList = elements => {\r\n  // We use arrays to represent lists, so this is basically a no-op.\r\n  // Do a slice though just in case we happen to depend on the unique-ness.\r\n  return elements.slice();\r\n};\r\n\r\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\r\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\r\n};\r\n\r\nexports.CreateIterResultObject = (value, done) => {\r\n  assert(typeof done === 'boolean');\r\n  const obj = {};\r\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\r\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\r\n  return obj;\r\n};\r\n\r\nexports.IsFiniteNonNegativeNumber = v => {\r\n  if (exports.IsNonNegativeNumber(v) === false) {\r\n    return false;\r\n  }\r\n\r\n  if (v === Infinity) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexports.IsNonNegativeNumber = v => {\r\n  if (typeof v !== 'number') {\r\n    return false;\r\n  }\r\n\r\n  if (Number.isNaN(v)) {\r\n    return false;\r\n  }\r\n\r\n  if (v < 0) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction Call(F, V, args) {\r\n  if (typeof F !== 'function') {\r\n    throw new TypeError('Argument is not a function');\r\n  }\r\n\r\n  return Function.prototype.apply.call(F, V, args);\r\n}\r\n\r\nexports.Call = Call;\r\n\r\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\r\n  assert(underlyingObject !== undefined);\r\n  assert(IsPropertyKey(methodName));\r\n  assert(algoArgCount === 0 || algoArgCount === 1);\r\n  assert(Array.isArray(extraArgs));\r\n  const method = underlyingObject[methodName];\r\n  if (method !== undefined) {\r\n    if (typeof method !== 'function') {\r\n      throw new TypeError(`${method} is not a method`);\r\n    }\r\n    switch (algoArgCount) {\r\n      case 0: {\r\n        return () => {\r\n          return PromiseCall(method, underlyingObject, extraArgs);\r\n        };\r\n      }\r\n\r\n      case 1: {\r\n        return arg => {\r\n          const fullArgs = [arg].concat(extraArgs);\r\n          return PromiseCall(method, underlyingObject, fullArgs);\r\n        };\r\n      }\r\n    }\r\n  }\r\n  return () => Promise.resolve();\r\n};\r\n\r\nexports.InvokeOrNoop = (O, P, args) => {\r\n  assert(O !== undefined);\r\n  assert(IsPropertyKey(P));\r\n  assert(Array.isArray(args));\r\n\r\n  const method = O[P];\r\n  if (method === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  return Call(method, O, args);\r\n};\r\n\r\nfunction PromiseCall(F, V, args) {\r\n  assert(typeof F === 'function');\r\n  assert(V !== undefined);\r\n  assert(Array.isArray(args));\r\n  try {\r\n    return Promise.resolve(Call(F, V, args));\r\n  } catch (value) {\r\n    return Promise.reject(value);\r\n  }\r\n}\r\n\r\nexports.PromiseCall = PromiseCall;\r\n\r\n// Not implemented correctly\r\nexports.TransferArrayBuffer = O => {\r\n  assert(!exports.IsDetachedBuffer(O));\r\n  const transferredIshVersion = O.slice();\r\n\r\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\r\n  // ArrayBuffer and checking if its byteLength starts returning 0.\r\n  Object.defineProperty(O, 'byteLength', {\r\n    get() {\r\n      return 0;\r\n    }\r\n  });\r\n  O[isFakeDetached] = true;\r\n\r\n  return transferredIshVersion;\r\n};\r\n\r\n// Not implemented correctly\r\nexports.IsDetachedBuffer = O => {\r\n  return isFakeDetached in O;\r\n};\r\n\r\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\r\n  highWaterMark = Number(highWaterMark);\r\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\r\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\r\n  }\r\n\r\n  return highWaterMark;\r\n};\r\n\r\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\r\n  if (size === undefined) {\r\n    return () => 1;\r\n  }\r\n  if (typeof size !== 'function') {\r\n    throw new TypeError('size property of a queuing strategy must be a function');\r\n  }\r\n  return chunk => size(chunk);\r\n};\r\n","import { noop } from '../utils';\n\nexport default function assert() {\n  // do nothing\n}\n\nassert.AssertionError = noop;\n","'use strict';\r\nconst assert = require('assert');\r\n\r\nexports.rethrowAssertionErrorRejection = e => {\r\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\r\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\r\n  // expect any errors, but assertion errors are always problematic.\r\n  if (e && e instanceof assert.AssertionError) {\r\n    setTimeout(() => {\r\n      throw e;\r\n    }, 0);\r\n  }\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\r\n\r\nexports.DequeueValue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n  assert(container._queue.length > 0);\r\n\r\n  const pair = container._queue.shift();\r\n  container._queueTotalSize -= pair.size;\r\n  if (container._queueTotalSize < 0) {\r\n    container._queueTotalSize = 0;\r\n  }\r\n\r\n  return pair.value;\r\n};\r\n\r\nexports.EnqueueValueWithSize = (container, value, size) => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n\r\n  size = Number(size);\r\n  if (!IsFiniteNonNegativeNumber(size)) {\r\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\r\n  }\r\n\r\n  container._queue.push({ value, size });\r\n  container._queueTotalSize += size;\r\n};\r\n\r\nexports.PeekQueueValue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n  assert(container._queue.length > 0);\r\n\r\n  const pair = container._queue[0];\r\n  return pair.value;\r\n};\r\n\r\nexports.ResetQueue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n\r\n  container._queue = [];\r\n  container._queueTotalSize = 0;\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\r\n// and do not appear in the standard text.\r\nconst verbose = require('debug')('streams:writable-stream:verbose');\r\n\r\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\r\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\r\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\r\n\r\nconst AbortSteps = Symbol('[[AbortSteps]]');\r\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\r\n\r\nclass WritableStream {\r\n  constructor(underlyingSink = {}, { size, highWaterMark = 1 } = {}) {\r\n    InitializeWritableStream(this);\r\n\r\n    const type = underlyingSink.type;\r\n\r\n    if (type !== undefined) {\r\n      throw new RangeError('Invalid type is specified');\r\n    }\r\n\r\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\r\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\r\n  }\r\n\r\n  get locked() {\r\n    if (IsWritableStream(this) === false) {\r\n      throw streamBrandCheckException('locked');\r\n    }\r\n\r\n    return IsWritableStreamLocked(this);\r\n  }\r\n\r\n  abort(reason) {\r\n    if (IsWritableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('abort'));\r\n    }\r\n\r\n    if (IsWritableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\r\n    }\r\n\r\n    return WritableStreamAbort(this, reason);\r\n  }\r\n\r\n  getWriter() {\r\n    if (IsWritableStream(this) === false) {\r\n      throw streamBrandCheckException('getWriter');\r\n    }\r\n\r\n    return AcquireWritableStreamDefaultWriter(this);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  AcquireWritableStreamDefaultWriter,\r\n  CreateWritableStream,\r\n  IsWritableStream,\r\n  IsWritableStreamLocked,\r\n  WritableStream,\r\n  WritableStreamAbort,\r\n  WritableStreamDefaultControllerErrorIfNeeded,\r\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\r\n  WritableStreamDefaultWriterRelease,\r\n  WritableStreamDefaultWriterWrite,\r\n  WritableStreamCloseQueuedOrInFlight\r\n};\r\n\r\n// Abstract operations for the WritableStream.\r\n\r\nfunction AcquireWritableStreamDefaultWriter(stream) {\r\n  return new WritableStreamDefaultWriter(stream);\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\r\n                              sizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n\r\n  const stream = Object.create(WritableStream.prototype);\r\n  InitializeWritableStream(stream);\r\n\r\n  const controller = Object.create(WritableStreamDefaultController.prototype);\r\n\r\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\r\n  return stream;\r\n}\r\n\r\nfunction InitializeWritableStream(stream) {\r\n  stream._state = 'writable';\r\n\r\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\r\n  // 'erroring' or 'errored'. May be set to an undefined value.\r\n  stream._storedError = undefined;\r\n\r\n  stream._writer = undefined;\r\n\r\n  // Initialize to undefined first because the constructor of the controller checks this\r\n  // variable to validate the caller.\r\n  stream._writableStreamController = undefined;\r\n\r\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\r\n  // producer without waiting for the queued writes to finish.\r\n  stream._writeRequests = [];\r\n\r\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\r\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\r\n  stream._inFlightWriteRequest = undefined;\r\n\r\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\r\n  // has been detached.\r\n  stream._closeRequest = undefined;\r\n\r\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\r\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\r\n  stream._pendingAbortRequest = undefined;\r\n\r\n  // The backpressure signal set by the controller.\r\n  stream._backpressure = false;\r\n}\r\n\r\nfunction IsWritableStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsWritableStreamLocked(stream) {\r\n  assert(IsWritableStream(stream) === true);\r\n\r\n  if (stream._writer === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamAbort(stream, reason) {\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return Promise.resolve(undefined);\r\n  }\r\n  if (stream._pendingAbortRequest !== undefined) {\r\n    return stream._pendingAbortRequest._promise;\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  let wasAlreadyErroring = false;\r\n  if (state === 'erroring') {\r\n    wasAlreadyErroring = true;\r\n    // reason will not be used, so don't keep a reference to it.\r\n    reason = undefined;\r\n  }\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    stream._pendingAbortRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject,\r\n      _reason: reason,\r\n      _wasAlreadyErroring: wasAlreadyErroring\r\n    };\r\n  });\r\n  stream._pendingAbortRequest._promise = promise;\r\n\r\n  if (wasAlreadyErroring === false) {\r\n    WritableStreamStartErroring(stream, reason);\r\n  }\r\n\r\n  return promise;\r\n}\r\n\r\n// WritableStream API exposed for controllers.\r\n\r\nfunction WritableStreamAddWriteRequest(stream) {\r\n  assert(IsWritableStreamLocked(stream) === true);\r\n  assert(stream._state === 'writable');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const writeRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._writeRequests.push(writeRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction WritableStreamDealWithRejection(stream, error) {\r\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\r\n  const state = stream._state;\r\n\r\n  if (state === 'writable') {\r\n    WritableStreamStartErroring(stream, error);\r\n    return;\r\n  }\r\n\r\n  assert(state === 'erroring');\r\n  WritableStreamFinishErroring(stream);\r\n}\r\n\r\nfunction WritableStreamStartErroring(stream, reason) {\r\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\r\n  assert(stream._storedError === undefined);\r\n  assert(stream._state === 'writable');\r\n\r\n  const controller = stream._writableStreamController;\r\n  assert(controller !== undefined);\r\n\r\n  stream._state = 'erroring';\r\n  stream._storedError = reason;\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\r\n  }\r\n\r\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\r\n    WritableStreamFinishErroring(stream);\r\n  }\r\n}\r\n\r\nfunction WritableStreamFinishErroring(stream) {\r\n  verbose('WritableStreamFinishErroring()');\r\n  assert(stream._state === 'erroring');\r\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\r\n  stream._state = 'errored';\r\n  stream._writableStreamController[ErrorSteps]();\r\n\r\n  const storedError = stream._storedError;\r\n  for (const writeRequest of stream._writeRequests) {\r\n    writeRequest._reject(storedError);\r\n  }\r\n  stream._writeRequests = [];\r\n\r\n  if (stream._pendingAbortRequest === undefined) {\r\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n    return;\r\n  }\r\n\r\n  const abortRequest = stream._pendingAbortRequest;\r\n  stream._pendingAbortRequest = undefined;\r\n\r\n  if (abortRequest._wasAlreadyErroring === true) {\r\n    abortRequest._reject(storedError);\r\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n    return;\r\n  }\r\n\r\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\r\n  promise.then(\r\n      () => {\r\n        abortRequest._resolve();\r\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n      },\r\n      reason => {\r\n        abortRequest._reject(reason);\r\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n      });\r\n}\r\n\r\nfunction WritableStreamFinishInFlightWrite(stream) {\r\n  assert(stream._inFlightWriteRequest !== undefined);\r\n  stream._inFlightWriteRequest._resolve(undefined);\r\n  stream._inFlightWriteRequest = undefined;\r\n}\r\n\r\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\r\n  assert(stream._inFlightWriteRequest !== undefined);\r\n  stream._inFlightWriteRequest._reject(error);\r\n  stream._inFlightWriteRequest = undefined;\r\n\r\n  assert(stream._state === 'writable' || stream._state === 'erroring');\r\n\r\n  WritableStreamDealWithRejection(stream, error);\r\n}\r\n\r\nfunction WritableStreamFinishInFlightClose(stream) {\r\n  assert(stream._inFlightCloseRequest !== undefined);\r\n  stream._inFlightCloseRequest._resolve(undefined);\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  const state = stream._state;\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  if (state === 'erroring') {\r\n    // The error was too late to do anything, so it is ignored.\r\n    stream._storedError = undefined;\r\n    if (stream._pendingAbortRequest !== undefined) {\r\n      stream._pendingAbortRequest._resolve();\r\n      stream._pendingAbortRequest = undefined;\r\n    }\r\n  }\r\n\r\n  stream._state = 'closed';\r\n\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    defaultWriterClosedPromiseResolve(writer);\r\n  }\r\n\r\n  assert(stream._pendingAbortRequest === undefined);\r\n  assert(stream._storedError === undefined);\r\n}\r\n\r\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\r\n  assert(stream._inFlightCloseRequest !== undefined);\r\n  stream._inFlightCloseRequest._reject(error);\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  assert(stream._state === 'writable' || stream._state === 'erroring');\r\n\r\n  // Never execute sink abort() after sink close().\r\n  if (stream._pendingAbortRequest !== undefined) {\r\n    stream._pendingAbortRequest._reject(error);\r\n    stream._pendingAbortRequest = undefined;\r\n  }\r\n  WritableStreamDealWithRejection(stream, error);\r\n}\r\n\r\n// TODO(ricea): Fix alphabetical order.\r\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\r\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\r\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\r\n    return false;\r\n  }\r\n\r\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\r\n  assert(stream._inFlightCloseRequest === undefined);\r\n  assert(stream._closeRequest !== undefined);\r\n  stream._inFlightCloseRequest = stream._closeRequest;\r\n  stream._closeRequest = undefined;\r\n}\r\n\r\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\r\n  assert(stream._inFlightWriteRequest === undefined);\r\n  assert(stream._writeRequests.length !== 0);\r\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\r\n}\r\n\r\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\r\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\r\n  assert(stream._state === 'errored');\r\n  if (stream._closeRequest !== undefined) {\r\n    assert(stream._inFlightCloseRequest === undefined);\r\n\r\n    stream._closeRequest._reject(stream._storedError);\r\n    stream._closeRequest = undefined;\r\n  }\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\r\n    writer._closedPromise.catch(() => {});\r\n  }\r\n}\r\n\r\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\r\n  assert(stream._state === 'writable');\r\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\r\n\r\n  const writer = stream._writer;\r\n  if (writer !== undefined && backpressure !== stream._backpressure) {\r\n    if (backpressure === true) {\r\n      defaultWriterReadyPromiseReset(writer);\r\n    } else {\r\n      assert(backpressure === false);\r\n\r\n      defaultWriterReadyPromiseResolve(writer);\r\n    }\r\n  }\r\n\r\n  stream._backpressure = backpressure;\r\n}\r\n\r\nclass WritableStreamDefaultWriter {\r\n  constructor(stream) {\r\n    if (IsWritableStream(stream) === false) {\r\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\r\n    }\r\n    if (IsWritableStreamLocked(stream) === true) {\r\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\r\n    }\r\n\r\n    this._ownerWritableStream = stream;\r\n    stream._writer = this;\r\n\r\n    const state = stream._state;\r\n\r\n    if (state === 'writable') {\r\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\r\n        defaultWriterReadyPromiseInitialize(this);\r\n      } else {\r\n        defaultWriterReadyPromiseInitializeAsResolved(this);\r\n      }\r\n\r\n      defaultWriterClosedPromiseInitialize(this);\r\n    } else if (state === 'erroring') {\r\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\r\n      this._readyPromise.catch(() => {});\r\n      defaultWriterClosedPromiseInitialize(this);\r\n    } else if (state === 'closed') {\r\n      defaultWriterReadyPromiseInitializeAsResolved(this);\r\n      defaultWriterClosedPromiseInitializeAsResolved(this);\r\n    } else {\r\n      assert(state === 'errored');\r\n\r\n      const storedError = stream._storedError;\r\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\r\n      this._readyPromise.catch(() => {});\r\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\r\n      this._closedPromise.catch(() => {});\r\n    }\r\n  }\r\n\r\n  get closed() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      throw defaultWriterBrandCheckException('desiredSize');\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      throw defaultWriterLockException('desiredSize');\r\n    }\r\n\r\n    return WritableStreamDefaultWriterGetDesiredSize(this);\r\n  }\r\n\r\n  get ready() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\r\n    }\r\n\r\n    return this._readyPromise;\r\n  }\r\n\r\n  abort(reason) {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('abort'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterAbort(this, reason);\r\n  }\r\n\r\n  close() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('close'));\r\n    }\r\n\r\n    const stream = this._ownerWritableStream;\r\n\r\n    if (stream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('close'));\r\n    }\r\n\r\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\r\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterClose(this);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      throw defaultWriterBrandCheckException('releaseLock');\r\n    }\r\n\r\n    const stream = this._ownerWritableStream;\r\n\r\n    if (stream === undefined) {\r\n      return;\r\n    }\r\n\r\n    assert(stream._writer !== undefined);\r\n\r\n    WritableStreamDefaultWriterRelease(this);\r\n  }\r\n\r\n  write(chunk) {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('write'));\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('write to'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterWrite(this, chunk);\r\n  }\r\n}\r\n\r\n// Abstract operations for the WritableStreamDefaultWriter.\r\n\r\nfunction IsWritableStreamDefaultWriter(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\r\n\r\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  return WritableStreamAbort(stream, reason);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterClose(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return Promise.reject(new TypeError(\r\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const closeRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._closeRequest = closeRequest;\r\n  });\r\n\r\n  if (stream._backpressure === true && state === 'writable') {\r\n    defaultWriterReadyPromiseResolve(writer);\r\n  }\r\n\r\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\r\n\r\n  return promise;\r\n}\r\n\r\n\r\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const state = stream._state;\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\r\n    return Promise.resolve();\r\n  }\r\n\r\n  if (state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  return WritableStreamDefaultWriterClose(writer);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\r\n  if (writer._closedPromiseState === 'pending') {\r\n    defaultWriterClosedPromiseReject(writer, error);\r\n  } else {\r\n    defaultWriterClosedPromiseResetToRejected(writer, error);\r\n  }\r\n  writer._closedPromise.catch(() => {});\r\n}\r\n\r\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\r\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\r\n  if (writer._readyPromiseState === 'pending') {\r\n    defaultWriterReadyPromiseReject(writer, error);\r\n  } else {\r\n    defaultWriterReadyPromiseResetToRejected(writer, error);\r\n  }\r\n  writer._readyPromise.catch(() => {});\r\n}\r\n\r\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored' || state === 'erroring') {\r\n    return null;\r\n  }\r\n\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterRelease(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n  assert(stream !== undefined);\r\n  assert(stream._writer === writer);\r\n\r\n  const releasedError = new TypeError(\r\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\r\n\r\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\r\n\r\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\r\n  // rejected until afterwards. This means that simply testing state will not work.\r\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\r\n\r\n  stream._writer = undefined;\r\n  writer._ownerWritableStream = undefined;\r\n}\r\n\r\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const controller = stream._writableStreamController;\r\n\r\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\r\n\r\n  if (stream !== writer._ownerWritableStream) {\r\n    return Promise.reject(defaultWriterLockException('write to'));\r\n  }\r\n\r\n  const state = stream._state;\r\n  if (state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\r\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\r\n  }\r\n  if (state === 'erroring') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(state === 'writable');\r\n\r\n  const promise = WritableStreamAddWriteRequest(stream);\r\n\r\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\r\n\r\n  return promise;\r\n}\r\n\r\nclass WritableStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\r\n  }\r\n\r\n  error(e) {\r\n    if (IsWritableStreamDefaultController(this) === false) {\r\n      throw new TypeError(\r\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\r\n    }\r\n    const state = this._controlledWritableStream._state;\r\n    if (state !== 'writable') {\r\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\r\n      // just treat it as a no-op.\r\n      return;\r\n    }\r\n\r\n    WritableStreamDefaultControllerError(this, e);\r\n  }\r\n\r\n  [AbortSteps](reason) {\r\n    return this._abortAlgorithm(reason);\r\n  }\r\n\r\n  [ErrorSteps]() {\r\n    ResetQueue(this);\r\n  }\r\n}\r\n\r\n// Abstract operations implementing interface required by the WritableStream.\r\n\r\nfunction IsWritableStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\r\n  assert(IsWritableStream(stream) === true);\r\n  assert(stream._writableStreamController === undefined);\r\n\r\n  controller._controlledWritableStream = stream;\r\n  stream._writableStreamController = controller;\r\n\r\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\r\n  controller._queue = undefined;\r\n  controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._started = false;\r\n\r\n  controller._strategySizeAlgorithm = sizeAlgorithm;\r\n  controller._strategyHWM = highWaterMark;\r\n\r\n  controller._writeAlgorithm = writeAlgorithm;\r\n  controller._closeAlgorithm = closeAlgorithm;\r\n  controller._abortAlgorithm = abortAlgorithm;\r\n\r\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n  WritableStreamUpdateBackpressure(stream, backpressure);\r\n\r\n  const startResult = startAlgorithm();\r\n  const startPromise = Promise.resolve(startResult);\r\n  startPromise.then(\r\n      () => {\r\n        assert(stream._state === 'writable' || stream._state === 'erroring');\r\n        controller._started = true;\r\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n      },\r\n      r => {\r\n        assert(stream._state === 'writable' || stream._state === 'erroring');\r\n        controller._started = true;\r\n        WritableStreamDealWithRejection(stream, r);\r\n      }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\r\n  assert(underlyingSink !== undefined);\r\n\r\n  const controller = Object.create(WritableStreamDefaultController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\r\n  }\r\n\r\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\r\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\r\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\r\n\r\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerClose(controller) {\r\n  EnqueueValueWithSize(controller, 'close', 0);\r\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\r\n  try {\r\n    return controller._strategySizeAlgorithm(chunk);\r\n  } catch (chunkSizeE) {\r\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\r\n    return 1;\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\r\n  const writeRecord = { chunk };\r\n\r\n  try {\r\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\r\n  } catch (enqueueE) {\r\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\r\n    return;\r\n  }\r\n\r\n  const stream = controller._controlledWritableStream;\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\r\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n    WritableStreamUpdateBackpressure(stream, backpressure);\r\n  }\r\n\r\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n}\r\n\r\n// Abstract operations for the WritableStreamDefaultController.\r\n\r\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\r\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  if (controller._started === false) {\r\n    return;\r\n  }\r\n\r\n  if (stream._inFlightWriteRequest !== undefined) {\r\n    return;\r\n  }\r\n\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return;\r\n  }\r\n  if (state === 'erroring') {\r\n    WritableStreamFinishErroring(stream);\r\n    return;\r\n  }\r\n\r\n  if (controller._queue.length === 0) {\r\n    return;\r\n  }\r\n\r\n  const writeRecord = PeekQueueValue(controller);\r\n  if (writeRecord === 'close') {\r\n    WritableStreamDefaultControllerProcessClose(controller);\r\n  } else {\r\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\r\n  if (controller._controlledWritableStream._state === 'writable') {\r\n    WritableStreamDefaultControllerError(controller, error);\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerProcessClose(controller) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  WritableStreamMarkCloseRequestInFlight(stream);\r\n\r\n  DequeueValue(controller);\r\n  assert(controller._queue.length === 0);\r\n\r\n  const sinkClosePromise = controller._closeAlgorithm();\r\n  sinkClosePromise.then(\r\n    () => {\r\n      WritableStreamFinishInFlightClose(stream);\r\n    },\r\n    reason => {\r\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\r\n\r\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\r\n  sinkWritePromise.then(\r\n    () => {\r\n      WritableStreamFinishInFlightWrite(stream);\r\n\r\n      const state = stream._state;\r\n      assert(state === 'writable' || state === 'erroring');\r\n\r\n      DequeueValue(controller);\r\n\r\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\r\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n        WritableStreamUpdateBackpressure(stream, backpressure);\r\n      }\r\n\r\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n    },\r\n    reason => {\r\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\r\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\r\n  return desiredSize <= 0;\r\n}\r\n\r\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\r\n\r\nfunction WritableStreamDefaultControllerError(controller, error) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  assert(stream._state === 'writable');\r\n\r\n  WritableStreamStartErroring(stream, error);\r\n}\r\n\r\n// Helper functions for the WritableStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\r\n}\r\n\r\n// Helper functions for the WritableStreamDefaultWriter.\r\n\r\nfunction defaultWriterBrandCheckException(name) {\r\n  return new TypeError(\r\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\r\n}\r\n\r\nfunction defaultWriterLockException(name) {\r\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitialize(writer) {\r\n  writer._closedPromise = new Promise((resolve, reject) => {\r\n    writer._closedPromise_resolve = resolve;\r\n    writer._closedPromise_reject = reject;\r\n    writer._closedPromiseState = 'pending';\r\n  });\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\r\n  writer._closedPromise = Promise.reject(reason);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\r\n  writer._closedPromise = Promise.resolve(undefined);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'resolved';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseReject(writer, reason) {\r\n  assert(writer._closedPromise_resolve !== undefined);\r\n  assert(writer._closedPromise_reject !== undefined);\r\n  assert(writer._closedPromiseState === 'pending');\r\n\r\n  writer._closedPromise_reject(reason);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\r\n  assert(writer._closedPromise_resolve === undefined);\r\n  assert(writer._closedPromise_reject === undefined);\r\n  assert(writer._closedPromiseState !== 'pending');\r\n\r\n  writer._closedPromise = Promise.reject(reason);\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseResolve(writer) {\r\n  assert(writer._closedPromise_resolve !== undefined);\r\n  assert(writer._closedPromise_reject !== undefined);\r\n  assert(writer._closedPromiseState === 'pending');\r\n\r\n  writer._closedPromise_resolve(undefined);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'resolved';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitialize(writer) {\r\n  verbose('defaultWriterReadyPromiseInitialize()');\r\n  writer._readyPromise = new Promise((resolve, reject) => {\r\n    writer._readyPromise_resolve = resolve;\r\n    writer._readyPromise_reject = reject;\r\n  });\r\n  writer._readyPromiseState = 'pending';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\r\n  writer._readyPromise = Promise.reject(reason);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\r\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\r\n  writer._readyPromise = Promise.resolve(undefined);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'fulfilled';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseReject(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\r\n  assert(writer._readyPromise_resolve !== undefined);\r\n  assert(writer._readyPromise_reject !== undefined);\r\n\r\n  writer._readyPromise_reject(reason);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseReset(writer) {\r\n  verbose('defaultWriterReadyPromiseReset()');\r\n  assert(writer._readyPromise_resolve === undefined);\r\n  assert(writer._readyPromise_reject === undefined);\r\n\r\n  writer._readyPromise = new Promise((resolve, reject) => {\r\n    writer._readyPromise_resolve = resolve;\r\n    writer._readyPromise_reject = reject;\r\n  });\r\n  writer._readyPromiseState = 'pending';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\r\n  assert(writer._readyPromise_resolve === undefined);\r\n  assert(writer._readyPromise_reject === undefined);\r\n\r\n  writer._readyPromise = Promise.reject(reason);\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseResolve(writer) {\r\n  verbose('defaultWriterReadyPromiseResolve()');\r\n  assert(writer._readyPromise_resolve !== undefined);\r\n  assert(writer._readyPromise_reject !== undefined);\r\n\r\n  writer._readyPromise_resolve(undefined);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'fulfilled';\r\n}\r\n","'use strict';\r\nconst assert = require('better-assert');\r\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, CreateIterResultObject, IsFiniteNonNegativeNumber,\r\n        InvokeOrNoop, IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject } = require('./helpers.js');\r\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\r\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\r\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\r\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\r\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\r\n      require('./writable-stream.js');\r\n\r\nconst CancelSteps = Symbol('[[CancelSteps]]');\r\nconst PullSteps = Symbol('[[PullSteps]]');\r\n\r\nclass ReadableStream {\r\n  constructor(underlyingSource = {}, { size, highWaterMark } = {}) {\r\n    InitializeReadableStream(this);\r\n    const type = underlyingSource.type;\r\n    const typeString = String(type);\r\n    if (typeString === 'bytes') {\r\n      if (highWaterMark === undefined) {\r\n        highWaterMark = 0;\r\n      }\r\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n      if (size !== undefined) {\r\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\r\n      }\r\n\r\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\r\n    } else if (type === undefined) {\r\n      if (highWaterMark === undefined) {\r\n        highWaterMark = 1;\r\n      }\r\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\r\n\r\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\r\n    } else {\r\n      throw new RangeError('Invalid type is specified');\r\n    }\r\n  }\r\n\r\n  get locked() {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('locked');\r\n    }\r\n\r\n    return IsReadableStreamLocked(this);\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (IsReadableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (IsReadableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\r\n    }\r\n\r\n    return ReadableStreamCancel(this, reason);\r\n  }\r\n\r\n  getReader({ mode } = {}) {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('getReader');\r\n    }\r\n\r\n    if (mode === undefined) {\r\n      return AcquireReadableStreamDefaultReader(this);\r\n    }\r\n\r\n    mode = String(mode);\r\n\r\n    if (mode === 'byob') {\r\n      return AcquireReadableStreamBYOBReader(this);\r\n    }\r\n\r\n    throw new RangeError('Invalid mode is specified');\r\n  }\r\n\r\n  pipeThrough({ writable, readable }, options) {\r\n    if (writable === undefined || readable === undefined) {\r\n      throw new TypeError('readable and writable arguments must be defined');\r\n    }\r\n\r\n    const promise = this.pipeTo(writable, options);\r\n\r\n    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\r\n\r\n    return readable;\r\n  }\r\n\r\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\r\n    if (IsReadableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('pipeTo'));\r\n    }\r\n    if (IsWritableStream(dest) === false) {\r\n      return Promise.reject(\r\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\r\n    }\r\n\r\n    preventClose = Boolean(preventClose);\r\n    preventAbort = Boolean(preventAbort);\r\n    preventCancel = Boolean(preventCancel);\r\n\r\n    if (IsReadableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\r\n    }\r\n    if (IsWritableStreamLocked(dest) === true) {\r\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\r\n    }\r\n\r\n    const reader = AcquireReadableStreamDefaultReader(this);\r\n    const writer = AcquireWritableStreamDefaultWriter(dest);\r\n\r\n    let shuttingDown = false;\r\n\r\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\r\n    let currentWrite = Promise.resolve();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      // Using reader and writer, read all chunks from this and write them to dest\r\n      // - Backpressure must be enforced\r\n      // - Shutdown must stop all activity\r\n      function pipeLoop() {\r\n        if (shuttingDown === true) {\r\n          return Promise.resolve();\r\n        }\r\n\r\n        return writer._readyPromise.then(() => {\r\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\r\n            if (done === true) {\r\n              return;\r\n            }\r\n\r\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\r\n          });\r\n        })\r\n        .then(pipeLoop);\r\n      }\r\n\r\n      // Errors must be propagated forward\r\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\r\n        if (preventAbort === false) {\r\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\r\n        } else {\r\n          shutdown(true, storedError);\r\n        }\r\n      });\r\n\r\n      // Errors must be propagated backward\r\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\r\n        if (preventCancel === false) {\r\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\r\n        } else {\r\n          shutdown(true, storedError);\r\n        }\r\n      });\r\n\r\n      // Closing must be propagated forward\r\n      isOrBecomesClosed(this, reader._closedPromise, () => {\r\n        if (preventClose === false) {\r\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\r\n        } else {\r\n          shutdown();\r\n        }\r\n      });\r\n\r\n      // Closing must be propagated backward\r\n      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\r\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\r\n\r\n        if (preventCancel === false) {\r\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\r\n        } else {\r\n          shutdown(true, destClosed);\r\n        }\r\n      }\r\n\r\n      pipeLoop().catch(err => {\r\n        currentWrite = Promise.resolve();\r\n        rethrowAssertionErrorRejection(err);\r\n      });\r\n\r\n      function waitForWritesToFinish() {\r\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\r\n        // for that too.\r\n        const oldCurrentWrite = currentWrite;\r\n        return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\r\n      }\r\n\r\n      function isOrBecomesErrored(stream, promise, action) {\r\n        if (stream._state === 'errored') {\r\n          action(stream._storedError);\r\n        } else {\r\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function isOrBecomesClosed(stream, promise, action) {\r\n        if (stream._state === 'closed') {\r\n          action();\r\n        } else {\r\n          promise.then(action).catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function shutdownWithAction(action, originalIsError, originalError) {\r\n        if (shuttingDown === true) {\r\n          return;\r\n        }\r\n        shuttingDown = true;\r\n\r\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\r\n          waitForWritesToFinish().then(doTheRest);\r\n        } else {\r\n          doTheRest();\r\n        }\r\n\r\n        function doTheRest() {\r\n          action().then(\r\n            () => finalize(originalIsError, originalError),\r\n            newError => finalize(true, newError)\r\n          )\r\n          .catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function shutdown(isError, error) {\r\n        if (shuttingDown === true) {\r\n          return;\r\n        }\r\n        shuttingDown = true;\r\n\r\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\r\n          waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\r\n        } else {\r\n          finalize(isError, error);\r\n        }\r\n      }\r\n\r\n      function finalize(isError, error) {\r\n        WritableStreamDefaultWriterRelease(writer);\r\n        ReadableStreamReaderGenericRelease(reader);\r\n\r\n        if (isError) {\r\n          reject(error);\r\n        } else {\r\n          resolve(undefined);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  tee() {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('tee');\r\n    }\r\n\r\n    const branches = ReadableStreamTee(this, false);\r\n    return createArrayFromList(branches);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  CreateReadableByteStream,\r\n  CreateReadableStream,\r\n  ReadableStream,\r\n  IsReadableStreamDisturbed,\r\n  ReadableStreamDefaultControllerClose,\r\n  ReadableStreamDefaultControllerEnqueue,\r\n  ReadableStreamDefaultControllerError,\r\n  ReadableStreamDefaultControllerGetDesiredSize,\r\n  ReadableStreamDefaultControllerHasBackpressure,\r\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\r\n};\r\n\r\n// Abstract operations for the ReadableStream.\r\n\r\nfunction AcquireReadableStreamBYOBReader(stream) {\r\n  return new ReadableStreamBYOBReader(stream);\r\n}\r\n\r\nfunction AcquireReadableStreamDefaultReader(stream) {\r\n  return new ReadableStreamDefaultReader(stream);\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\r\n                              sizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n\r\n  const stream = Object.create(ReadableStream.prototype);\r\n  InitializeReadableStream(stream);\r\n\r\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\r\n\r\n  SetUpReadableStreamDefaultController(\r\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\r\n  );\r\n\r\n  return stream;\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\r\n                                  autoAllocateChunkSize = undefined) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\r\n    assert(autoAllocateChunkSize > 0);\r\n  }\r\n\r\n  const stream = Object.create(ReadableStream.prototype);\r\n  InitializeReadableStream(stream);\r\n\r\n  const controller = Object.create(ReadableByteStreamController.prototype);\r\n\r\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\r\n                                    autoAllocateChunkSize);\r\n\r\n  return stream;\r\n}\r\n\r\nfunction InitializeReadableStream(stream) {\r\n  stream._state = 'readable';\r\n  stream._reader = undefined;\r\n  stream._storedError = undefined;\r\n  stream._disturbed = false;\r\n}\r\n\r\nfunction IsReadableStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamDisturbed(stream) {\r\n  assert(IsReadableStream(stream) === true);\r\n\r\n  return stream._disturbed;\r\n}\r\n\r\nfunction IsReadableStreamLocked(stream) {\r\n  assert(IsReadableStream(stream) === true);\r\n\r\n  if (stream._reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamTee(stream, cloneForBranch2) {\r\n  assert(IsReadableStream(stream) === true);\r\n  assert(typeof cloneForBranch2 === 'boolean');\r\n\r\n  const reader = AcquireReadableStreamDefaultReader(stream);\r\n\r\n  let closedOrErrored = false;\r\n  let canceled1 = false;\r\n  let canceled2 = false;\r\n  let reason1;\r\n  let reason2;\r\n  let branch1;\r\n  let branch2;\r\n\r\n  let resolveCancelPromise;\r\n  const cancelPromise = new Promise(resolve => {\r\n    resolveCancelPromise = resolve;\r\n  });\r\n\r\n  function pullAlgorithm() {\r\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\r\n      assert(typeIsObject(result));\r\n      const value = result.value;\r\n      const done = result.done;\r\n      assert(typeof done === 'boolean');\r\n\r\n      if (done === true && closedOrErrored === false) {\r\n        if (canceled1 === false) {\r\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\r\n        }\r\n        if (canceled2 === false) {\r\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\r\n        }\r\n        closedOrErrored = true;\r\n      }\r\n\r\n      if (closedOrErrored === true) {\r\n        return;\r\n      }\r\n\r\n      const value1 = value;\r\n      const value2 = value;\r\n\r\n      // There is no way to access the cloning code right now in the reference implementation.\r\n      // If we add one then we'll need an implementation for serializable objects.\r\n      // if (canceled2 === false && cloneForBranch2 === true) {\r\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\r\n      // }\r\n\r\n      if (canceled1 === false) {\r\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\r\n      }\r\n\r\n      if (canceled2 === false) {\r\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\r\n      }\r\n    });\r\n  }\r\n\r\n  function cancel1Algorithm(reason) {\r\n    canceled1 = true;\r\n    reason1 = reason;\r\n    if (canceled2 === true) {\r\n      const compositeReason = createArrayFromList([reason1, reason2]);\r\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n      resolveCancelPromise(cancelResult);\r\n    }\r\n    return cancelPromise;\r\n  }\r\n\r\n  function cancel2Algorithm(reason) {\r\n    canceled2 = true;\r\n    reason2 = reason;\r\n    if (canceled1 === true) {\r\n      const compositeReason = createArrayFromList([reason1, reason2]);\r\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n      resolveCancelPromise(cancelResult);\r\n    }\r\n    return cancelPromise;\r\n  }\r\n\r\n  function startAlgorithm() {}\r\n\r\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\r\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\r\n\r\n  reader._closedPromise.catch(r => {\r\n    if (closedOrErrored === true) {\r\n      return;\r\n    }\r\n\r\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\r\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\r\n    closedOrErrored = true;\r\n  });\r\n\r\n  return [branch1, branch2];\r\n}\r\n\r\n// ReadableStream API exposed for controllers.\r\n\r\nfunction ReadableStreamAddReadIntoRequest(stream) {\r\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\r\n  assert(stream._state === 'readable' || stream._state === 'closed');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const readIntoRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._reader._readIntoRequests.push(readIntoRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableStreamAddReadRequest(stream) {\r\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\r\n  assert(stream._state === 'readable');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const readRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._reader._readRequests.push(readRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableStreamCancel(stream, reason) {\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'closed') {\r\n    return Promise.resolve(undefined);\r\n  }\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  ReadableStreamClose(stream);\r\n\r\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\r\n  return sourceCancelPromise.then(() => undefined);\r\n}\r\n\r\nfunction ReadableStreamClose(stream) {\r\n  assert(stream._state === 'readable');\r\n\r\n  stream._state = 'closed';\r\n\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === true) {\r\n    for (const { _resolve } of reader._readRequests) {\r\n      _resolve(CreateIterResultObject(undefined, true));\r\n    }\r\n    reader._readRequests = [];\r\n  }\r\n\r\n  defaultReaderClosedPromiseResolve(reader);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamError(stream, e) {\r\n  assert(IsReadableStream(stream) === true);\r\n  assert(stream._state === 'readable');\r\n\r\n  stream._state = 'errored';\r\n  stream._storedError = e;\r\n\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === true) {\r\n    for (const readRequest of reader._readRequests) {\r\n      readRequest._reject(e);\r\n    }\r\n\r\n    reader._readRequests = [];\r\n  } else {\r\n    assert(IsReadableStreamBYOBReader(reader));\r\n\r\n    for (const readIntoRequest of reader._readIntoRequests) {\r\n      readIntoRequest._reject(e);\r\n    }\r\n\r\n    reader._readIntoRequests = [];\r\n  }\r\n\r\n  defaultReaderClosedPromiseReject(reader, e);\r\n  reader._closedPromise.catch(() => {});\r\n}\r\n\r\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\r\n  const reader = stream._reader;\r\n\r\n  assert(reader._readIntoRequests.length > 0);\r\n\r\n  const readIntoRequest = reader._readIntoRequests.shift();\r\n  readIntoRequest._resolve(CreateIterResultObject(chunk, done));\r\n}\r\n\r\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\r\n  const reader = stream._reader;\r\n\r\n  assert(reader._readRequests.length > 0);\r\n\r\n  const readRequest = reader._readRequests.shift();\r\n  readRequest._resolve(CreateIterResultObject(chunk, done));\r\n}\r\n\r\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\r\n  return stream._reader._readIntoRequests.length;\r\n}\r\n\r\nfunction ReadableStreamGetNumReadRequests(stream) {\r\n  return stream._reader._readRequests.length;\r\n}\r\n\r\nfunction ReadableStreamHasBYOBReader(stream) {\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamBYOBReader(reader) === false) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamHasDefaultReader(stream) {\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === false) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// Readers\r\n\r\nclass ReadableStreamDefaultReader {\r\n  constructor(stream) {\r\n    if (IsReadableStream(stream) === false) {\r\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\r\n    }\r\n    if (IsReadableStreamLocked(stream) === true) {\r\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n    }\r\n\r\n    ReadableStreamReaderGenericInitialize(this, stream);\r\n\r\n    this._readRequests = [];\r\n  }\r\n\r\n  get closed() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('cancel'));\r\n    }\r\n\r\n    return ReadableStreamReaderGenericCancel(this, reason);\r\n  }\r\n\r\n  read() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('read'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('read from'));\r\n    }\r\n\r\n    return ReadableStreamDefaultReaderRead(this);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      throw defaultReaderBrandCheckException('releaseLock');\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (this._readRequests.length > 0) {\r\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\r\n    }\r\n\r\n    ReadableStreamReaderGenericRelease(this);\r\n  }\r\n}\r\n\r\nclass ReadableStreamBYOBReader {\r\n  constructor(stream) {\r\n    if (!IsReadableStream(stream)) {\r\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\r\n          'byte source');\r\n    }\r\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\r\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\r\n          'source');\r\n    }\r\n    if (IsReadableStreamLocked(stream)) {\r\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n    }\r\n\r\n    ReadableStreamReaderGenericInitialize(this, stream);\r\n\r\n    this._readIntoRequests = [];\r\n  }\r\n\r\n  get closed() {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('cancel'));\r\n    }\r\n\r\n    return ReadableStreamReaderGenericCancel(this, reason);\r\n  }\r\n\r\n  read(view) {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('read'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('read from'));\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(view)) {\r\n      return Promise.reject(new TypeError('view must be an array buffer view'));\r\n    }\r\n\r\n    if (IsDetachedBuffer(view.buffer) === true) {\r\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\r\n    }\r\n\r\n    if (view.byteLength === 0) {\r\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\r\n    }\r\n\r\n    return ReadableStreamBYOBReaderRead(this, view);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      throw byobReaderBrandCheckException('releaseLock');\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (this._readIntoRequests.length > 0) {\r\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\r\n    }\r\n\r\n    ReadableStreamReaderGenericRelease(this);\r\n  }\r\n}\r\n\r\n// Abstract operations for the readers.\r\n\r\nfunction IsReadableStreamBYOBReader(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamDefaultReader(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\r\n  reader._ownerReadableStream = stream;\r\n  stream._reader = reader;\r\n\r\n  if (stream._state === 'readable') {\r\n    defaultReaderClosedPromiseInitialize(reader);\r\n  } else if (stream._state === 'closed') {\r\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\r\n  } else {\r\n    assert(stream._state === 'errored');\r\n\r\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\r\n    reader._closedPromise.catch(() => {});\r\n  }\r\n}\r\n\r\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\r\n// check.\r\n\r\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\r\n  const stream = reader._ownerReadableStream;\r\n  assert(stream !== undefined);\r\n  return ReadableStreamCancel(stream, reason);\r\n}\r\n\r\nfunction ReadableStreamReaderGenericRelease(reader) {\r\n  assert(reader._ownerReadableStream !== undefined);\r\n  assert(reader._ownerReadableStream._reader === reader);\r\n\r\n  if (reader._ownerReadableStream._state === 'readable') {\r\n    defaultReaderClosedPromiseReject(\r\n        reader,\r\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\r\n  } else {\r\n    defaultReaderClosedPromiseResetToRejected(\r\n        reader,\r\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\r\n  }\r\n  reader._closedPromise.catch(() => {});\r\n\r\n  reader._ownerReadableStream._reader = undefined;\r\n  reader._ownerReadableStream = undefined;\r\n}\r\n\r\nfunction ReadableStreamBYOBReaderRead(reader, view) {\r\n  const stream = reader._ownerReadableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  // Controllers must implement this.\r\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\r\n}\r\n\r\nfunction ReadableStreamDefaultReaderRead(reader) {\r\n  const stream = reader._ownerReadableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'closed') {\r\n    return Promise.resolve(CreateIterResultObject(undefined, true));\r\n  }\r\n\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(stream._state === 'readable');\r\n\r\n  return stream._readableStreamController[PullSteps]();\r\n}\r\n\r\n// Controllers\r\n\r\nclass ReadableStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError();\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\r\n  }\r\n\r\n  close() {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('close');\r\n    }\r\n\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\r\n      throw new TypeError('The stream is not in a state that permits close');\r\n    }\r\n\r\n    ReadableStreamDefaultControllerClose(this);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\r\n      throw new TypeError('The stream is not in a state that permits enqueue');\r\n    }\r\n\r\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(e) {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('error');\r\n    }\r\n\r\n    ReadableStreamDefaultControllerError(this, e);\r\n  }\r\n\r\n  [CancelSteps](reason) {\r\n    ResetQueue(this);\r\n    return this._cancelAlgorithm(reason);\r\n  }\r\n\r\n  [PullSteps]() {\r\n    const stream = this._controlledReadableStream;\r\n\r\n    if (this._queue.length > 0) {\r\n      const chunk = DequeueValue(this);\r\n\r\n      if (this._closeRequested === true && this._queue.length === 0) {\r\n        ReadableStreamClose(stream);\r\n      } else {\r\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n      }\r\n\r\n      return Promise.resolve(CreateIterResultObject(chunk, false));\r\n    }\r\n\r\n    const pendingPromise = ReadableStreamAddReadRequest(stream);\r\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n    return pendingPromise;\r\n  }\r\n}\r\n\r\n// Abstract operations for the ReadableStreamDefaultController.\r\n\r\nfunction IsReadableStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\r\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\r\n  if (shouldPull === false) {\r\n    return undefined;\r\n  }\r\n\r\n  if (controller._pulling === true) {\r\n    controller._pullAgain = true;\r\n    return undefined;\r\n  }\r\n\r\n  assert(controller._pullAgain === false);\r\n\r\n  controller._pulling = true;\r\n\r\n  const pullPromise = controller._pullAlgorithm();\r\n  pullPromise.then(\r\n    () => {\r\n      controller._pulling = false;\r\n\r\n      if (controller._pullAgain === true) {\r\n        controller._pullAgain = false;\r\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n      }\r\n      return undefined;\r\n    },\r\n    e => {\r\n      ReadableStreamDefaultControllerError(controller, e);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\r\n    return false;\r\n  }\r\n\r\n  if (controller._started === false) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\r\n  if (desiredSize > 0) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\r\n\r\nfunction ReadableStreamDefaultControllerClose(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\r\n\r\n  controller._closeRequested = true;\r\n\r\n  if (controller._queue.length === 0) {\r\n    ReadableStreamClose(stream);\r\n  }\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\r\n\r\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\r\n  } else {\r\n    let chunkSize;\r\n    try {\r\n      chunkSize = controller._strategySizeAlgorithm(chunk);\r\n    } catch (chunkSizeE) {\r\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\r\n      throw chunkSizeE;\r\n    }\r\n\r\n    try {\r\n      EnqueueValueWithSize(controller, chunk, chunkSize);\r\n    } catch (enqueueE) {\r\n      ReadableStreamDefaultControllerError(controller, enqueueE);\r\n      throw enqueueE;\r\n    }\r\n  }\r\n\r\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerError(controller, e) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return;\r\n  }\r\n\r\n  ResetQueue(controller);\r\n\r\n  ReadableStreamError(stream, e);\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored') {\r\n    return null;\r\n  }\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\n// This is used in the implementation of TransformStream.\r\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\r\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\r\n  const state = controller._controlledReadableStream._state;\r\n\r\n  if (controller._closeRequested === false && state === 'readable') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction SetUpReadableStreamDefaultController(\r\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\r\n  assert(stream._readableStreamController === undefined);\r\n\r\n  controller._controlledReadableStream = stream;\r\n\r\n  controller._queue = undefined;\r\n  controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._started = false;\r\n  controller._closeRequested = false;\r\n  controller._pullAgain = false;\r\n  controller._pulling = false;\r\n\r\n  controller._strategySizeAlgorithm = sizeAlgorithm;\r\n  controller._strategyHWM = highWaterMark;\r\n\r\n  controller._pullAlgorithm = pullAlgorithm;\r\n  controller._cancelAlgorithm = cancelAlgorithm;\r\n\r\n  stream._readableStreamController = controller;\r\n\r\n  const startResult = startAlgorithm();\r\n  Promise.resolve(startResult).then(\r\n    () => {\r\n      controller._started = true;\r\n\r\n      assert(controller._pulling === false);\r\n      assert(controller._pullAgain === false);\r\n\r\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n    },\r\n    r => {\r\n      ReadableStreamDefaultControllerError(controller, r);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\r\n                                                                  sizeAlgorithm) {\r\n  assert(underlyingSource !== undefined);\r\n\r\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\r\n  }\r\n\r\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\r\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\r\n\r\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\r\n                                       highWaterMark, sizeAlgorithm);\r\n}\r\n\r\nclass ReadableStreamBYOBRequest {\r\n  constructor() {\r\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\r\n  }\r\n\r\n  get view() {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('view');\r\n    }\r\n\r\n    return this._view;\r\n  }\r\n\r\n  respond(bytesWritten) {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('respond');\r\n    }\r\n\r\n    if (this._associatedReadableByteStreamController === undefined) {\r\n      throw new TypeError('This BYOB request has been invalidated');\r\n    }\r\n\r\n    if (IsDetachedBuffer(this._view.buffer) === true) {\r\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\r\n  }\r\n\r\n  respondWithNewView(view) {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('respond');\r\n    }\r\n\r\n    if (this._associatedReadableByteStreamController === undefined) {\r\n      throw new TypeError('This BYOB request has been invalidated');\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(view)) {\r\n      throw new TypeError('You can only respond with array buffer views');\r\n    }\r\n\r\n    if (IsDetachedBuffer(view.buffer) === true) {\r\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\r\n  }\r\n}\r\n\r\nclass ReadableByteStreamController {\r\n  constructor() {\r\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\r\n  }\r\n\r\n  get byobRequest() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('byobRequest');\r\n    }\r\n\r\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\r\n      const firstDescriptor = this._pendingPullIntos[0];\r\n      const view = new Uint8Array(firstDescriptor.buffer,\r\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\r\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\r\n\r\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\r\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\r\n      this._byobRequest = byobRequest;\r\n    }\r\n\r\n    return this._byobRequest;\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    return ReadableByteStreamControllerGetDesiredSize(this);\r\n  }\r\n\r\n  close() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('close');\r\n    }\r\n\r\n    if (this._closeRequested === true) {\r\n      throw new TypeError('The stream has already been closed; do not close it again!');\r\n    }\r\n\r\n    const state = this._controlledReadableByteStream._state;\r\n    if (state !== 'readable') {\r\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\r\n    }\r\n\r\n    ReadableByteStreamControllerClose(this);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    if (this._closeRequested === true) {\r\n      throw new TypeError('stream is closed or draining');\r\n    }\r\n\r\n    const state = this._controlledReadableByteStream._state;\r\n    if (state !== 'readable') {\r\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(chunk)) {\r\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\r\n    }\r\n\r\n    if (IsDetachedBuffer(chunk.buffer) === true) {\r\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\r\n    }\r\n\r\n    ReadableByteStreamControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(e) {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('error');\r\n    }\r\n\r\n    ReadableByteStreamControllerError(this, e);\r\n  }\r\n\r\n  [CancelSteps](reason) {\r\n    if (this._pendingPullIntos.length > 0) {\r\n      const firstDescriptor = this._pendingPullIntos[0];\r\n      firstDescriptor.bytesFilled = 0;\r\n    }\r\n\r\n    ResetQueue(this);\r\n\r\n    return this._cancelAlgorithm(reason);\r\n  }\r\n\r\n  [PullSteps]() {\r\n    const stream = this._controlledReadableByteStream;\r\n    assert(ReadableStreamHasDefaultReader(stream) === true);\r\n\r\n    if (this._queueTotalSize > 0) {\r\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\r\n\r\n      const entry = this._queue.shift();\r\n      this._queueTotalSize -= entry.byteLength;\r\n\r\n      ReadableByteStreamControllerHandleQueueDrain(this);\r\n\r\n      let view;\r\n      try {\r\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\r\n      } catch (viewE) {\r\n        return Promise.reject(viewE);\r\n      }\r\n\r\n      return Promise.resolve(CreateIterResultObject(view, false));\r\n    }\r\n\r\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\r\n    if (autoAllocateChunkSize !== undefined) {\r\n      let buffer;\r\n      try {\r\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\r\n      } catch (bufferE) {\r\n        return Promise.reject(bufferE);\r\n      }\r\n\r\n      const pullIntoDescriptor = {\r\n        buffer,\r\n        byteOffset: 0,\r\n        byteLength: autoAllocateChunkSize,\r\n        bytesFilled: 0,\r\n        elementSize: 1,\r\n        ctor: Uint8Array,\r\n        readerType: 'default'\r\n      };\r\n\r\n      this._pendingPullIntos.push(pullIntoDescriptor);\r\n    }\r\n\r\n    const promise = ReadableStreamAddReadRequest(stream);\r\n\r\n    ReadableByteStreamControllerCallPullIfNeeded(this);\r\n\r\n    return promise;\r\n  }\r\n}\r\n\r\n// Abstract operations for the ReadableByteStreamController.\r\n\r\nfunction IsReadableByteStreamController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamBYOBRequest(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\r\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\r\n  if (shouldPull === false) {\r\n    return undefined;\r\n  }\r\n\r\n  if (controller._pulling === true) {\r\n    controller._pullAgain = true;\r\n    return undefined;\r\n  }\r\n\r\n  assert(controller._pullAgain === false);\r\n\r\n  controller._pulling = true;\r\n\r\n  // TODO: Test controller argument\r\n  const pullPromise = controller._pullAlgorithm();\r\n  pullPromise.then(\r\n    () => {\r\n      controller._pulling = false;\r\n\r\n      if (controller._pullAgain === true) {\r\n        controller._pullAgain = false;\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n      }\r\n    },\r\n    e => {\r\n      ReadableByteStreamControllerError(controller, e);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  controller._pendingPullIntos = [];\r\n}\r\n\r\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\r\n  assert(stream._state !== 'errored');\r\n\r\n  let done = false;\r\n  if (stream._state === 'closed') {\r\n    assert(pullIntoDescriptor.bytesFilled === 0);\r\n    done = true;\r\n  }\r\n\r\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n  if (pullIntoDescriptor.readerType === 'default') {\r\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\r\n  } else {\r\n    assert(pullIntoDescriptor.readerType === 'byob');\r\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\r\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\r\n  const elementSize = pullIntoDescriptor.elementSize;\r\n\r\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\r\n  assert(bytesFilled % elementSize === 0);\r\n\r\n  return new pullIntoDescriptor.ctor(\r\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\r\n}\r\n\r\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\r\n  controller._queue.push({ buffer, byteOffset, byteLength });\r\n  controller._queueTotalSize += byteLength;\r\n}\r\n\r\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\r\n  const elementSize = pullIntoDescriptor.elementSize;\r\n\r\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\r\n\r\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\r\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\r\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\r\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\r\n\r\n  let totalBytesToCopyRemaining = maxBytesToCopy;\r\n  let ready = false;\r\n  if (maxAlignedBytes > currentAlignedBytes) {\r\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\r\n    ready = true;\r\n  }\r\n\r\n  const queue = controller._queue;\r\n\r\n  while (totalBytesToCopyRemaining > 0) {\r\n    const headOfQueue = queue[0];\r\n\r\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\r\n\r\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\r\n\r\n    if (headOfQueue.byteLength === bytesToCopy) {\r\n      queue.shift();\r\n    } else {\r\n      headOfQueue.byteOffset += bytesToCopy;\r\n      headOfQueue.byteLength -= bytesToCopy;\r\n    }\r\n    controller._queueTotalSize -= bytesToCopy;\r\n\r\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\r\n\r\n    totalBytesToCopyRemaining -= bytesToCopy;\r\n  }\r\n\r\n  if (ready === false) {\r\n    assert(controller._queueTotalSize === 0);\r\n    assert(pullIntoDescriptor.bytesFilled > 0);\r\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\r\n  }\r\n\r\n  return ready;\r\n}\r\n\r\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\r\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\r\n\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  pullIntoDescriptor.bytesFilled += size;\r\n}\r\n\r\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\r\n  assert(controller._controlledReadableByteStream._state === 'readable');\r\n\r\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\r\n    ReadableStreamClose(controller._controlledReadableByteStream);\r\n  } else {\r\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\r\n  if (controller._byobRequest === undefined) {\r\n    return;\r\n  }\r\n\r\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\r\n  controller._byobRequest._view = undefined;\r\n  controller._byobRequest = undefined;\r\n}\r\n\r\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\r\n  assert(controller._closeRequested === false);\r\n\r\n  while (controller._pendingPullIntos.length > 0) {\r\n    if (controller._queueTotalSize === 0) {\r\n      return;\r\n    }\r\n\r\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\r\n\r\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\r\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n\r\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\r\n        controller._controlledReadableByteStream,\r\n        pullIntoDescriptor\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerPullInto(controller, view) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  let elementSize = 1;\r\n  if (view.constructor !== DataView) {\r\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\r\n  }\r\n\r\n  const ctor = view.constructor;\r\n\r\n  const buffer = TransferArrayBuffer(view.buffer);\r\n  const pullIntoDescriptor = {\r\n    buffer,\r\n    byteOffset: view.byteOffset,\r\n    byteLength: view.byteLength,\r\n    bytesFilled: 0,\r\n    elementSize,\r\n    ctor,\r\n    readerType: 'byob'\r\n  };\r\n\r\n  if (controller._pendingPullIntos.length > 0) {\r\n    controller._pendingPullIntos.push(pullIntoDescriptor);\r\n\r\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\r\n    // - No change happens on desiredSize\r\n    // - The source has already been notified of that there's at least 1 pending read(view)\r\n\r\n    return ReadableStreamAddReadIntoRequest(stream);\r\n  }\r\n\r\n  if (stream._state === 'closed') {\r\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\r\n    return Promise.resolve(CreateIterResultObject(emptyView, true));\r\n  }\r\n\r\n  if (controller._queueTotalSize > 0) {\r\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\r\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n\r\n      ReadableByteStreamControllerHandleQueueDrain(controller);\r\n\r\n      return Promise.resolve(CreateIterResultObject(filledView, false));\r\n    }\r\n\r\n    if (controller._closeRequested === true) {\r\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n      ReadableByteStreamControllerError(controller, e);\r\n\r\n      return Promise.reject(e);\r\n    }\r\n  }\r\n\r\n  controller._pendingPullIntos.push(pullIntoDescriptor);\r\n\r\n  const promise = ReadableStreamAddReadIntoRequest(stream);\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\r\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\r\n\r\n  assert(firstDescriptor.bytesFilled === 0);\r\n\r\n  const stream = controller._controlledReadableByteStream;\r\n  if (ReadableStreamHasBYOBReader(stream) === true) {\r\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\r\n    }\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\r\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\r\n    throw new RangeError('bytesWritten out of range');\r\n  }\r\n\r\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\r\n\r\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\r\n    // TODO: Figure out whether we should detach the buffer or not here.\r\n    return;\r\n  }\r\n\r\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n\r\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\r\n  if (remainderSize > 0) {\r\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\r\n  }\r\n\r\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\r\n  pullIntoDescriptor.bytesFilled -= remainderSize;\r\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\r\n\r\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\r\n  const firstDescriptor = controller._pendingPullIntos[0];\r\n\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state === 'closed') {\r\n    if (bytesWritten !== 0) {\r\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\r\n  } else {\r\n    assert(stream._state === 'readable');\r\n\r\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\r\n  }\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\r\n  const descriptor = controller._pendingPullIntos.shift();\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  return descriptor;\r\n}\r\n\r\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return false;\r\n  }\r\n\r\n  if (controller._closeRequested === true) {\r\n    return false;\r\n  }\r\n\r\n  if (controller._started === false) {\r\n    return false;\r\n  }\r\n\r\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\r\n\r\nfunction ReadableByteStreamControllerClose(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  assert(controller._closeRequested === false);\r\n  assert(stream._state === 'readable');\r\n\r\n  if (controller._queueTotalSize > 0) {\r\n    controller._closeRequested = true;\r\n\r\n    return;\r\n  }\r\n\r\n  if (controller._pendingPullIntos.length > 0) {\r\n    const firstPendingPullInto = controller._pendingPullIntos[0];\r\n    if (firstPendingPullInto.bytesFilled > 0) {\r\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n      ReadableByteStreamControllerError(controller, e);\r\n\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  ReadableStreamClose(stream);\r\n}\r\n\r\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  assert(controller._closeRequested === false);\r\n  assert(stream._state === 'readable');\r\n\r\n  const buffer = chunk.buffer;\r\n  const byteOffset = chunk.byteOffset;\r\n  const byteLength = chunk.byteLength;\r\n  const transferredBuffer = TransferArrayBuffer(buffer);\r\n\r\n  if (ReadableStreamHasDefaultReader(stream) === true) {\r\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\r\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n    } else {\r\n      assert(controller._queue.length === 0);\r\n\r\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\r\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\r\n    }\r\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\r\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n  } else {\r\n    assert(IsReadableStreamLocked(stream) === false);\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n  }\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerError(controller, e) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return;\r\n  }\r\n\r\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\r\n\r\n  ResetQueue(controller);\r\n  ReadableStreamError(stream, e);\r\n}\r\n\r\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored') {\r\n    return null;\r\n  }\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\r\n  bytesWritten = Number(bytesWritten);\r\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\r\n    throw new RangeError('bytesWritten must be a finite');\r\n  }\r\n\r\n  assert(controller._pendingPullIntos.length > 0);\r\n\r\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\r\n  assert(controller._pendingPullIntos.length > 0);\r\n\r\n  const firstDescriptor = controller._pendingPullIntos[0];\r\n\r\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\r\n    throw new RangeError('The region specified by view does not match byobRequest');\r\n  }\r\n  if (firstDescriptor.byteLength !== view.byteLength) {\r\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\r\n  }\r\n\r\n  firstDescriptor.buffer = view.buffer;\r\n\r\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\r\n}\r\n\r\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\r\n                                           highWaterMark, autoAllocateChunkSize) {\r\n  assert(stream._readableStreamController === undefined);\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\r\n    assert(autoAllocateChunkSize > 0);\r\n  }\r\n\r\n  controller._controlledReadableByteStream = stream;\r\n\r\n  controller._pullAgain = false;\r\n  controller._pulling = false;\r\n\r\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\r\n\r\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\r\n  controller._queue = controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._closeRequested = false;\r\n  controller._started = false;\r\n\r\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n  controller._pullAlgorithm = pullAlgorithm;\r\n  controller._cancelAlgorithm = cancelAlgorithm;\r\n\r\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\r\n\r\n  controller._pendingPullIntos = [];\r\n\r\n  stream._readableStreamController = controller;\r\n\r\n  const startResult = startAlgorithm();\r\n  Promise.resolve(startResult).then(\r\n      () => {\r\n        controller._started = true;\r\n\r\n        assert(controller._pulling === false);\r\n        assert(controller._pullAgain === false);\r\n\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n      },\r\n      r => {\r\n        ReadableByteStreamControllerError(controller, r);\r\n      }\r\n  )\r\n      .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\r\n  assert(underlyingByteSource !== undefined);\r\n\r\n  const controller = Object.create(ReadableByteStreamController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\r\n  }\r\n\r\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\r\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\r\n\r\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\r\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\r\n    }\r\n  }\r\n\r\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\r\n                                    autoAllocateChunkSize);\r\n}\r\n\r\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\r\n  assert(IsReadableByteStreamController(controller) === true);\r\n  assert(typeof view === 'object');\r\n  assert(ArrayBuffer.isView(view) === true);\r\n  assert(IsDetachedBuffer(view.buffer) === false);\r\n  request._associatedReadableByteStreamController = controller;\r\n  request._view = view;\r\n}\r\n\r\n// Helper functions for the ReadableStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\r\n}\r\n\r\n// Helper functions for the readers.\r\n\r\nfunction readerLockException(name) {\r\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultReader.\r\n\r\nfunction defaultReaderBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitialize(reader) {\r\n  reader._closedPromise = new Promise((resolve, reject) => {\r\n    reader._closedPromise_resolve = resolve;\r\n    reader._closedPromise_reject = reject;\r\n  });\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\r\n  reader._closedPromise = Promise.reject(reason);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\r\n  reader._closedPromise = Promise.resolve(undefined);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseReject(reader, reason) {\r\n  assert(reader._closedPromise_resolve !== undefined);\r\n  assert(reader._closedPromise_reject !== undefined);\r\n\r\n  reader._closedPromise_reject(reason);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\r\n  assert(reader._closedPromise_resolve === undefined);\r\n  assert(reader._closedPromise_reject === undefined);\r\n\r\n  reader._closedPromise = Promise.reject(reason);\r\n}\r\n\r\nfunction defaultReaderClosedPromiseResolve(reader) {\r\n  assert(reader._closedPromise_resolve !== undefined);\r\n  assert(reader._closedPromise_reject !== undefined);\r\n\r\n  reader._closedPromise_resolve(undefined);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultReader.\r\n\r\nfunction byobReaderBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultController.\r\n\r\nfunction defaultControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\r\n}\r\n\r\n// Helper functions for the ReadableStreamBYOBRequest.\r\n\r\nfunction byobRequestBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\r\n}\r\n\r\n// Helper functions for the ReadableByteStreamController.\r\n\r\nfunction byteStreamControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\r\n}\r\n\r\n// Helper function for ReadableStream pipeThrough\r\n\r\nfunction ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\r\n  try {\r\n    // This relies on the brand-check that is enforced by Promise.prototype.then(). As with the rest of the reference\r\n    // implementation, it doesn't attempt to do the right thing if someone has modified the global environment.\r\n    Promise.prototype.then.call(promise, undefined, () => {});\r\n  } catch (e) {\r\n    // The brand check failed, therefore the internal slot is not present and there's nothing further to do.\r\n  }\r\n}\r\n","'use strict';\r\nconst { createDataProperty } = require('./helpers.js');\r\n\r\nmodule.exports = class ByteLengthQueuingStrategy {\r\n  constructor({ highWaterMark }) {\r\n    createDataProperty(this, 'highWaterMark', highWaterMark);\r\n  }\r\n\r\n  size(chunk) {\r\n    return chunk.byteLength;\r\n  }\r\n};\r\n","'use strict';\r\nconst { createDataProperty } = require('./helpers.js');\r\n\r\nmodule.exports = class CountQueuingStrategy {\r\n  constructor({ highWaterMark }) {\r\n    createDataProperty(this, 'highWaterMark', highWaterMark);\r\n  }\r\n\r\n  size() {\r\n    return 1;\r\n  }\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\r\n// and do not appear in the standard text.\r\nconst verbose = require('debug')('streams:transform-stream:verbose');\r\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\r\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\r\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\r\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\r\n        ReadableStreamDefaultControllerHasBackpressure,\r\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\r\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\r\n\r\n// Class TransformStream\r\n\r\nclass TransformStream {\r\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\r\n    const readableType = transformer.readableType;\r\n\r\n    if (readableType !== undefined) {\r\n      throw new RangeError('Invalid readable type specified');\r\n    }\r\n\r\n    const writableType = transformer.writableType;\r\n\r\n    if (writableType !== undefined) {\r\n      throw new RangeError('Invalid writable type specified');\r\n    }\r\n\r\n    const writableSizeFunction = writableStrategy.size;\r\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\r\n    let writableHighWaterMark = writableStrategy.highWaterMark;\r\n    if (writableHighWaterMark === undefined) {\r\n      writableHighWaterMark = 1;\r\n    }\r\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\r\n\r\n    const readableSizeFunction = readableStrategy.size;\r\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\r\n    let readableHighWaterMark = readableStrategy.highWaterMark;\r\n    if (readableHighWaterMark === undefined) {\r\n      readableHighWaterMark = 0;\r\n    }\r\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\r\n\r\n    let startPromise_resolve;\r\n    const startPromise = new Promise(resolve => {\r\n      startPromise_resolve = resolve;\r\n    });\r\n\r\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\r\n                              readableSizeAlgorithm);\r\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\r\n\r\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\r\n    startPromise_resolve(startResult);\r\n  }\r\n\r\n  get readable() {\r\n    if (IsTransformStream(this) === false) {\r\n      throw streamBrandCheckException('readable');\r\n    }\r\n\r\n    return this._readable;\r\n  }\r\n\r\n  get writable() {\r\n    if (IsTransformStream(this) === false) {\r\n      throw streamBrandCheckException('writable');\r\n    }\r\n\r\n    return this._writable;\r\n  }\r\n}\r\n\r\n// Transform Stream Abstract Operations\r\n\r\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\r\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\r\n                               readableSizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(writableHighWaterMark));\r\n  assert(IsNonNegativeNumber(readableHighWaterMark));\r\n\r\n  const stream = Object.create(TransformStream.prototype);\r\n\r\n  let startPromise_resolve;\r\n  const startPromise = new Promise(resolve => {\r\n    startPromise_resolve = resolve;\r\n  });\r\n\r\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\r\n                            readableSizeAlgorithm);\r\n\r\n  const controller = Object.create(TransformStreamDefaultController.prototype);\r\n\r\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\r\n\r\n  const startResult = startAlgorithm();\r\n  startPromise_resolve(startResult);\r\n  return stream;\r\n}\r\n\r\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\r\n                                   readableHighWaterMark, readableSizeAlgorithm) {\r\n  function startAlgorithm() {\r\n    return startPromise;\r\n  }\r\n\r\n  function writeAlgorithm(chunk) {\r\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\r\n  }\r\n\r\n  function abortAlgorithm(reason) {\r\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\r\n  }\r\n\r\n  function closeAlgorithm() {\r\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\r\n  }\r\n\r\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\r\n                                          writableHighWaterMark, writableSizeAlgorithm);\r\n\r\n  function pullAlgorithm() {\r\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\r\n  }\r\n\r\n  function cancelAlgorithm(reason) {\r\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\r\n    return Promise.resolve();\r\n  }\r\n\r\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\r\n                                          readableSizeAlgorithm);\r\n\r\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\r\n  stream._backpressure = undefined;\r\n  stream._backpressureChangePromise = undefined;\r\n  stream._backpressureChangePromise_resolve = undefined;\r\n  TransformStreamSetBackpressure(stream, true);\r\n\r\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\r\n  stream._transformStreamController = undefined;\r\n}\r\n\r\nfunction IsTransformStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// This is a no-op if both sides are already errored.\r\nfunction TransformStreamError(stream, e) {\r\n  verbose('TransformStreamError()');\r\n\r\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\r\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\r\n}\r\n\r\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\r\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\r\n  if (stream._backpressure === true) {\r\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\r\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\r\n    // _backpressure is set.\r\n    TransformStreamSetBackpressure(stream, false);\r\n  }\r\n}\r\n\r\nfunction TransformStreamSetBackpressure(stream, backpressure) {\r\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\r\n\r\n  // Passes also when called during construction.\r\n  assert(stream._backpressure !== backpressure);\r\n\r\n  if (stream._backpressureChangePromise !== undefined) {\r\n    stream._backpressureChangePromise_resolve();\r\n  }\r\n\r\n  stream._backpressureChangePromise = new Promise(resolve => {\r\n    stream._backpressureChangePromise_resolve = resolve;\r\n  });\r\n\r\n  stream._backpressure = backpressure;\r\n}\r\n\r\n// Class TransformStreamDefaultController\r\n\r\nclass TransformStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\r\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    TransformStreamDefaultControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(reason) {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('error');\r\n    }\r\n\r\n    TransformStreamDefaultControllerError(this, reason);\r\n  }\r\n\r\n  terminate() {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('terminate');\r\n    }\r\n\r\n    TransformStreamDefaultControllerTerminate(this);\r\n  }\r\n}\r\n\r\n// Transform Stream Default Controller Abstract Operations\r\n\r\nfunction IsTransformStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\r\n  assert(IsTransformStream(stream) === true);\r\n  assert(stream._transformStreamController === undefined);\r\n\r\n  controller._controlledTransformStream = stream;\r\n  stream._transformStreamController = controller;\r\n\r\n  controller._transformAlgorithm = transformAlgorithm;\r\n  controller._flushAlgorithm = flushAlgorithm;\r\n}\r\n\r\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\r\n  assert(transformer !== undefined);\r\n\r\n  const controller = Object.create(TransformStreamDefaultController.prototype);\r\n\r\n  let transformAlgorithm = chunk => {\r\n    try {\r\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\r\n      return Promise.resolve();\r\n    } catch (transformResultE) {\r\n      return Promise.reject(transformResultE);\r\n    }\r\n  };\r\n  const transformMethod = transformer.transform;\r\n  if (transformMethod !== undefined) {\r\n    if (typeof transformMethod !== 'function') {\r\n      throw new TypeError('transform is not a method');\r\n    }\r\n    transformAlgorithm = chunk => {\r\n      const transformPromise = PromiseCall(transformMethod, transformer, [chunk, controller]);\r\n      return transformPromise.catch(e => {\r\n        TransformStreamError(stream, e);\r\n        throw e;\r\n      });\r\n    };\r\n  }\r\n\r\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\r\n\r\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\r\n}\r\n\r\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\r\n  verbose('TransformStreamDefaultControllerEnqueue()');\r\n\r\n  const stream = controller._controlledTransformStream;\r\n  const readableController = stream._readable._readableStreamController;\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\r\n    throw new TypeError('Readable side is not in a state that permits enqueue');\r\n  }\r\n\r\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\r\n  // accept TransformStreamDefaultControllerEnqueue() calls.\r\n\r\n  try {\r\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\r\n  } catch (e) {\r\n    // This happens when readableStrategy.size() throws.\r\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\r\n\r\n    throw stream._readable._storedError;\r\n  }\r\n\r\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\r\n  if (backpressure !== stream._backpressure) {\r\n    assert(backpressure === true);\r\n    TransformStreamSetBackpressure(stream, true);\r\n  }\r\n}\r\n\r\nfunction TransformStreamDefaultControllerError(controller, e) {\r\n  TransformStreamError(controller._controlledTransformStream, e);\r\n}\r\n\r\nfunction TransformStreamDefaultControllerTerminate(controller) {\r\n  verbose('TransformStreamDefaultControllerTerminate()');\r\n\r\n  const stream = controller._controlledTransformStream;\r\n  const readableController = stream._readable._readableStreamController;\r\n\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\r\n    ReadableStreamDefaultControllerClose(readableController);\r\n  }\r\n\r\n  const error = new TypeError('TransformStream terminated');\r\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\r\n}\r\n\r\n// TransformStreamDefaultSink Algorithms\r\n\r\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\r\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\r\n\r\n  assert(stream._writable._state === 'writable');\r\n\r\n  const controller = stream._transformStreamController;\r\n\r\n  if (stream._backpressure === true) {\r\n    const backpressureChangePromise = stream._backpressureChangePromise;\r\n    assert(backpressureChangePromise !== undefined);\r\n    return backpressureChangePromise\r\n        .then(() => {\r\n          const writable = stream._writable;\r\n          const state = writable._state;\r\n          if (state === 'erroring') {\r\n            throw writable._storedError;\r\n          }\r\n          assert(state === 'writable');\r\n          return controller._transformAlgorithm(chunk);\r\n        });\r\n  }\r\n\r\n  return controller._transformAlgorithm(chunk);\r\n}\r\n\r\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\r\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\r\n  // errored.\r\n  TransformStreamError(stream, reason);\r\n  return Promise.resolve();\r\n}\r\n\r\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\r\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\r\n\r\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\r\n  const readable = stream._readable;\r\n\r\n  const flushPromise = stream._transformStreamController._flushAlgorithm();\r\n  // Return a promise that is fulfilled with undefined on success.\r\n  return flushPromise.then(() => {\r\n    if (readable._state === 'errored') {\r\n      throw readable._storedError;\r\n    }\r\n    const readableController = readable._readableStreamController;\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\r\n      ReadableStreamDefaultControllerClose(readableController);\r\n    }\r\n  }).catch(r => {\r\n    TransformStreamError(stream, r);\r\n    throw readable._storedError;\r\n  });\r\n}\r\n\r\n// TransformStreamDefaultSource Algorithms\r\n\r\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\r\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\r\n\r\n  // Invariant. Enforced by the promises returned by start() and pull().\r\n  assert(stream._backpressure === true);\r\n\r\n  assert(stream._backpressureChangePromise !== undefined);\r\n\r\n  TransformStreamSetBackpressure(stream, false);\r\n\r\n  // Prevent the next pull() call until there is backpressure.\r\n  return stream._backpressureChangePromise;\r\n}\r\n\r\nmodule.exports = { CreateTransformStream, TransformStream };\r\n\r\n// Helper functions for the TransformStreamDefaultController.\r\n\r\nfunction defaultControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\r\n}\r\n\r\n// Helper functions for the TransformStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(\r\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\r\n}\r\n"],"names":["NumberIsInteger","Number","isInteger","value","isFinite","Math","floor","FakeSymbol","Symbol","iterator","description","noop","NumberIsNaN","isNaN","x","isFakeDetached","o","p","v","defineProperty","elements","slice","dest","destOffset","src","srcOffset","n","Uint8Array","set","done","obj","exports","IsNonNegativeNumber","Infinity","Number.isNaN","Call","F","V","args","TypeError","Function","prototype","apply","call","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","PromiseCall","fullArgs","arg","concat","Promise","resolve","O","P","reject","transferredIshVersion","highWaterMark","RangeError","size","chunk","assert","AssertionError","e","IsFiniteNonNegativeNumber","require$$0","pair","container","_queue","shift","_queueTotalSize","push","verbose","CreateAlgorithmFromUnderlyingMethod","require$$1","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","typeIsObject","rethrowAssertionErrorRejection","require$$2","DequeueValue","require$$3","EnqueueValueWithSize","PeekQueueValue","ResetQueue","AbortSteps","ErrorSteps","WritableStream","underlyingSink","type","sizeAlgorithm","abort","reason","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","getWriter","AcquireWritableStreamDefaultWriter","stream","WritableStreamDefaultWriter","CreateWritableStream","startAlgorithm","writeAlgorithm","closeAlgorithm","abortAlgorithm","Object","create","controller","WritableStreamDefaultController","InitializeWritableStream","_state","_storedError","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","state","_promise","wasAlreadyErroring","promise","WritableStreamAddWriteRequest","writeRequest","WritableStreamDealWithRejection","error","WritableStreamStartErroring","writer","WritableStreamHasOperationMarkedInFlight","_started","WritableStreamFinishErroring","storedError","_reject","abortRequest","_wasAlreadyErroring","_reason","then","_resolve","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamFinishInFlightClose","WritableStreamFinishInFlightCloseWithError","WritableStreamCloseQueuedOrInFlight","WritableStreamMarkCloseRequestInFlight","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamRejectCloseAndClosedPromiseIfNeeded","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","_ownerWritableStream","_readyPromise","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterAbort","close","WritableStreamDefaultWriterClose","releaseLock","write","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriterGetDesiredSize","closeRequest","WritableStreamDefaultWriterCloseWithErrorPropagation","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","WritableStreamDefaultWriterEnsureReadyPromiseRejected","_readyPromiseState","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterRelease","releasedError","chunkSize","WritableStreamDefaultControllerGetChunkSize","IsWritableStreamDefaultController","_controlledWritableStream","_abortAlgorithm","SetUpWritableStreamDefaultController","_strategySizeAlgorithm","_strategyHWM","_writeAlgorithm","_closeAlgorithm","WritableStreamDefaultControllerGetBackpressure","startResult","startPromise","r","SetUpWritableStreamDefaultControllerFromUnderlyingSink","WritableStreamDefaultControllerClose","chunkSizeE","WritableStreamDefaultControllerWrite","writeRecord","enqueueE","WritableStreamDefaultControllerAdvanceQueueIfNeeded","length","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerProcessClose","sinkClosePromise","WritableStreamDefaultControllerProcessWrite","sinkWritePromise","desiredSize","WritableStreamDefaultControllerError","name","defaultWriterClosedPromiseInitialize","_closedPromise_resolve","_closedPromise_reject","defaultWriterClosedPromiseInitializeAsRejected","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseReject","defaultWriterClosedPromiseResetToRejected","defaultWriterClosedPromiseResolve","defaultWriterReadyPromiseInitialize","_readyPromise_resolve","_readyPromise_reject","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseReset","defaultWriterReadyPromiseResetToRejected","defaultWriterReadyPromiseResolve","ArrayBufferCopy","CreateIterResultObject","IsDetachedBuffer","TransferArrayBuffer","createArrayFromList","CancelSteps","PullSteps","ReadableStream","underlyingSource","typeString","String","cancel","IsReadableStream","IsReadableStreamLocked","ReadableStreamCancel","getReader","mode","AcquireReadableStreamDefaultReader","AcquireReadableStreamBYOBReader","pipeThrough","options","writable","readable","pipeTo","preventClose","preventAbort","preventCancel","Boolean","reader","shuttingDown","currentWrite","pipeLoop","ReadableStreamDefaultReaderRead","destClosed","err","waitForWritesToFinish","oldCurrentWrite","isOrBecomesErrored","action","isOrBecomesClosed","shutdownWithAction","originalIsError","originalError","doTheRest","finalize","newError","shutdown","isError","tee","branches","ReadableStreamTee","ReadableStreamBYOBReader","ReadableStreamDefaultReader","CreateReadableStream","pullAlgorithm","cancelAlgorithm","ReadableStreamDefaultController","CreateReadableByteStream","autoAllocateChunkSize","ReadableByteStreamController","InitializeReadableStream","_reader","_disturbed","IsReadableStreamDisturbed","cloneForBranch2","closedOrErrored","canceled1","canceled2","reason1","reason2","branch1","branch2","resolveCancelPromise","cancelPromise","result","_readableStreamController","value1","value2","cancel1Algorithm","compositeReason","cancelResult","cancel2Algorithm","ReadableStreamAddReadIntoRequest","readIntoRequest","_readIntoRequests","ReadableStreamAddReadRequest","readRequest","_readRequests","sourceCancelPromise","ReadableStreamClose","IsReadableStreamDefaultReader","ReadableStreamError","ReadableStreamFulfillReadIntoRequest","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","IsReadableStreamBYOBReader","ReadableStreamHasDefaultReader","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","read","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","ReadableStreamBYOBReaderRead","ReadableStreamReaderGenericInitialize","ReadableStreamReaderGenericRelease","ReadableByteStreamControllerPullInto","IsReadableStreamDefaultController","defaultControllerBrandCheckException","ReadableStreamDefaultControllerCanCloseOrEnqueue","enqueue","ReadableStreamDefaultControllerEnqueue","_cancelAlgorithm","_controlledReadableStream","_closeRequested","pendingPromise","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCallPullIfNeeded","shouldPull","ReadableStreamDefaultControllerShouldCallPull","_pulling","_pullAgain","pullPromise","_pullAlgorithm","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerHasBackpressure","SetUpReadableStreamDefaultController","SetUpReadableStreamDefaultControllerFromUnderlyingSource","ReadableStreamBYOBRequest","respond","bytesWritten","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_associatedReadableByteStreamController","_view","respondWithNewView","byteStreamControllerBrandCheckException","_controlledReadableByteStream","_pendingPullIntos","firstDescriptor","bytesFilled","entry","byteOffset","viewE","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","_byobRequest","byobRequest","ReadableByteStreamControllerGetDesiredSize","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","readerType","elementSize","ctor","ReadableByteStreamControllerEnqueueChunkToQueue","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerHandleQueueDrain","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","constructor","DataView","BYTES_PER_ELEMENT","emptyView","ReadableByteStreamControllerRespondInClosedState","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInReadableState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInternal","descriptor","ReadableByteStreamControllerClose","firstPendingPullInto","ReadableByteStreamControllerEnqueue","transferredBuffer","transferredView","ReadableByteStreamControllerError","ReadableByteStreamControllerRespond","ReadableByteStreamControllerRespondWithNewView","SetUpReadableByteStreamController","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","Number.isInteger","SetUpReadableStreamBYOBRequest","request","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsRejected","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","defaultReaderClosedPromiseResolve","ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue","createDataProperty","TransformStream","transformer","writableStrategy","readableStrategy","readableType","writableType","writableSizeFunction","writableSizeAlgorithm","writableHighWaterMark","readableSizeFunction","readableSizeAlgorithm","readableHighWaterMark","startPromise_resolve","_transformStreamController","IsTransformStream","_readable","_writable","CreateTransformStream","transformAlgorithm","flushAlgorithm","TransformStreamDefaultController","InitializeTransformStream","TransformStreamDefaultSinkWriteAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSourcePullAlgorithm","_backpressureChangePromise","_backpressureChangePromise_resolve","TransformStreamError","TransformStreamErrorWritableAndUnblockWrite","TransformStreamSetBackpressure","IsTransformStreamDefaultController","terminate","readableController","_controlledTransformStream","SetUpTransformStreamDefaultController","_transformAlgorithm","_flushAlgorithm","SetUpTransformStreamDefaultControllerFromTransformer","transformResultE","transformMethod","transform","transformPromise","TransformStreamDefaultControllerEnqueue","TransformStreamDefaultControllerError","TransformStreamDefaultControllerTerminate","backpressureChangePromise","flushPromise"],"mappings":"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"}