{"version":3,"file":"ponyfill.es6.cjs.min.js","sources":["../src/stub/number-isinteger.js","../src/stub/symbol.js","../src/utils.js","../src/stub/number-isnan.js","../spec/reference-implementation/lib/helpers.js","../src/stub/assert.js","../spec/reference-implementation/lib/utils.js","../spec/reference-implementation/lib/queue-with-sizes.js","../spec/reference-implementation/lib/writable-stream.js","../spec/reference-implementation/lib/readable-stream.js","../spec/reference-implementation/lib/byte-length-queuing-strategy.js","../spec/reference-implementation/lib/count-queuing-strategy.js","../spec/reference-implementation/lib/transform-stream.js"],"sourcesContent":["// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill\nconst NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\nexport default NumberIsInteger;\n","const FakeSymbol = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n  Symbol :\n  description => `Symbol(${description})`;\n\nexport default FakeSymbol;\n","export function noop() {\n  // do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\r\n\r\nfunction IsPropertyKey(argument) {\r\n  return typeof argument === 'string' || typeof argument === 'symbol';\r\n}\r\n\r\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\r\n\r\nexports.createDataProperty = (o, p, v) => {\r\n  assert(exports.typeIsObject(o));\r\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\r\n};\r\n\r\nexports.createArrayFromList = elements => {\r\n  // We use arrays to represent lists, so this is basically a no-op.\r\n  // Do a slice though just in case we happen to depend on the unique-ness.\r\n  return elements.slice();\r\n};\r\n\r\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\r\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\r\n};\r\n\r\nexports.CreateIterResultObject = (value, done) => {\r\n  assert(typeof done === 'boolean');\r\n  const obj = {};\r\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\r\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\r\n  return obj;\r\n};\r\n\r\nexports.IsFiniteNonNegativeNumber = v => {\r\n  if (exports.IsNonNegativeNumber(v) === false) {\r\n    return false;\r\n  }\r\n\r\n  if (v === Infinity) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexports.IsNonNegativeNumber = v => {\r\n  if (typeof v !== 'number') {\r\n    return false;\r\n  }\r\n\r\n  if (Number.isNaN(v)) {\r\n    return false;\r\n  }\r\n\r\n  if (v < 0) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction Call(F, V, args) {\r\n  if (typeof F !== 'function') {\r\n    throw new TypeError('Argument is not a function');\r\n  }\r\n\r\n  return Function.prototype.apply.call(F, V, args);\r\n}\r\n\r\nexports.Call = Call;\r\n\r\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\r\n  assert(underlyingObject !== undefined);\r\n  assert(IsPropertyKey(methodName));\r\n  assert(algoArgCount === 0 || algoArgCount === 1);\r\n  assert(Array.isArray(extraArgs));\r\n  const method = underlyingObject[methodName];\r\n  if (method !== undefined) {\r\n    if (typeof method !== 'function') {\r\n      throw new TypeError(`${method} is not a method`);\r\n    }\r\n    switch (algoArgCount) {\r\n      case 0: {\r\n        return () => {\r\n          return PromiseCall(method, underlyingObject, extraArgs);\r\n        };\r\n      }\r\n\r\n      case 1: {\r\n        return arg => {\r\n          const fullArgs = [arg].concat(extraArgs);\r\n          return PromiseCall(method, underlyingObject, fullArgs);\r\n        };\r\n      }\r\n    }\r\n  }\r\n  return () => Promise.resolve();\r\n};\r\n\r\nexports.InvokeOrNoop = (O, P, args) => {\r\n  assert(O !== undefined);\r\n  assert(IsPropertyKey(P));\r\n  assert(Array.isArray(args));\r\n\r\n  const method = O[P];\r\n  if (method === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  return Call(method, O, args);\r\n};\r\n\r\nfunction PromiseCall(F, V, args) {\r\n  assert(typeof F === 'function');\r\n  assert(V !== undefined);\r\n  assert(Array.isArray(args));\r\n  try {\r\n    return Promise.resolve(Call(F, V, args));\r\n  } catch (value) {\r\n    return Promise.reject(value);\r\n  }\r\n}\r\n\r\nexports.PromiseCall = PromiseCall;\r\n\r\n// Not implemented correctly\r\nexports.TransferArrayBuffer = O => {\r\n  assert(!exports.IsDetachedBuffer(O));\r\n  const transferredIshVersion = O.slice();\r\n\r\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\r\n  // ArrayBuffer and checking if its byteLength starts returning 0.\r\n  Object.defineProperty(O, 'byteLength', {\r\n    get() {\r\n      return 0;\r\n    }\r\n  });\r\n  O[isFakeDetached] = true;\r\n\r\n  return transferredIshVersion;\r\n};\r\n\r\n// Not implemented correctly\r\nexports.IsDetachedBuffer = O => {\r\n  return isFakeDetached in O;\r\n};\r\n\r\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\r\n  highWaterMark = Number(highWaterMark);\r\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\r\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\r\n  }\r\n\r\n  return highWaterMark;\r\n};\r\n\r\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\r\n  if (size === undefined) {\r\n    return () => 1;\r\n  }\r\n  if (typeof size !== 'function') {\r\n    throw new TypeError('size property of a queuing strategy must be a function');\r\n  }\r\n  return chunk => size(chunk);\r\n};\r\n","import { noop } from '../utils';\n\nexport default function assert() {\n  // do nothing\n}\n\nassert.AssertionError = noop;\n","'use strict';\r\nconst assert = require('assert');\r\n\r\nexports.rethrowAssertionErrorRejection = e => {\r\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\r\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\r\n  // expect any errors, but assertion errors are always problematic.\r\n  if (e && e instanceof assert.AssertionError) {\r\n    setTimeout(() => {\r\n      throw e;\r\n    }, 0);\r\n  }\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\r\n\r\nexports.DequeueValue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n  assert(container._queue.length > 0);\r\n\r\n  const pair = container._queue.shift();\r\n  container._queueTotalSize -= pair.size;\r\n  if (container._queueTotalSize < 0) {\r\n    container._queueTotalSize = 0;\r\n  }\r\n\r\n  return pair.value;\r\n};\r\n\r\nexports.EnqueueValueWithSize = (container, value, size) => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n\r\n  size = Number(size);\r\n  if (!IsFiniteNonNegativeNumber(size)) {\r\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\r\n  }\r\n\r\n  container._queue.push({ value, size });\r\n  container._queueTotalSize += size;\r\n};\r\n\r\nexports.PeekQueueValue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n  assert(container._queue.length > 0);\r\n\r\n  const pair = container._queue[0];\r\n  return pair.value;\r\n};\r\n\r\nexports.ResetQueue = container => {\r\n  assert('_queue' in container && '_queueTotalSize' in container);\r\n\r\n  container._queue = [];\r\n  container._queueTotalSize = 0;\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\r\n// and do not appear in the standard text.\r\nconst verbose = require('debug')('streams:writable-stream:verbose');\r\n\r\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\r\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\r\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\r\n\r\nconst AbortSteps = Symbol('[[AbortSteps]]');\r\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\r\n\r\nclass WritableStream {\r\n  constructor(underlyingSink = {}, { size, highWaterMark = 1 } = {}) {\r\n    InitializeWritableStream(this);\r\n\r\n    const type = underlyingSink.type;\r\n\r\n    if (type !== undefined) {\r\n      throw new RangeError('Invalid type is specified');\r\n    }\r\n\r\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\r\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\r\n  }\r\n\r\n  get locked() {\r\n    if (IsWritableStream(this) === false) {\r\n      throw streamBrandCheckException('locked');\r\n    }\r\n\r\n    return IsWritableStreamLocked(this);\r\n  }\r\n\r\n  abort(reason) {\r\n    if (IsWritableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('abort'));\r\n    }\r\n\r\n    if (IsWritableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\r\n    }\r\n\r\n    return WritableStreamAbort(this, reason);\r\n  }\r\n\r\n  getWriter() {\r\n    if (IsWritableStream(this) === false) {\r\n      throw streamBrandCheckException('getWriter');\r\n    }\r\n\r\n    return AcquireWritableStreamDefaultWriter(this);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  AcquireWritableStreamDefaultWriter,\r\n  CreateWritableStream,\r\n  IsWritableStream,\r\n  IsWritableStreamLocked,\r\n  WritableStream,\r\n  WritableStreamAbort,\r\n  WritableStreamDefaultControllerErrorIfNeeded,\r\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\r\n  WritableStreamDefaultWriterRelease,\r\n  WritableStreamDefaultWriterWrite,\r\n  WritableStreamCloseQueuedOrInFlight\r\n};\r\n\r\n// Abstract operations for the WritableStream.\r\n\r\nfunction AcquireWritableStreamDefaultWriter(stream) {\r\n  return new WritableStreamDefaultWriter(stream);\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\r\n                              sizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n\r\n  const stream = Object.create(WritableStream.prototype);\r\n  InitializeWritableStream(stream);\r\n\r\n  const controller = Object.create(WritableStreamDefaultController.prototype);\r\n\r\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\r\n  return stream;\r\n}\r\n\r\nfunction InitializeWritableStream(stream) {\r\n  stream._state = 'writable';\r\n\r\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\r\n  // 'erroring' or 'errored'. May be set to an undefined value.\r\n  stream._storedError = undefined;\r\n\r\n  stream._writer = undefined;\r\n\r\n  // Initialize to undefined first because the constructor of the controller checks this\r\n  // variable to validate the caller.\r\n  stream._writableStreamController = undefined;\r\n\r\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\r\n  // producer without waiting for the queued writes to finish.\r\n  stream._writeRequests = [];\r\n\r\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\r\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\r\n  stream._inFlightWriteRequest = undefined;\r\n\r\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\r\n  // has been detached.\r\n  stream._closeRequest = undefined;\r\n\r\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\r\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\r\n  stream._pendingAbortRequest = undefined;\r\n\r\n  // The backpressure signal set by the controller.\r\n  stream._backpressure = false;\r\n}\r\n\r\nfunction IsWritableStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsWritableStreamLocked(stream) {\r\n  assert(IsWritableStream(stream) === true);\r\n\r\n  if (stream._writer === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamAbort(stream, reason) {\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return Promise.resolve(undefined);\r\n  }\r\n  if (stream._pendingAbortRequest !== undefined) {\r\n    return stream._pendingAbortRequest._promise;\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  let wasAlreadyErroring = false;\r\n  if (state === 'erroring') {\r\n    wasAlreadyErroring = true;\r\n    // reason will not be used, so don't keep a reference to it.\r\n    reason = undefined;\r\n  }\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    stream._pendingAbortRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject,\r\n      _reason: reason,\r\n      _wasAlreadyErroring: wasAlreadyErroring\r\n    };\r\n  });\r\n  stream._pendingAbortRequest._promise = promise;\r\n\r\n  if (wasAlreadyErroring === false) {\r\n    WritableStreamStartErroring(stream, reason);\r\n  }\r\n\r\n  return promise;\r\n}\r\n\r\n// WritableStream API exposed for controllers.\r\n\r\nfunction WritableStreamAddWriteRequest(stream) {\r\n  assert(IsWritableStreamLocked(stream) === true);\r\n  assert(stream._state === 'writable');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const writeRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._writeRequests.push(writeRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction WritableStreamDealWithRejection(stream, error) {\r\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\r\n  const state = stream._state;\r\n\r\n  if (state === 'writable') {\r\n    WritableStreamStartErroring(stream, error);\r\n    return;\r\n  }\r\n\r\n  assert(state === 'erroring');\r\n  WritableStreamFinishErroring(stream);\r\n}\r\n\r\nfunction WritableStreamStartErroring(stream, reason) {\r\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\r\n  assert(stream._storedError === undefined);\r\n  assert(stream._state === 'writable');\r\n\r\n  const controller = stream._writableStreamController;\r\n  assert(controller !== undefined);\r\n\r\n  stream._state = 'erroring';\r\n  stream._storedError = reason;\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\r\n  }\r\n\r\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\r\n    WritableStreamFinishErroring(stream);\r\n  }\r\n}\r\n\r\nfunction WritableStreamFinishErroring(stream) {\r\n  verbose('WritableStreamFinishErroring()');\r\n  assert(stream._state === 'erroring');\r\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\r\n  stream._state = 'errored';\r\n  stream._writableStreamController[ErrorSteps]();\r\n\r\n  const storedError = stream._storedError;\r\n  for (const writeRequest of stream._writeRequests) {\r\n    writeRequest._reject(storedError);\r\n  }\r\n  stream._writeRequests = [];\r\n\r\n  if (stream._pendingAbortRequest === undefined) {\r\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n    return;\r\n  }\r\n\r\n  const abortRequest = stream._pendingAbortRequest;\r\n  stream._pendingAbortRequest = undefined;\r\n\r\n  if (abortRequest._wasAlreadyErroring === true) {\r\n    abortRequest._reject(storedError);\r\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n    return;\r\n  }\r\n\r\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\r\n  promise.then(\r\n      () => {\r\n        abortRequest._resolve();\r\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n      },\r\n      reason => {\r\n        abortRequest._reject(reason);\r\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n      });\r\n}\r\n\r\nfunction WritableStreamFinishInFlightWrite(stream) {\r\n  assert(stream._inFlightWriteRequest !== undefined);\r\n  stream._inFlightWriteRequest._resolve(undefined);\r\n  stream._inFlightWriteRequest = undefined;\r\n}\r\n\r\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\r\n  assert(stream._inFlightWriteRequest !== undefined);\r\n  stream._inFlightWriteRequest._reject(error);\r\n  stream._inFlightWriteRequest = undefined;\r\n\r\n  assert(stream._state === 'writable' || stream._state === 'erroring');\r\n\r\n  WritableStreamDealWithRejection(stream, error);\r\n}\r\n\r\nfunction WritableStreamFinishInFlightClose(stream) {\r\n  assert(stream._inFlightCloseRequest !== undefined);\r\n  stream._inFlightCloseRequest._resolve(undefined);\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  const state = stream._state;\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  if (state === 'erroring') {\r\n    // The error was too late to do anything, so it is ignored.\r\n    stream._storedError = undefined;\r\n    if (stream._pendingAbortRequest !== undefined) {\r\n      stream._pendingAbortRequest._resolve();\r\n      stream._pendingAbortRequest = undefined;\r\n    }\r\n  }\r\n\r\n  stream._state = 'closed';\r\n\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    defaultWriterClosedPromiseResolve(writer);\r\n  }\r\n\r\n  assert(stream._pendingAbortRequest === undefined);\r\n  assert(stream._storedError === undefined);\r\n}\r\n\r\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\r\n  assert(stream._inFlightCloseRequest !== undefined);\r\n  stream._inFlightCloseRequest._reject(error);\r\n  stream._inFlightCloseRequest = undefined;\r\n\r\n  assert(stream._state === 'writable' || stream._state === 'erroring');\r\n\r\n  // Never execute sink abort() after sink close().\r\n  if (stream._pendingAbortRequest !== undefined) {\r\n    stream._pendingAbortRequest._reject(error);\r\n    stream._pendingAbortRequest = undefined;\r\n  }\r\n  WritableStreamDealWithRejection(stream, error);\r\n}\r\n\r\n// TODO(ricea): Fix alphabetical order.\r\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\r\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\r\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\r\n    return false;\r\n  }\r\n\r\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\r\n  return true;\r\n}\r\n\r\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\r\n  assert(stream._inFlightCloseRequest === undefined);\r\n  assert(stream._closeRequest !== undefined);\r\n  stream._inFlightCloseRequest = stream._closeRequest;\r\n  stream._closeRequest = undefined;\r\n}\r\n\r\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\r\n  assert(stream._inFlightWriteRequest === undefined);\r\n  assert(stream._writeRequests.length !== 0);\r\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\r\n}\r\n\r\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\r\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\r\n  assert(stream._state === 'errored');\r\n  if (stream._closeRequest !== undefined) {\r\n    assert(stream._inFlightCloseRequest === undefined);\r\n\r\n    stream._closeRequest._reject(stream._storedError);\r\n    stream._closeRequest = undefined;\r\n  }\r\n  const writer = stream._writer;\r\n  if (writer !== undefined) {\r\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\r\n    writer._closedPromise.catch(() => {});\r\n  }\r\n}\r\n\r\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\r\n  assert(stream._state === 'writable');\r\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\r\n\r\n  const writer = stream._writer;\r\n  if (writer !== undefined && backpressure !== stream._backpressure) {\r\n    if (backpressure === true) {\r\n      defaultWriterReadyPromiseReset(writer);\r\n    } else {\r\n      assert(backpressure === false);\r\n\r\n      defaultWriterReadyPromiseResolve(writer);\r\n    }\r\n  }\r\n\r\n  stream._backpressure = backpressure;\r\n}\r\n\r\nclass WritableStreamDefaultWriter {\r\n  constructor(stream) {\r\n    if (IsWritableStream(stream) === false) {\r\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\r\n    }\r\n    if (IsWritableStreamLocked(stream) === true) {\r\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\r\n    }\r\n\r\n    this._ownerWritableStream = stream;\r\n    stream._writer = this;\r\n\r\n    const state = stream._state;\r\n\r\n    if (state === 'writable') {\r\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\r\n        defaultWriterReadyPromiseInitialize(this);\r\n      } else {\r\n        defaultWriterReadyPromiseInitializeAsResolved(this);\r\n      }\r\n\r\n      defaultWriterClosedPromiseInitialize(this);\r\n    } else if (state === 'erroring') {\r\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\r\n      this._readyPromise.catch(() => {});\r\n      defaultWriterClosedPromiseInitialize(this);\r\n    } else if (state === 'closed') {\r\n      defaultWriterReadyPromiseInitializeAsResolved(this);\r\n      defaultWriterClosedPromiseInitializeAsResolved(this);\r\n    } else {\r\n      assert(state === 'errored');\r\n\r\n      const storedError = stream._storedError;\r\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\r\n      this._readyPromise.catch(() => {});\r\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\r\n      this._closedPromise.catch(() => {});\r\n    }\r\n  }\r\n\r\n  get closed() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      throw defaultWriterBrandCheckException('desiredSize');\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      throw defaultWriterLockException('desiredSize');\r\n    }\r\n\r\n    return WritableStreamDefaultWriterGetDesiredSize(this);\r\n  }\r\n\r\n  get ready() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\r\n    }\r\n\r\n    return this._readyPromise;\r\n  }\r\n\r\n  abort(reason) {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('abort'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterAbort(this, reason);\r\n  }\r\n\r\n  close() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('close'));\r\n    }\r\n\r\n    const stream = this._ownerWritableStream;\r\n\r\n    if (stream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('close'));\r\n    }\r\n\r\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\r\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterClose(this);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      throw defaultWriterBrandCheckException('releaseLock');\r\n    }\r\n\r\n    const stream = this._ownerWritableStream;\r\n\r\n    if (stream === undefined) {\r\n      return;\r\n    }\r\n\r\n    assert(stream._writer !== undefined);\r\n\r\n    WritableStreamDefaultWriterRelease(this);\r\n  }\r\n\r\n  write(chunk) {\r\n    if (IsWritableStreamDefaultWriter(this) === false) {\r\n      return Promise.reject(defaultWriterBrandCheckException('write'));\r\n    }\r\n\r\n    if (this._ownerWritableStream === undefined) {\r\n      return Promise.reject(defaultWriterLockException('write to'));\r\n    }\r\n\r\n    return WritableStreamDefaultWriterWrite(this, chunk);\r\n  }\r\n}\r\n\r\n// Abstract operations for the WritableStreamDefaultWriter.\r\n\r\nfunction IsWritableStreamDefaultWriter(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\r\n\r\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  return WritableStreamAbort(stream, reason);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterClose(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return Promise.reject(new TypeError(\r\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const closeRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._closeRequest = closeRequest;\r\n  });\r\n\r\n  if (stream._backpressure === true && state === 'writable') {\r\n    defaultWriterReadyPromiseResolve(writer);\r\n  }\r\n\r\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\r\n\r\n  return promise;\r\n}\r\n\r\n\r\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const state = stream._state;\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\r\n    return Promise.resolve();\r\n  }\r\n\r\n  if (state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(state === 'writable' || state === 'erroring');\r\n\r\n  return WritableStreamDefaultWriterClose(writer);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\r\n  if (writer._closedPromiseState === 'pending') {\r\n    defaultWriterClosedPromiseReject(writer, error);\r\n  } else {\r\n    defaultWriterClosedPromiseResetToRejected(writer, error);\r\n  }\r\n  writer._closedPromise.catch(() => {});\r\n}\r\n\r\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\r\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\r\n  if (writer._readyPromiseState === 'pending') {\r\n    defaultWriterReadyPromiseReject(writer, error);\r\n  } else {\r\n    defaultWriterReadyPromiseResetToRejected(writer, error);\r\n  }\r\n  writer._readyPromise.catch(() => {});\r\n}\r\n\r\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored' || state === 'erroring') {\r\n    return null;\r\n  }\r\n\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\r\n}\r\n\r\nfunction WritableStreamDefaultWriterRelease(writer) {\r\n  const stream = writer._ownerWritableStream;\r\n  assert(stream !== undefined);\r\n  assert(stream._writer === writer);\r\n\r\n  const releasedError = new TypeError(\r\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\r\n\r\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\r\n\r\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\r\n  // rejected until afterwards. This means that simply testing state will not work.\r\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\r\n\r\n  stream._writer = undefined;\r\n  writer._ownerWritableStream = undefined;\r\n}\r\n\r\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\r\n  const stream = writer._ownerWritableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  const controller = stream._writableStreamController;\r\n\r\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\r\n\r\n  if (stream !== writer._ownerWritableStream) {\r\n    return Promise.reject(defaultWriterLockException('write to'));\r\n  }\r\n\r\n  const state = stream._state;\r\n  if (state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\r\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\r\n  }\r\n  if (state === 'erroring') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(state === 'writable');\r\n\r\n  const promise = WritableStreamAddWriteRequest(stream);\r\n\r\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\r\n\r\n  return promise;\r\n}\r\n\r\nclass WritableStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\r\n  }\r\n\r\n  error(e) {\r\n    if (IsWritableStreamDefaultController(this) === false) {\r\n      throw new TypeError(\r\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\r\n    }\r\n    const state = this._controlledWritableStream._state;\r\n    if (state !== 'writable') {\r\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\r\n      // just treat it as a no-op.\r\n      return;\r\n    }\r\n\r\n    WritableStreamDefaultControllerError(this, e);\r\n  }\r\n\r\n  [AbortSteps](reason) {\r\n    return this._abortAlgorithm(reason);\r\n  }\r\n\r\n  [ErrorSteps]() {\r\n    ResetQueue(this);\r\n  }\r\n}\r\n\r\n// Abstract operations implementing interface required by the WritableStream.\r\n\r\nfunction IsWritableStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\r\n  assert(IsWritableStream(stream) === true);\r\n  assert(stream._writableStreamController === undefined);\r\n\r\n  controller._controlledWritableStream = stream;\r\n  stream._writableStreamController = controller;\r\n\r\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\r\n  controller._queue = undefined;\r\n  controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._started = false;\r\n\r\n  controller._strategySizeAlgorithm = sizeAlgorithm;\r\n  controller._strategyHWM = highWaterMark;\r\n\r\n  controller._writeAlgorithm = writeAlgorithm;\r\n  controller._closeAlgorithm = closeAlgorithm;\r\n  controller._abortAlgorithm = abortAlgorithm;\r\n\r\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n  WritableStreamUpdateBackpressure(stream, backpressure);\r\n\r\n  const startResult = startAlgorithm();\r\n  const startPromise = Promise.resolve(startResult);\r\n  startPromise.then(\r\n      () => {\r\n        assert(stream._state === 'writable' || stream._state === 'erroring');\r\n        controller._started = true;\r\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n      },\r\n      r => {\r\n        assert(stream._state === 'writable' || stream._state === 'erroring');\r\n        controller._started = true;\r\n        WritableStreamDealWithRejection(stream, r);\r\n      }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\r\n  assert(underlyingSink !== undefined);\r\n\r\n  const controller = Object.create(WritableStreamDefaultController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\r\n  }\r\n\r\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\r\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\r\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\r\n\r\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\r\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerClose(controller) {\r\n  EnqueueValueWithSize(controller, 'close', 0);\r\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\r\n  try {\r\n    return controller._strategySizeAlgorithm(chunk);\r\n  } catch (chunkSizeE) {\r\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\r\n    return 1;\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\r\n  const writeRecord = { chunk };\r\n\r\n  try {\r\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\r\n  } catch (enqueueE) {\r\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\r\n    return;\r\n  }\r\n\r\n  const stream = controller._controlledWritableStream;\r\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\r\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n    WritableStreamUpdateBackpressure(stream, backpressure);\r\n  }\r\n\r\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n}\r\n\r\n// Abstract operations for the WritableStreamDefaultController.\r\n\r\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\r\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  if (controller._started === false) {\r\n    return;\r\n  }\r\n\r\n  if (stream._inFlightWriteRequest !== undefined) {\r\n    return;\r\n  }\r\n\r\n  const state = stream._state;\r\n  if (state === 'closed' || state === 'errored') {\r\n    return;\r\n  }\r\n  if (state === 'erroring') {\r\n    WritableStreamFinishErroring(stream);\r\n    return;\r\n  }\r\n\r\n  if (controller._queue.length === 0) {\r\n    return;\r\n  }\r\n\r\n  const writeRecord = PeekQueueValue(controller);\r\n  if (writeRecord === 'close') {\r\n    WritableStreamDefaultControllerProcessClose(controller);\r\n  } else {\r\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\r\n  if (controller._controlledWritableStream._state === 'writable') {\r\n    WritableStreamDefaultControllerError(controller, error);\r\n  }\r\n}\r\n\r\nfunction WritableStreamDefaultControllerProcessClose(controller) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  WritableStreamMarkCloseRequestInFlight(stream);\r\n\r\n  DequeueValue(controller);\r\n  assert(controller._queue.length === 0);\r\n\r\n  const sinkClosePromise = controller._closeAlgorithm();\r\n  sinkClosePromise.then(\r\n    () => {\r\n      WritableStreamFinishInFlightClose(stream);\r\n    },\r\n    reason => {\r\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\r\n\r\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\r\n  sinkWritePromise.then(\r\n    () => {\r\n      WritableStreamFinishInFlightWrite(stream);\r\n\r\n      const state = stream._state;\r\n      assert(state === 'writable' || state === 'erroring');\r\n\r\n      DequeueValue(controller);\r\n\r\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\r\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n        WritableStreamUpdateBackpressure(stream, backpressure);\r\n      }\r\n\r\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n    },\r\n    reason => {\r\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\r\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\r\n  return desiredSize <= 0;\r\n}\r\n\r\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\r\n\r\nfunction WritableStreamDefaultControllerError(controller, error) {\r\n  const stream = controller._controlledWritableStream;\r\n\r\n  assert(stream._state === 'writable');\r\n\r\n  WritableStreamStartErroring(stream, error);\r\n}\r\n\r\n// Helper functions for the WritableStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\r\n}\r\n\r\n// Helper functions for the WritableStreamDefaultWriter.\r\n\r\nfunction defaultWriterBrandCheckException(name) {\r\n  return new TypeError(\r\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\r\n}\r\n\r\nfunction defaultWriterLockException(name) {\r\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitialize(writer) {\r\n  writer._closedPromise = new Promise((resolve, reject) => {\r\n    writer._closedPromise_resolve = resolve;\r\n    writer._closedPromise_reject = reject;\r\n    writer._closedPromiseState = 'pending';\r\n  });\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\r\n  writer._closedPromise = Promise.reject(reason);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\r\n  writer._closedPromise = Promise.resolve(undefined);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'resolved';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseReject(writer, reason) {\r\n  assert(writer._closedPromise_resolve !== undefined);\r\n  assert(writer._closedPromise_reject !== undefined);\r\n  assert(writer._closedPromiseState === 'pending');\r\n\r\n  writer._closedPromise_reject(reason);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\r\n  assert(writer._closedPromise_resolve === undefined);\r\n  assert(writer._closedPromise_reject === undefined);\r\n  assert(writer._closedPromiseState !== 'pending');\r\n\r\n  writer._closedPromise = Promise.reject(reason);\r\n  writer._closedPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterClosedPromiseResolve(writer) {\r\n  assert(writer._closedPromise_resolve !== undefined);\r\n  assert(writer._closedPromise_reject !== undefined);\r\n  assert(writer._closedPromiseState === 'pending');\r\n\r\n  writer._closedPromise_resolve(undefined);\r\n  writer._closedPromise_resolve = undefined;\r\n  writer._closedPromise_reject = undefined;\r\n  writer._closedPromiseState = 'resolved';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitialize(writer) {\r\n  verbose('defaultWriterReadyPromiseInitialize()');\r\n  writer._readyPromise = new Promise((resolve, reject) => {\r\n    writer._readyPromise_resolve = resolve;\r\n    writer._readyPromise_reject = reject;\r\n  });\r\n  writer._readyPromiseState = 'pending';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\r\n  writer._readyPromise = Promise.reject(reason);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\r\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\r\n  writer._readyPromise = Promise.resolve(undefined);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'fulfilled';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseReject(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\r\n  assert(writer._readyPromise_resolve !== undefined);\r\n  assert(writer._readyPromise_reject !== undefined);\r\n\r\n  writer._readyPromise_reject(reason);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseReset(writer) {\r\n  verbose('defaultWriterReadyPromiseReset()');\r\n  assert(writer._readyPromise_resolve === undefined);\r\n  assert(writer._readyPromise_reject === undefined);\r\n\r\n  writer._readyPromise = new Promise((resolve, reject) => {\r\n    writer._readyPromise_resolve = resolve;\r\n    writer._readyPromise_reject = reject;\r\n  });\r\n  writer._readyPromiseState = 'pending';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\r\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\r\n  assert(writer._readyPromise_resolve === undefined);\r\n  assert(writer._readyPromise_reject === undefined);\r\n\r\n  writer._readyPromise = Promise.reject(reason);\r\n  writer._readyPromiseState = 'rejected';\r\n}\r\n\r\nfunction defaultWriterReadyPromiseResolve(writer) {\r\n  verbose('defaultWriterReadyPromiseResolve()');\r\n  assert(writer._readyPromise_resolve !== undefined);\r\n  assert(writer._readyPromise_reject !== undefined);\r\n\r\n  writer._readyPromise_resolve(undefined);\r\n  writer._readyPromise_resolve = undefined;\r\n  writer._readyPromise_reject = undefined;\r\n  writer._readyPromiseState = 'fulfilled';\r\n}\r\n","'use strict';\r\nconst assert = require('better-assert');\r\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, CreateIterResultObject, IsFiniteNonNegativeNumber,\r\n        InvokeOrNoop, IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject } = require('./helpers.js');\r\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\r\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\r\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\r\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\r\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\r\n      require('./writable-stream.js');\r\n\r\nconst CancelSteps = Symbol('[[CancelSteps]]');\r\nconst PullSteps = Symbol('[[PullSteps]]');\r\n\r\nclass ReadableStream {\r\n  constructor(underlyingSource = {}, { size, highWaterMark } = {}) {\r\n    InitializeReadableStream(this);\r\n    const type = underlyingSource.type;\r\n    const typeString = String(type);\r\n    if (typeString === 'bytes') {\r\n      if (highWaterMark === undefined) {\r\n        highWaterMark = 0;\r\n      }\r\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n      if (size !== undefined) {\r\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\r\n      }\r\n\r\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\r\n    } else if (type === undefined) {\r\n      if (highWaterMark === undefined) {\r\n        highWaterMark = 1;\r\n      }\r\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\r\n\r\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\r\n    } else {\r\n      throw new RangeError('Invalid type is specified');\r\n    }\r\n  }\r\n\r\n  get locked() {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('locked');\r\n    }\r\n\r\n    return IsReadableStreamLocked(this);\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (IsReadableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (IsReadableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\r\n    }\r\n\r\n    return ReadableStreamCancel(this, reason);\r\n  }\r\n\r\n  getReader({ mode } = {}) {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('getReader');\r\n    }\r\n\r\n    if (mode === undefined) {\r\n      return AcquireReadableStreamDefaultReader(this);\r\n    }\r\n\r\n    mode = String(mode);\r\n\r\n    if (mode === 'byob') {\r\n      return AcquireReadableStreamBYOBReader(this);\r\n    }\r\n\r\n    throw new RangeError('Invalid mode is specified');\r\n  }\r\n\r\n  pipeThrough({ writable, readable }, options) {\r\n    if (writable === undefined || readable === undefined) {\r\n      throw new TypeError('readable and writable arguments must be defined');\r\n    }\r\n\r\n    const promise = this.pipeTo(writable, options);\r\n\r\n    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\r\n\r\n    return readable;\r\n  }\r\n\r\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\r\n    if (IsReadableStream(this) === false) {\r\n      return Promise.reject(streamBrandCheckException('pipeTo'));\r\n    }\r\n    if (IsWritableStream(dest) === false) {\r\n      return Promise.reject(\r\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\r\n    }\r\n\r\n    preventClose = Boolean(preventClose);\r\n    preventAbort = Boolean(preventAbort);\r\n    preventCancel = Boolean(preventCancel);\r\n\r\n    if (IsReadableStreamLocked(this) === true) {\r\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\r\n    }\r\n    if (IsWritableStreamLocked(dest) === true) {\r\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\r\n    }\r\n\r\n    const reader = AcquireReadableStreamDefaultReader(this);\r\n    const writer = AcquireWritableStreamDefaultWriter(dest);\r\n\r\n    let shuttingDown = false;\r\n\r\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\r\n    let currentWrite = Promise.resolve();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      // Using reader and writer, read all chunks from this and write them to dest\r\n      // - Backpressure must be enforced\r\n      // - Shutdown must stop all activity\r\n      function pipeLoop() {\r\n        if (shuttingDown === true) {\r\n          return Promise.resolve();\r\n        }\r\n\r\n        return writer._readyPromise.then(() => {\r\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\r\n            if (done === true) {\r\n              return;\r\n            }\r\n\r\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\r\n          });\r\n        })\r\n        .then(pipeLoop);\r\n      }\r\n\r\n      // Errors must be propagated forward\r\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\r\n        if (preventAbort === false) {\r\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\r\n        } else {\r\n          shutdown(true, storedError);\r\n        }\r\n      });\r\n\r\n      // Errors must be propagated backward\r\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\r\n        if (preventCancel === false) {\r\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\r\n        } else {\r\n          shutdown(true, storedError);\r\n        }\r\n      });\r\n\r\n      // Closing must be propagated forward\r\n      isOrBecomesClosed(this, reader._closedPromise, () => {\r\n        if (preventClose === false) {\r\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\r\n        } else {\r\n          shutdown();\r\n        }\r\n      });\r\n\r\n      // Closing must be propagated backward\r\n      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\r\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\r\n\r\n        if (preventCancel === false) {\r\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\r\n        } else {\r\n          shutdown(true, destClosed);\r\n        }\r\n      }\r\n\r\n      pipeLoop().catch(err => {\r\n        currentWrite = Promise.resolve();\r\n        rethrowAssertionErrorRejection(err);\r\n      });\r\n\r\n      function waitForWritesToFinish() {\r\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\r\n        // for that too.\r\n        const oldCurrentWrite = currentWrite;\r\n        return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\r\n      }\r\n\r\n      function isOrBecomesErrored(stream, promise, action) {\r\n        if (stream._state === 'errored') {\r\n          action(stream._storedError);\r\n        } else {\r\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function isOrBecomesClosed(stream, promise, action) {\r\n        if (stream._state === 'closed') {\r\n          action();\r\n        } else {\r\n          promise.then(action).catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function shutdownWithAction(action, originalIsError, originalError) {\r\n        if (shuttingDown === true) {\r\n          return;\r\n        }\r\n        shuttingDown = true;\r\n\r\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\r\n          waitForWritesToFinish().then(doTheRest);\r\n        } else {\r\n          doTheRest();\r\n        }\r\n\r\n        function doTheRest() {\r\n          action().then(\r\n            () => finalize(originalIsError, originalError),\r\n            newError => finalize(true, newError)\r\n          )\r\n          .catch(rethrowAssertionErrorRejection);\r\n        }\r\n      }\r\n\r\n      function shutdown(isError, error) {\r\n        if (shuttingDown === true) {\r\n          return;\r\n        }\r\n        shuttingDown = true;\r\n\r\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\r\n          waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\r\n        } else {\r\n          finalize(isError, error);\r\n        }\r\n      }\r\n\r\n      function finalize(isError, error) {\r\n        WritableStreamDefaultWriterRelease(writer);\r\n        ReadableStreamReaderGenericRelease(reader);\r\n\r\n        if (isError) {\r\n          reject(error);\r\n        } else {\r\n          resolve(undefined);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  tee() {\r\n    if (IsReadableStream(this) === false) {\r\n      throw streamBrandCheckException('tee');\r\n    }\r\n\r\n    const branches = ReadableStreamTee(this, false);\r\n    return createArrayFromList(branches);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  CreateReadableByteStream,\r\n  CreateReadableStream,\r\n  ReadableStream,\r\n  IsReadableStreamDisturbed,\r\n  ReadableStreamDefaultControllerClose,\r\n  ReadableStreamDefaultControllerEnqueue,\r\n  ReadableStreamDefaultControllerError,\r\n  ReadableStreamDefaultControllerGetDesiredSize,\r\n  ReadableStreamDefaultControllerHasBackpressure,\r\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\r\n};\r\n\r\n// Abstract operations for the ReadableStream.\r\n\r\nfunction AcquireReadableStreamBYOBReader(stream) {\r\n  return new ReadableStreamBYOBReader(stream);\r\n}\r\n\r\nfunction AcquireReadableStreamDefaultReader(stream) {\r\n  return new ReadableStreamDefaultReader(stream);\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\r\n                              sizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n\r\n  const stream = Object.create(ReadableStream.prototype);\r\n  InitializeReadableStream(stream);\r\n\r\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\r\n\r\n  SetUpReadableStreamDefaultController(\r\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\r\n  );\r\n\r\n  return stream;\r\n}\r\n\r\n// Throws if and only if startAlgorithm throws.\r\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\r\n                                  autoAllocateChunkSize = undefined) {\r\n  assert(IsNonNegativeNumber(highWaterMark) === true);\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\r\n    assert(autoAllocateChunkSize > 0);\r\n  }\r\n\r\n  const stream = Object.create(ReadableStream.prototype);\r\n  InitializeReadableStream(stream);\r\n\r\n  const controller = Object.create(ReadableByteStreamController.prototype);\r\n\r\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\r\n                                    autoAllocateChunkSize);\r\n\r\n  return stream;\r\n}\r\n\r\nfunction InitializeReadableStream(stream) {\r\n  stream._state = 'readable';\r\n  stream._reader = undefined;\r\n  stream._storedError = undefined;\r\n  stream._disturbed = false;\r\n}\r\n\r\nfunction IsReadableStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamDisturbed(stream) {\r\n  assert(IsReadableStream(stream) === true);\r\n\r\n  return stream._disturbed;\r\n}\r\n\r\nfunction IsReadableStreamLocked(stream) {\r\n  assert(IsReadableStream(stream) === true);\r\n\r\n  if (stream._reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamTee(stream, cloneForBranch2) {\r\n  assert(IsReadableStream(stream) === true);\r\n  assert(typeof cloneForBranch2 === 'boolean');\r\n\r\n  const reader = AcquireReadableStreamDefaultReader(stream);\r\n\r\n  let closedOrErrored = false;\r\n  let canceled1 = false;\r\n  let canceled2 = false;\r\n  let reason1;\r\n  let reason2;\r\n  let branch1;\r\n  let branch2;\r\n\r\n  let resolveCancelPromise;\r\n  const cancelPromise = new Promise(resolve => {\r\n    resolveCancelPromise = resolve;\r\n  });\r\n\r\n  function pullAlgorithm() {\r\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\r\n      assert(typeIsObject(result));\r\n      const value = result.value;\r\n      const done = result.done;\r\n      assert(typeof done === 'boolean');\r\n\r\n      if (done === true && closedOrErrored === false) {\r\n        if (canceled1 === false) {\r\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\r\n        }\r\n        if (canceled2 === false) {\r\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\r\n        }\r\n        closedOrErrored = true;\r\n      }\r\n\r\n      if (closedOrErrored === true) {\r\n        return;\r\n      }\r\n\r\n      const value1 = value;\r\n      const value2 = value;\r\n\r\n      // There is no way to access the cloning code right now in the reference implementation.\r\n      // If we add one then we'll need an implementation for serializable objects.\r\n      // if (canceled2 === false && cloneForBranch2 === true) {\r\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\r\n      // }\r\n\r\n      if (canceled1 === false) {\r\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\r\n      }\r\n\r\n      if (canceled2 === false) {\r\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\r\n      }\r\n    });\r\n  }\r\n\r\n  function cancel1Algorithm(reason) {\r\n    canceled1 = true;\r\n    reason1 = reason;\r\n    if (canceled2 === true) {\r\n      const compositeReason = createArrayFromList([reason1, reason2]);\r\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n      resolveCancelPromise(cancelResult);\r\n    }\r\n    return cancelPromise;\r\n  }\r\n\r\n  function cancel2Algorithm(reason) {\r\n    canceled2 = true;\r\n    reason2 = reason;\r\n    if (canceled1 === true) {\r\n      const compositeReason = createArrayFromList([reason1, reason2]);\r\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n      resolveCancelPromise(cancelResult);\r\n    }\r\n    return cancelPromise;\r\n  }\r\n\r\n  function startAlgorithm() {}\r\n\r\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\r\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\r\n\r\n  reader._closedPromise.catch(r => {\r\n    if (closedOrErrored === true) {\r\n      return;\r\n    }\r\n\r\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\r\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\r\n    closedOrErrored = true;\r\n  });\r\n\r\n  return [branch1, branch2];\r\n}\r\n\r\n// ReadableStream API exposed for controllers.\r\n\r\nfunction ReadableStreamAddReadIntoRequest(stream) {\r\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\r\n  assert(stream._state === 'readable' || stream._state === 'closed');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const readIntoRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._reader._readIntoRequests.push(readIntoRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableStreamAddReadRequest(stream) {\r\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\r\n  assert(stream._state === 'readable');\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    const readRequest = {\r\n      _resolve: resolve,\r\n      _reject: reject\r\n    };\r\n\r\n    stream._reader._readRequests.push(readRequest);\r\n  });\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableStreamCancel(stream, reason) {\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'closed') {\r\n    return Promise.resolve(undefined);\r\n  }\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  ReadableStreamClose(stream);\r\n\r\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\r\n  return sourceCancelPromise.then(() => undefined);\r\n}\r\n\r\nfunction ReadableStreamClose(stream) {\r\n  assert(stream._state === 'readable');\r\n\r\n  stream._state = 'closed';\r\n\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === true) {\r\n    for (const { _resolve } of reader._readRequests) {\r\n      _resolve(CreateIterResultObject(undefined, true));\r\n    }\r\n    reader._readRequests = [];\r\n  }\r\n\r\n  defaultReaderClosedPromiseResolve(reader);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamError(stream, e) {\r\n  assert(IsReadableStream(stream) === true);\r\n  assert(stream._state === 'readable');\r\n\r\n  stream._state = 'errored';\r\n  stream._storedError = e;\r\n\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === true) {\r\n    for (const readRequest of reader._readRequests) {\r\n      readRequest._reject(e);\r\n    }\r\n\r\n    reader._readRequests = [];\r\n  } else {\r\n    assert(IsReadableStreamBYOBReader(reader));\r\n\r\n    for (const readIntoRequest of reader._readIntoRequests) {\r\n      readIntoRequest._reject(e);\r\n    }\r\n\r\n    reader._readIntoRequests = [];\r\n  }\r\n\r\n  defaultReaderClosedPromiseReject(reader, e);\r\n  reader._closedPromise.catch(() => {});\r\n}\r\n\r\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\r\n  const reader = stream._reader;\r\n\r\n  assert(reader._readIntoRequests.length > 0);\r\n\r\n  const readIntoRequest = reader._readIntoRequests.shift();\r\n  readIntoRequest._resolve(CreateIterResultObject(chunk, done));\r\n}\r\n\r\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\r\n  const reader = stream._reader;\r\n\r\n  assert(reader._readRequests.length > 0);\r\n\r\n  const readRequest = reader._readRequests.shift();\r\n  readRequest._resolve(CreateIterResultObject(chunk, done));\r\n}\r\n\r\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\r\n  return stream._reader._readIntoRequests.length;\r\n}\r\n\r\nfunction ReadableStreamGetNumReadRequests(stream) {\r\n  return stream._reader._readRequests.length;\r\n}\r\n\r\nfunction ReadableStreamHasBYOBReader(stream) {\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamBYOBReader(reader) === false) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamHasDefaultReader(stream) {\r\n  const reader = stream._reader;\r\n\r\n  if (reader === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamDefaultReader(reader) === false) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// Readers\r\n\r\nclass ReadableStreamDefaultReader {\r\n  constructor(stream) {\r\n    if (IsReadableStream(stream) === false) {\r\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\r\n    }\r\n    if (IsReadableStreamLocked(stream) === true) {\r\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n    }\r\n\r\n    ReadableStreamReaderGenericInitialize(this, stream);\r\n\r\n    this._readRequests = [];\r\n  }\r\n\r\n  get closed() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('cancel'));\r\n    }\r\n\r\n    return ReadableStreamReaderGenericCancel(this, reason);\r\n  }\r\n\r\n  read() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      return Promise.reject(defaultReaderBrandCheckException('read'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('read from'));\r\n    }\r\n\r\n    return ReadableStreamDefaultReaderRead(this);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (IsReadableStreamDefaultReader(this) === false) {\r\n      throw defaultReaderBrandCheckException('releaseLock');\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (this._readRequests.length > 0) {\r\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\r\n    }\r\n\r\n    ReadableStreamReaderGenericRelease(this);\r\n  }\r\n}\r\n\r\nclass ReadableStreamBYOBReader {\r\n  constructor(stream) {\r\n    if (!IsReadableStream(stream)) {\r\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\r\n          'byte source');\r\n    }\r\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\r\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\r\n          'source');\r\n    }\r\n    if (IsReadableStreamLocked(stream)) {\r\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n    }\r\n\r\n    ReadableStreamReaderGenericInitialize(this, stream);\r\n\r\n    this._readIntoRequests = [];\r\n  }\r\n\r\n  get closed() {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('closed'));\r\n    }\r\n\r\n    return this._closedPromise;\r\n  }\r\n\r\n  cancel(reason) {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('cancel'));\r\n    }\r\n\r\n    return ReadableStreamReaderGenericCancel(this, reason);\r\n  }\r\n\r\n  read(view) {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      return Promise.reject(byobReaderBrandCheckException('read'));\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return Promise.reject(readerLockException('read from'));\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(view)) {\r\n      return Promise.reject(new TypeError('view must be an array buffer view'));\r\n    }\r\n\r\n    if (IsDetachedBuffer(view.buffer) === true) {\r\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\r\n    }\r\n\r\n    if (view.byteLength === 0) {\r\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\r\n    }\r\n\r\n    return ReadableStreamBYOBReaderRead(this, view);\r\n  }\r\n\r\n  releaseLock() {\r\n    if (!IsReadableStreamBYOBReader(this)) {\r\n      throw byobReaderBrandCheckException('releaseLock');\r\n    }\r\n\r\n    if (this._ownerReadableStream === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (this._readIntoRequests.length > 0) {\r\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\r\n    }\r\n\r\n    ReadableStreamReaderGenericRelease(this);\r\n  }\r\n}\r\n\r\n// Abstract operations for the readers.\r\n\r\nfunction IsReadableStreamBYOBReader(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamDefaultReader(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\r\n  reader._ownerReadableStream = stream;\r\n  stream._reader = reader;\r\n\r\n  if (stream._state === 'readable') {\r\n    defaultReaderClosedPromiseInitialize(reader);\r\n  } else if (stream._state === 'closed') {\r\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\r\n  } else {\r\n    assert(stream._state === 'errored');\r\n\r\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\r\n    reader._closedPromise.catch(() => {});\r\n  }\r\n}\r\n\r\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\r\n// check.\r\n\r\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\r\n  const stream = reader._ownerReadableStream;\r\n  assert(stream !== undefined);\r\n  return ReadableStreamCancel(stream, reason);\r\n}\r\n\r\nfunction ReadableStreamReaderGenericRelease(reader) {\r\n  assert(reader._ownerReadableStream !== undefined);\r\n  assert(reader._ownerReadableStream._reader === reader);\r\n\r\n  if (reader._ownerReadableStream._state === 'readable') {\r\n    defaultReaderClosedPromiseReject(\r\n        reader,\r\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\r\n  } else {\r\n    defaultReaderClosedPromiseResetToRejected(\r\n        reader,\r\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\r\n  }\r\n  reader._closedPromise.catch(() => {});\r\n\r\n  reader._ownerReadableStream._reader = undefined;\r\n  reader._ownerReadableStream = undefined;\r\n}\r\n\r\nfunction ReadableStreamBYOBReaderRead(reader, view) {\r\n  const stream = reader._ownerReadableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  // Controllers must implement this.\r\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\r\n}\r\n\r\nfunction ReadableStreamDefaultReaderRead(reader) {\r\n  const stream = reader._ownerReadableStream;\r\n\r\n  assert(stream !== undefined);\r\n\r\n  stream._disturbed = true;\r\n\r\n  if (stream._state === 'closed') {\r\n    return Promise.resolve(CreateIterResultObject(undefined, true));\r\n  }\r\n\r\n  if (stream._state === 'errored') {\r\n    return Promise.reject(stream._storedError);\r\n  }\r\n\r\n  assert(stream._state === 'readable');\r\n\r\n  return stream._readableStreamController[PullSteps]();\r\n}\r\n\r\n// Controllers\r\n\r\nclass ReadableStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError();\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\r\n  }\r\n\r\n  close() {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('close');\r\n    }\r\n\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\r\n      throw new TypeError('The stream is not in a state that permits close');\r\n    }\r\n\r\n    ReadableStreamDefaultControllerClose(this);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\r\n      throw new TypeError('The stream is not in a state that permits enqueue');\r\n    }\r\n\r\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(e) {\r\n    if (IsReadableStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('error');\r\n    }\r\n\r\n    ReadableStreamDefaultControllerError(this, e);\r\n  }\r\n\r\n  [CancelSteps](reason) {\r\n    ResetQueue(this);\r\n    return this._cancelAlgorithm(reason);\r\n  }\r\n\r\n  [PullSteps]() {\r\n    const stream = this._controlledReadableStream;\r\n\r\n    if (this._queue.length > 0) {\r\n      const chunk = DequeueValue(this);\r\n\r\n      if (this._closeRequested === true && this._queue.length === 0) {\r\n        ReadableStreamClose(stream);\r\n      } else {\r\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n      }\r\n\r\n      return Promise.resolve(CreateIterResultObject(chunk, false));\r\n    }\r\n\r\n    const pendingPromise = ReadableStreamAddReadRequest(stream);\r\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n    return pendingPromise;\r\n  }\r\n}\r\n\r\n// Abstract operations for the ReadableStreamDefaultController.\r\n\r\nfunction IsReadableStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\r\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\r\n  if (shouldPull === false) {\r\n    return undefined;\r\n  }\r\n\r\n  if (controller._pulling === true) {\r\n    controller._pullAgain = true;\r\n    return undefined;\r\n  }\r\n\r\n  assert(controller._pullAgain === false);\r\n\r\n  controller._pulling = true;\r\n\r\n  const pullPromise = controller._pullAlgorithm();\r\n  pullPromise.then(\r\n    () => {\r\n      controller._pulling = false;\r\n\r\n      if (controller._pullAgain === true) {\r\n        controller._pullAgain = false;\r\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n      }\r\n      return undefined;\r\n    },\r\n    e => {\r\n      ReadableStreamDefaultControllerError(controller, e);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\r\n    return false;\r\n  }\r\n\r\n  if (controller._started === false) {\r\n    return false;\r\n  }\r\n\r\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\r\n  if (desiredSize > 0) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\r\n\r\nfunction ReadableStreamDefaultControllerClose(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\r\n\r\n  controller._closeRequested = true;\r\n\r\n  if (controller._queue.length === 0) {\r\n    ReadableStreamClose(stream);\r\n  }\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\r\n\r\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\r\n  } else {\r\n    let chunkSize;\r\n    try {\r\n      chunkSize = controller._strategySizeAlgorithm(chunk);\r\n    } catch (chunkSizeE) {\r\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\r\n      throw chunkSizeE;\r\n    }\r\n\r\n    try {\r\n      EnqueueValueWithSize(controller, chunk, chunkSize);\r\n    } catch (enqueueE) {\r\n      ReadableStreamDefaultControllerError(controller, enqueueE);\r\n      throw enqueueE;\r\n    }\r\n  }\r\n\r\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerError(controller, e) {\r\n  const stream = controller._controlledReadableStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return;\r\n  }\r\n\r\n  ResetQueue(controller);\r\n\r\n  ReadableStreamError(stream, e);\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\r\n  const stream = controller._controlledReadableStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored') {\r\n    return null;\r\n  }\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\n// This is used in the implementation of TransformStream.\r\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\r\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\r\n  const state = controller._controlledReadableStream._state;\r\n\r\n  if (controller._closeRequested === false && state === 'readable') {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction SetUpReadableStreamDefaultController(\r\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\r\n  assert(stream._readableStreamController === undefined);\r\n\r\n  controller._controlledReadableStream = stream;\r\n\r\n  controller._queue = undefined;\r\n  controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._started = false;\r\n  controller._closeRequested = false;\r\n  controller._pullAgain = false;\r\n  controller._pulling = false;\r\n\r\n  controller._strategySizeAlgorithm = sizeAlgorithm;\r\n  controller._strategyHWM = highWaterMark;\r\n\r\n  controller._pullAlgorithm = pullAlgorithm;\r\n  controller._cancelAlgorithm = cancelAlgorithm;\r\n\r\n  stream._readableStreamController = controller;\r\n\r\n  const startResult = startAlgorithm();\r\n  Promise.resolve(startResult).then(\r\n    () => {\r\n      controller._started = true;\r\n\r\n      assert(controller._pulling === false);\r\n      assert(controller._pullAgain === false);\r\n\r\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n    },\r\n    r => {\r\n      ReadableStreamDefaultControllerError(controller, r);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\r\n                                                                  sizeAlgorithm) {\r\n  assert(underlyingSource !== undefined);\r\n\r\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\r\n  }\r\n\r\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\r\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\r\n\r\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\r\n                                       highWaterMark, sizeAlgorithm);\r\n}\r\n\r\nclass ReadableStreamBYOBRequest {\r\n  constructor() {\r\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\r\n  }\r\n\r\n  get view() {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('view');\r\n    }\r\n\r\n    return this._view;\r\n  }\r\n\r\n  respond(bytesWritten) {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('respond');\r\n    }\r\n\r\n    if (this._associatedReadableByteStreamController === undefined) {\r\n      throw new TypeError('This BYOB request has been invalidated');\r\n    }\r\n\r\n    if (IsDetachedBuffer(this._view.buffer) === true) {\r\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\r\n  }\r\n\r\n  respondWithNewView(view) {\r\n    if (IsReadableStreamBYOBRequest(this) === false) {\r\n      throw byobRequestBrandCheckException('respond');\r\n    }\r\n\r\n    if (this._associatedReadableByteStreamController === undefined) {\r\n      throw new TypeError('This BYOB request has been invalidated');\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(view)) {\r\n      throw new TypeError('You can only respond with array buffer views');\r\n    }\r\n\r\n    if (IsDetachedBuffer(view.buffer) === true) {\r\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\r\n  }\r\n}\r\n\r\nclass ReadableByteStreamController {\r\n  constructor() {\r\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\r\n  }\r\n\r\n  get byobRequest() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('byobRequest');\r\n    }\r\n\r\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\r\n      const firstDescriptor = this._pendingPullIntos[0];\r\n      const view = new Uint8Array(firstDescriptor.buffer,\r\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\r\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\r\n\r\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\r\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\r\n      this._byobRequest = byobRequest;\r\n    }\r\n\r\n    return this._byobRequest;\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    return ReadableByteStreamControllerGetDesiredSize(this);\r\n  }\r\n\r\n  close() {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('close');\r\n    }\r\n\r\n    if (this._closeRequested === true) {\r\n      throw new TypeError('The stream has already been closed; do not close it again!');\r\n    }\r\n\r\n    const state = this._controlledReadableByteStream._state;\r\n    if (state !== 'readable') {\r\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\r\n    }\r\n\r\n    ReadableByteStreamControllerClose(this);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    if (this._closeRequested === true) {\r\n      throw new TypeError('stream is closed or draining');\r\n    }\r\n\r\n    const state = this._controlledReadableByteStream._state;\r\n    if (state !== 'readable') {\r\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\r\n    }\r\n\r\n    if (!ArrayBuffer.isView(chunk)) {\r\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\r\n    }\r\n\r\n    if (IsDetachedBuffer(chunk.buffer) === true) {\r\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\r\n    }\r\n\r\n    ReadableByteStreamControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(e) {\r\n    if (IsReadableByteStreamController(this) === false) {\r\n      throw byteStreamControllerBrandCheckException('error');\r\n    }\r\n\r\n    ReadableByteStreamControllerError(this, e);\r\n  }\r\n\r\n  [CancelSteps](reason) {\r\n    if (this._pendingPullIntos.length > 0) {\r\n      const firstDescriptor = this._pendingPullIntos[0];\r\n      firstDescriptor.bytesFilled = 0;\r\n    }\r\n\r\n    ResetQueue(this);\r\n\r\n    return this._cancelAlgorithm(reason);\r\n  }\r\n\r\n  [PullSteps]() {\r\n    const stream = this._controlledReadableByteStream;\r\n    assert(ReadableStreamHasDefaultReader(stream) === true);\r\n\r\n    if (this._queueTotalSize > 0) {\r\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\r\n\r\n      const entry = this._queue.shift();\r\n      this._queueTotalSize -= entry.byteLength;\r\n\r\n      ReadableByteStreamControllerHandleQueueDrain(this);\r\n\r\n      let view;\r\n      try {\r\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\r\n      } catch (viewE) {\r\n        return Promise.reject(viewE);\r\n      }\r\n\r\n      return Promise.resolve(CreateIterResultObject(view, false));\r\n    }\r\n\r\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\r\n    if (autoAllocateChunkSize !== undefined) {\r\n      let buffer;\r\n      try {\r\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\r\n      } catch (bufferE) {\r\n        return Promise.reject(bufferE);\r\n      }\r\n\r\n      const pullIntoDescriptor = {\r\n        buffer,\r\n        byteOffset: 0,\r\n        byteLength: autoAllocateChunkSize,\r\n        bytesFilled: 0,\r\n        elementSize: 1,\r\n        ctor: Uint8Array,\r\n        readerType: 'default'\r\n      };\r\n\r\n      this._pendingPullIntos.push(pullIntoDescriptor);\r\n    }\r\n\r\n    const promise = ReadableStreamAddReadRequest(stream);\r\n\r\n    ReadableByteStreamControllerCallPullIfNeeded(this);\r\n\r\n    return promise;\r\n  }\r\n}\r\n\r\n// Abstract operations for the ReadableByteStreamController.\r\n\r\nfunction IsReadableByteStreamController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction IsReadableStreamBYOBRequest(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\r\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\r\n  if (shouldPull === false) {\r\n    return undefined;\r\n  }\r\n\r\n  if (controller._pulling === true) {\r\n    controller._pullAgain = true;\r\n    return undefined;\r\n  }\r\n\r\n  assert(controller._pullAgain === false);\r\n\r\n  controller._pulling = true;\r\n\r\n  // TODO: Test controller argument\r\n  const pullPromise = controller._pullAlgorithm();\r\n  pullPromise.then(\r\n    () => {\r\n      controller._pulling = false;\r\n\r\n      if (controller._pullAgain === true) {\r\n        controller._pullAgain = false;\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n      }\r\n    },\r\n    e => {\r\n      ReadableByteStreamControllerError(controller, e);\r\n    }\r\n  )\r\n  .catch(rethrowAssertionErrorRejection);\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  controller._pendingPullIntos = [];\r\n}\r\n\r\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\r\n  assert(stream._state !== 'errored');\r\n\r\n  let done = false;\r\n  if (stream._state === 'closed') {\r\n    assert(pullIntoDescriptor.bytesFilled === 0);\r\n    done = true;\r\n  }\r\n\r\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n  if (pullIntoDescriptor.readerType === 'default') {\r\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\r\n  } else {\r\n    assert(pullIntoDescriptor.readerType === 'byob');\r\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\r\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\r\n  const elementSize = pullIntoDescriptor.elementSize;\r\n\r\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\r\n  assert(bytesFilled % elementSize === 0);\r\n\r\n  return new pullIntoDescriptor.ctor(\r\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\r\n}\r\n\r\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\r\n  controller._queue.push({ buffer, byteOffset, byteLength });\r\n  controller._queueTotalSize += byteLength;\r\n}\r\n\r\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\r\n  const elementSize = pullIntoDescriptor.elementSize;\r\n\r\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\r\n\r\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\r\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\r\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\r\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\r\n\r\n  let totalBytesToCopyRemaining = maxBytesToCopy;\r\n  let ready = false;\r\n  if (maxAlignedBytes > currentAlignedBytes) {\r\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\r\n    ready = true;\r\n  }\r\n\r\n  const queue = controller._queue;\r\n\r\n  while (totalBytesToCopyRemaining > 0) {\r\n    const headOfQueue = queue[0];\r\n\r\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\r\n\r\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\r\n\r\n    if (headOfQueue.byteLength === bytesToCopy) {\r\n      queue.shift();\r\n    } else {\r\n      headOfQueue.byteOffset += bytesToCopy;\r\n      headOfQueue.byteLength -= bytesToCopy;\r\n    }\r\n    controller._queueTotalSize -= bytesToCopy;\r\n\r\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\r\n\r\n    totalBytesToCopyRemaining -= bytesToCopy;\r\n  }\r\n\r\n  if (ready === false) {\r\n    assert(controller._queueTotalSize === 0);\r\n    assert(pullIntoDescriptor.bytesFilled > 0);\r\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\r\n  }\r\n\r\n  return ready;\r\n}\r\n\r\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\r\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\r\n\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  pullIntoDescriptor.bytesFilled += size;\r\n}\r\n\r\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\r\n  assert(controller._controlledReadableByteStream._state === 'readable');\r\n\r\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\r\n    ReadableStreamClose(controller._controlledReadableByteStream);\r\n  } else {\r\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\r\n  if (controller._byobRequest === undefined) {\r\n    return;\r\n  }\r\n\r\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\r\n  controller._byobRequest._view = undefined;\r\n  controller._byobRequest = undefined;\r\n}\r\n\r\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\r\n  assert(controller._closeRequested === false);\r\n\r\n  while (controller._pendingPullIntos.length > 0) {\r\n    if (controller._queueTotalSize === 0) {\r\n      return;\r\n    }\r\n\r\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\r\n\r\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\r\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n\r\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\r\n        controller._controlledReadableByteStream,\r\n        pullIntoDescriptor\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerPullInto(controller, view) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  let elementSize = 1;\r\n  if (view.constructor !== DataView) {\r\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\r\n  }\r\n\r\n  const ctor = view.constructor;\r\n\r\n  const buffer = TransferArrayBuffer(view.buffer);\r\n  const pullIntoDescriptor = {\r\n    buffer,\r\n    byteOffset: view.byteOffset,\r\n    byteLength: view.byteLength,\r\n    bytesFilled: 0,\r\n    elementSize,\r\n    ctor,\r\n    readerType: 'byob'\r\n  };\r\n\r\n  if (controller._pendingPullIntos.length > 0) {\r\n    controller._pendingPullIntos.push(pullIntoDescriptor);\r\n\r\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\r\n    // - No change happens on desiredSize\r\n    // - The source has already been notified of that there's at least 1 pending read(view)\r\n\r\n    return ReadableStreamAddReadIntoRequest(stream);\r\n  }\r\n\r\n  if (stream._state === 'closed') {\r\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\r\n    return Promise.resolve(CreateIterResultObject(emptyView, true));\r\n  }\r\n\r\n  if (controller._queueTotalSize > 0) {\r\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\r\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n\r\n      ReadableByteStreamControllerHandleQueueDrain(controller);\r\n\r\n      return Promise.resolve(CreateIterResultObject(filledView, false));\r\n    }\r\n\r\n    if (controller._closeRequested === true) {\r\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n      ReadableByteStreamControllerError(controller, e);\r\n\r\n      return Promise.reject(e);\r\n    }\r\n  }\r\n\r\n  controller._pendingPullIntos.push(pullIntoDescriptor);\r\n\r\n  const promise = ReadableStreamAddReadIntoRequest(stream);\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n\r\n  return promise;\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\r\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\r\n\r\n  assert(firstDescriptor.bytesFilled === 0);\r\n\r\n  const stream = controller._controlledReadableByteStream;\r\n  if (ReadableStreamHasBYOBReader(stream) === true) {\r\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\r\n    }\r\n  }\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\r\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\r\n    throw new RangeError('bytesWritten out of range');\r\n  }\r\n\r\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\r\n\r\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\r\n    // TODO: Figure out whether we should detach the buffer or not here.\r\n    return;\r\n  }\r\n\r\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n\r\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\r\n  if (remainderSize > 0) {\r\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\r\n  }\r\n\r\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\r\n  pullIntoDescriptor.bytesFilled -= remainderSize;\r\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\r\n\r\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\r\n  const firstDescriptor = controller._pendingPullIntos[0];\r\n\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state === 'closed') {\r\n    if (bytesWritten !== 0) {\r\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\r\n    }\r\n\r\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\r\n  } else {\r\n    assert(stream._state === 'readable');\r\n\r\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\r\n  }\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\r\n  const descriptor = controller._pendingPullIntos.shift();\r\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n  return descriptor;\r\n}\r\n\r\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return false;\r\n  }\r\n\r\n  if (controller._closeRequested === true) {\r\n    return false;\r\n  }\r\n\r\n  if (controller._started === false) {\r\n    return false;\r\n  }\r\n\r\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n    return true;\r\n  }\r\n\r\n  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\r\n\r\nfunction ReadableByteStreamControllerClose(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  assert(controller._closeRequested === false);\r\n  assert(stream._state === 'readable');\r\n\r\n  if (controller._queueTotalSize > 0) {\r\n    controller._closeRequested = true;\r\n\r\n    return;\r\n  }\r\n\r\n  if (controller._pendingPullIntos.length > 0) {\r\n    const firstPendingPullInto = controller._pendingPullIntos[0];\r\n    if (firstPendingPullInto.bytesFilled > 0) {\r\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n      ReadableByteStreamControllerError(controller, e);\r\n\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  ReadableStreamClose(stream);\r\n}\r\n\r\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  assert(controller._closeRequested === false);\r\n  assert(stream._state === 'readable');\r\n\r\n  const buffer = chunk.buffer;\r\n  const byteOffset = chunk.byteOffset;\r\n  const byteLength = chunk.byteLength;\r\n  const transferredBuffer = TransferArrayBuffer(buffer);\r\n\r\n  if (ReadableStreamHasDefaultReader(stream) === true) {\r\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\r\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n    } else {\r\n      assert(controller._queue.length === 0);\r\n\r\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\r\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\r\n    }\r\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\r\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n  } else {\r\n    assert(IsReadableStreamLocked(stream) === false);\r\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n  }\r\n\r\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n}\r\n\r\nfunction ReadableByteStreamControllerError(controller, e) {\r\n  const stream = controller._controlledReadableByteStream;\r\n\r\n  if (stream._state !== 'readable') {\r\n    return;\r\n  }\r\n\r\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\r\n\r\n  ResetQueue(controller);\r\n  ReadableStreamError(stream, e);\r\n}\r\n\r\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\r\n  const stream = controller._controlledReadableByteStream;\r\n  const state = stream._state;\r\n\r\n  if (state === 'errored') {\r\n    return null;\r\n  }\r\n  if (state === 'closed') {\r\n    return 0;\r\n  }\r\n\r\n  return controller._strategyHWM - controller._queueTotalSize;\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\r\n  bytesWritten = Number(bytesWritten);\r\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\r\n    throw new RangeError('bytesWritten must be a finite');\r\n  }\r\n\r\n  assert(controller._pendingPullIntos.length > 0);\r\n\r\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\r\n}\r\n\r\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\r\n  assert(controller._pendingPullIntos.length > 0);\r\n\r\n  const firstDescriptor = controller._pendingPullIntos[0];\r\n\r\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\r\n    throw new RangeError('The region specified by view does not match byobRequest');\r\n  }\r\n  if (firstDescriptor.byteLength !== view.byteLength) {\r\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\r\n  }\r\n\r\n  firstDescriptor.buffer = view.buffer;\r\n\r\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\r\n}\r\n\r\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\r\n                                           highWaterMark, autoAllocateChunkSize) {\r\n  assert(stream._readableStreamController === undefined);\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\r\n    assert(autoAllocateChunkSize > 0);\r\n  }\r\n\r\n  controller._controlledReadableByteStream = stream;\r\n\r\n  controller._pullAgain = false;\r\n  controller._pulling = false;\r\n\r\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\r\n\r\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\r\n  controller._queue = controller._queueTotalSize = undefined;\r\n  ResetQueue(controller);\r\n\r\n  controller._closeRequested = false;\r\n  controller._started = false;\r\n\r\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n\r\n  controller._pullAlgorithm = pullAlgorithm;\r\n  controller._cancelAlgorithm = cancelAlgorithm;\r\n\r\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\r\n\r\n  controller._pendingPullIntos = [];\r\n\r\n  stream._readableStreamController = controller;\r\n\r\n  const startResult = startAlgorithm();\r\n  Promise.resolve(startResult).then(\r\n      () => {\r\n        controller._started = true;\r\n\r\n        assert(controller._pulling === false);\r\n        assert(controller._pullAgain === false);\r\n\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n      },\r\n      r => {\r\n        ReadableByteStreamControllerError(controller, r);\r\n      }\r\n  )\r\n      .catch(rethrowAssertionErrorRejection);\r\n}\r\n\r\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\r\n  assert(underlyingByteSource !== undefined);\r\n\r\n  const controller = Object.create(ReadableByteStreamController.prototype);\r\n\r\n  function startAlgorithm() {\r\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\r\n  }\r\n\r\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\r\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\r\n\r\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\r\n  if (autoAllocateChunkSize !== undefined) {\r\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\r\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\r\n    }\r\n  }\r\n\r\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\r\n                                    autoAllocateChunkSize);\r\n}\r\n\r\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\r\n  assert(IsReadableByteStreamController(controller) === true);\r\n  assert(typeof view === 'object');\r\n  assert(ArrayBuffer.isView(view) === true);\r\n  assert(IsDetachedBuffer(view.buffer) === false);\r\n  request._associatedReadableByteStreamController = controller;\r\n  request._view = view;\r\n}\r\n\r\n// Helper functions for the ReadableStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\r\n}\r\n\r\n// Helper functions for the readers.\r\n\r\nfunction readerLockException(name) {\r\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultReader.\r\n\r\nfunction defaultReaderBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitialize(reader) {\r\n  reader._closedPromise = new Promise((resolve, reject) => {\r\n    reader._closedPromise_resolve = resolve;\r\n    reader._closedPromise_reject = reject;\r\n  });\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\r\n  reader._closedPromise = Promise.reject(reason);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\r\n  reader._closedPromise = Promise.resolve(undefined);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseReject(reader, reason) {\r\n  assert(reader._closedPromise_resolve !== undefined);\r\n  assert(reader._closedPromise_reject !== undefined);\r\n\r\n  reader._closedPromise_reject(reason);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\r\n  assert(reader._closedPromise_resolve === undefined);\r\n  assert(reader._closedPromise_reject === undefined);\r\n\r\n  reader._closedPromise = Promise.reject(reason);\r\n}\r\n\r\nfunction defaultReaderClosedPromiseResolve(reader) {\r\n  assert(reader._closedPromise_resolve !== undefined);\r\n  assert(reader._closedPromise_reject !== undefined);\r\n\r\n  reader._closedPromise_resolve(undefined);\r\n  reader._closedPromise_resolve = undefined;\r\n  reader._closedPromise_reject = undefined;\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultReader.\r\n\r\nfunction byobReaderBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\r\n}\r\n\r\n// Helper functions for the ReadableStreamDefaultController.\r\n\r\nfunction defaultControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\r\n}\r\n\r\n// Helper functions for the ReadableStreamBYOBRequest.\r\n\r\nfunction byobRequestBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\r\n}\r\n\r\n// Helper functions for the ReadableByteStreamController.\r\n\r\nfunction byteStreamControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\r\n}\r\n\r\n// Helper function for ReadableStream pipeThrough\r\n\r\nfunction ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\r\n  try {\r\n    // This relies on the brand-check that is enforced by Promise.prototype.then(). As with the rest of the reference\r\n    // implementation, it doesn't attempt to do the right thing if someone has modified the global environment.\r\n    Promise.prototype.then.call(promise, undefined, () => {});\r\n  } catch (e) {\r\n    // The brand check failed, therefore the internal slot is not present and there's nothing further to do.\r\n  }\r\n}\r\n","'use strict';\r\nconst { createDataProperty } = require('./helpers.js');\r\n\r\nmodule.exports = class ByteLengthQueuingStrategy {\r\n  constructor({ highWaterMark }) {\r\n    createDataProperty(this, 'highWaterMark', highWaterMark);\r\n  }\r\n\r\n  size(chunk) {\r\n    return chunk.byteLength;\r\n  }\r\n};\r\n","'use strict';\r\nconst { createDataProperty } = require('./helpers.js');\r\n\r\nmodule.exports = class CountQueuingStrategy {\r\n  constructor({ highWaterMark }) {\r\n    createDataProperty(this, 'highWaterMark', highWaterMark);\r\n  }\r\n\r\n  size() {\r\n    return 1;\r\n  }\r\n};\r\n","'use strict';\r\nconst assert = require('better-assert');\r\n\r\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\r\n// and do not appear in the standard text.\r\nconst verbose = require('debug')('streams:transform-stream:verbose');\r\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\r\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\r\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\r\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\r\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\r\n        ReadableStreamDefaultControllerHasBackpressure,\r\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\r\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\r\n\r\n// Class TransformStream\r\n\r\nclass TransformStream {\r\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\r\n    const readableType = transformer.readableType;\r\n\r\n    if (readableType !== undefined) {\r\n      throw new RangeError('Invalid readable type specified');\r\n    }\r\n\r\n    const writableType = transformer.writableType;\r\n\r\n    if (writableType !== undefined) {\r\n      throw new RangeError('Invalid writable type specified');\r\n    }\r\n\r\n    const writableSizeFunction = writableStrategy.size;\r\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\r\n    let writableHighWaterMark = writableStrategy.highWaterMark;\r\n    if (writableHighWaterMark === undefined) {\r\n      writableHighWaterMark = 1;\r\n    }\r\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\r\n\r\n    const readableSizeFunction = readableStrategy.size;\r\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\r\n    let readableHighWaterMark = readableStrategy.highWaterMark;\r\n    if (readableHighWaterMark === undefined) {\r\n      readableHighWaterMark = 0;\r\n    }\r\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\r\n\r\n    let startPromise_resolve;\r\n    const startPromise = new Promise(resolve => {\r\n      startPromise_resolve = resolve;\r\n    });\r\n\r\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\r\n                              readableSizeAlgorithm);\r\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\r\n\r\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\r\n    startPromise_resolve(startResult);\r\n  }\r\n\r\n  get readable() {\r\n    if (IsTransformStream(this) === false) {\r\n      throw streamBrandCheckException('readable');\r\n    }\r\n\r\n    return this._readable;\r\n  }\r\n\r\n  get writable() {\r\n    if (IsTransformStream(this) === false) {\r\n      throw streamBrandCheckException('writable');\r\n    }\r\n\r\n    return this._writable;\r\n  }\r\n}\r\n\r\n// Transform Stream Abstract Operations\r\n\r\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\r\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\r\n                               readableSizeAlgorithm = () => 1) {\r\n  assert(IsNonNegativeNumber(writableHighWaterMark));\r\n  assert(IsNonNegativeNumber(readableHighWaterMark));\r\n\r\n  const stream = Object.create(TransformStream.prototype);\r\n\r\n  let startPromise_resolve;\r\n  const startPromise = new Promise(resolve => {\r\n    startPromise_resolve = resolve;\r\n  });\r\n\r\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\r\n                            readableSizeAlgorithm);\r\n\r\n  const controller = Object.create(TransformStreamDefaultController.prototype);\r\n\r\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\r\n\r\n  const startResult = startAlgorithm();\r\n  startPromise_resolve(startResult);\r\n  return stream;\r\n}\r\n\r\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\r\n                                   readableHighWaterMark, readableSizeAlgorithm) {\r\n  function startAlgorithm() {\r\n    return startPromise;\r\n  }\r\n\r\n  function writeAlgorithm(chunk) {\r\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\r\n  }\r\n\r\n  function abortAlgorithm(reason) {\r\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\r\n  }\r\n\r\n  function closeAlgorithm() {\r\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\r\n  }\r\n\r\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\r\n                                          writableHighWaterMark, writableSizeAlgorithm);\r\n\r\n  function pullAlgorithm() {\r\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\r\n  }\r\n\r\n  function cancelAlgorithm(reason) {\r\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\r\n    return Promise.resolve();\r\n  }\r\n\r\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\r\n                                          readableSizeAlgorithm);\r\n\r\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\r\n  stream._backpressure = undefined;\r\n  stream._backpressureChangePromise = undefined;\r\n  stream._backpressureChangePromise_resolve = undefined;\r\n  TransformStreamSetBackpressure(stream, true);\r\n\r\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\r\n  stream._transformStreamController = undefined;\r\n}\r\n\r\nfunction IsTransformStream(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n// This is a no-op if both sides are already errored.\r\nfunction TransformStreamError(stream, e) {\r\n  verbose('TransformStreamError()');\r\n\r\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\r\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\r\n}\r\n\r\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\r\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\r\n  if (stream._backpressure === true) {\r\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\r\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\r\n    // _backpressure is set.\r\n    TransformStreamSetBackpressure(stream, false);\r\n  }\r\n}\r\n\r\nfunction TransformStreamSetBackpressure(stream, backpressure) {\r\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\r\n\r\n  // Passes also when called during construction.\r\n  assert(stream._backpressure !== backpressure);\r\n\r\n  if (stream._backpressureChangePromise !== undefined) {\r\n    stream._backpressureChangePromise_resolve();\r\n  }\r\n\r\n  stream._backpressureChangePromise = new Promise(resolve => {\r\n    stream._backpressureChangePromise_resolve = resolve;\r\n  });\r\n\r\n  stream._backpressure = backpressure;\r\n}\r\n\r\n// Class TransformStreamDefaultController\r\n\r\nclass TransformStreamDefaultController {\r\n  constructor() {\r\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\r\n  }\r\n\r\n  get desiredSize() {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('desiredSize');\r\n    }\r\n\r\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\r\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\r\n  }\r\n\r\n  enqueue(chunk) {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('enqueue');\r\n    }\r\n\r\n    TransformStreamDefaultControllerEnqueue(this, chunk);\r\n  }\r\n\r\n  error(reason) {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('error');\r\n    }\r\n\r\n    TransformStreamDefaultControllerError(this, reason);\r\n  }\r\n\r\n  terminate() {\r\n    if (IsTransformStreamDefaultController(this) === false) {\r\n      throw defaultControllerBrandCheckException('terminate');\r\n    }\r\n\r\n    TransformStreamDefaultControllerTerminate(this);\r\n  }\r\n}\r\n\r\n// Transform Stream Default Controller Abstract Operations\r\n\r\nfunction IsTransformStreamDefaultController(x) {\r\n  if (!typeIsObject(x)) {\r\n    return false;\r\n  }\r\n\r\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\r\n  assert(IsTransformStream(stream) === true);\r\n  assert(stream._transformStreamController === undefined);\r\n\r\n  controller._controlledTransformStream = stream;\r\n  stream._transformStreamController = controller;\r\n\r\n  controller._transformAlgorithm = transformAlgorithm;\r\n  controller._flushAlgorithm = flushAlgorithm;\r\n}\r\n\r\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\r\n  assert(transformer !== undefined);\r\n\r\n  const controller = Object.create(TransformStreamDefaultController.prototype);\r\n\r\n  let transformAlgorithm = chunk => {\r\n    try {\r\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\r\n      return Promise.resolve();\r\n    } catch (transformResultE) {\r\n      return Promise.reject(transformResultE);\r\n    }\r\n  };\r\n  const transformMethod = transformer.transform;\r\n  if (transformMethod !== undefined) {\r\n    if (typeof transformMethod !== 'function') {\r\n      throw new TypeError('transform is not a method');\r\n    }\r\n    transformAlgorithm = chunk => {\r\n      const transformPromise = PromiseCall(transformMethod, transformer, [chunk, controller]);\r\n      return transformPromise.catch(e => {\r\n        TransformStreamError(stream, e);\r\n        throw e;\r\n      });\r\n    };\r\n  }\r\n\r\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\r\n\r\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\r\n}\r\n\r\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\r\n  verbose('TransformStreamDefaultControllerEnqueue()');\r\n\r\n  const stream = controller._controlledTransformStream;\r\n  const readableController = stream._readable._readableStreamController;\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\r\n    throw new TypeError('Readable side is not in a state that permits enqueue');\r\n  }\r\n\r\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\r\n  // accept TransformStreamDefaultControllerEnqueue() calls.\r\n\r\n  try {\r\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\r\n  } catch (e) {\r\n    // This happens when readableStrategy.size() throws.\r\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\r\n\r\n    throw stream._readable._storedError;\r\n  }\r\n\r\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\r\n  if (backpressure !== stream._backpressure) {\r\n    assert(backpressure === true);\r\n    TransformStreamSetBackpressure(stream, true);\r\n  }\r\n}\r\n\r\nfunction TransformStreamDefaultControllerError(controller, e) {\r\n  TransformStreamError(controller._controlledTransformStream, e);\r\n}\r\n\r\nfunction TransformStreamDefaultControllerTerminate(controller) {\r\n  verbose('TransformStreamDefaultControllerTerminate()');\r\n\r\n  const stream = controller._controlledTransformStream;\r\n  const readableController = stream._readable._readableStreamController;\r\n\r\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\r\n    ReadableStreamDefaultControllerClose(readableController);\r\n  }\r\n\r\n  const error = new TypeError('TransformStream terminated');\r\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\r\n}\r\n\r\n// TransformStreamDefaultSink Algorithms\r\n\r\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\r\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\r\n\r\n  assert(stream._writable._state === 'writable');\r\n\r\n  const controller = stream._transformStreamController;\r\n\r\n  if (stream._backpressure === true) {\r\n    const backpressureChangePromise = stream._backpressureChangePromise;\r\n    assert(backpressureChangePromise !== undefined);\r\n    return backpressureChangePromise\r\n        .then(() => {\r\n          const writable = stream._writable;\r\n          const state = writable._state;\r\n          if (state === 'erroring') {\r\n            throw writable._storedError;\r\n          }\r\n          assert(state === 'writable');\r\n          return controller._transformAlgorithm(chunk);\r\n        });\r\n  }\r\n\r\n  return controller._transformAlgorithm(chunk);\r\n}\r\n\r\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\r\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\r\n  // errored.\r\n  TransformStreamError(stream, reason);\r\n  return Promise.resolve();\r\n}\r\n\r\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\r\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\r\n\r\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\r\n  const readable = stream._readable;\r\n\r\n  const flushPromise = stream._transformStreamController._flushAlgorithm();\r\n  // Return a promise that is fulfilled with undefined on success.\r\n  return flushPromise.then(() => {\r\n    if (readable._state === 'errored') {\r\n      throw readable._storedError;\r\n    }\r\n    const readableController = readable._readableStreamController;\r\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\r\n      ReadableStreamDefaultControllerClose(readableController);\r\n    }\r\n  }).catch(r => {\r\n    TransformStreamError(stream, r);\r\n    throw readable._storedError;\r\n  });\r\n}\r\n\r\n// TransformStreamDefaultSource Algorithms\r\n\r\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\r\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\r\n\r\n  // Invariant. Enforced by the promises returned by start() and pull().\r\n  assert(stream._backpressure === true);\r\n\r\n  assert(stream._backpressureChangePromise !== undefined);\r\n\r\n  TransformStreamSetBackpressure(stream, false);\r\n\r\n  // Prevent the next pull() call until there is backpressure.\r\n  return stream._backpressureChangePromise;\r\n}\r\n\r\nmodule.exports = { CreateTransformStream, TransformStream };\r\n\r\n// Helper functions for the TransformStreamDefaultController.\r\n\r\nfunction defaultControllerBrandCheckException(name) {\r\n  return new TypeError(\r\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\r\n}\r\n\r\n// Helper functions for the TransformStream.\r\n\r\nfunction streamBrandCheckException(name) {\r\n  return new TypeError(\r\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\r\n}\r\n"],"names":["NumberIsInteger","Number","isInteger","value","isFinite","Math","floor","FakeSymbol","Symbol","iterator","description","noop","NumberIsNaN","isNaN","x","isFakeDetached","Call","F","V","args","TypeError","Function","prototype","apply","call","PromiseCall","Promise","resolve","reject","exports","o","p","v","Object","defineProperty","writable","enumerable","configurable","elements","slice","dest","destOffset","src","srcOffset","n","Uint8Array","set","done","obj","IsNonNegativeNumber","Infinity","Number.isNaN","underlyingObject","methodName","algoArgCount","extraArgs","method","undefined","arg","fullArgs","concat","O","P","transferredIshVersion","get","highWaterMark","RangeError","size","chunk","assert","AssertionError","e","setTimeout","IsFiniteNonNegativeNumber","require$$0","container","pair","_queue","shift","_queueTotalSize","push","verbose","CreateAlgorithmFromUnderlyingMethod","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","typeIsObject","require$$1","rethrowAssertionErrorRejection","require$$2","DequeueValue","EnqueueValueWithSize","PeekQueueValue","ResetQueue","require$$3","AbortSteps","ErrorSteps","WritableStream","[object Object]","underlyingSink","InitializeWritableStream","this","type","sizeAlgorithm","SetUpWritableStreamDefaultControllerFromUnderlyingSink","locked","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","reason","WritableStreamAbort","AcquireWritableStreamDefaultWriter","CreateWritableStream","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultWriterCloseWithErrorPropagation","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamCloseQueuedOrInFlight","stream","WritableStreamDefaultWriter","startAlgorithm","writeAlgorithm","closeAlgorithm","abortAlgorithm","create","SetUpWritableStreamDefaultController","WritableStreamDefaultController","_state","_storedError","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","state","_promise","wasAlreadyErroring","promise","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","WritableStreamAddWriteRequest","writeRequest","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","controller","writer","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","_started","storedError","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","then","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamFinishInFlightClose","defaultWriterClosedPromiseResolve","WritableStreamFinishInFlightCloseWithError","WritableStreamMarkCloseRequestInFlight","WritableStreamMarkFirstWriteRequestInFlight","defaultWriterClosedPromiseReject","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseReset","defaultWriterReadyPromiseResolve","_ownerWritableStream","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","_readyPromise","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseInitializeAsRejected","closed","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","desiredSize","defaultWriterLockException","WritableStreamDefaultWriterGetDesiredSize","ready","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","closeRequest","WritableStreamDefaultControllerClose","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","WritableStreamDefaultControllerGetDesiredSize","releasedError","chunkSize","WritableStreamDefaultControllerGetChunkSize","WritableStreamDefaultControllerWrite","IsWritableStreamDefaultController","_controlledWritableStream","WritableStreamDefaultControllerError","_abortAlgorithm","_strategySizeAlgorithm","_strategyHWM","_writeAlgorithm","_closeAlgorithm","WritableStreamDefaultControllerGetBackpressure","startResult","WritableStreamDefaultControllerAdvanceQueueIfNeeded","r","chunkSizeE","writeRecord","enqueueE","length","WritableStreamDefaultControllerProcessClose","WritableStreamDefaultControllerProcessWrite","name","_closedPromise_resolve","_closedPromise_reject","_readyPromise_resolve","_readyPromise_reject","ArrayBufferCopy","CreateIterResultObject","IsDetachedBuffer","TransferArrayBuffer","createArrayFromList","CancelSteps","PullSteps","ReadableStream","underlyingSource","InitializeReadableStream","String","SetUpReadableByteStreamControllerFromUnderlyingSource","SetUpReadableStreamDefaultControllerFromUnderlyingSource","IsReadableStream","IsReadableStreamLocked","ReadableStreamCancel","mode","AcquireReadableStreamDefaultReader","AcquireReadableStreamBYOBReader","readable","options","ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue","pipeTo","preventClose","preventAbort","preventCancel","Boolean","reader","shuttingDown","currentWrite","isOrBecomesErrored","shutdownWithAction","shutdown","action","isOrBecomesClosed","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","ReadableStreamReaderGenericRelease","pipeLoop","ReadableStreamDefaultReaderRead","err","branches","ReadableStreamTee","CreateReadableByteStream","CreateReadableStream","IsReadableStreamDisturbed","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerHasBackpressure","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamBYOBReader","ReadableStreamDefaultReader","pullAlgorithm","cancelAlgorithm","SetUpReadableStreamDefaultController","ReadableStreamDefaultController","autoAllocateChunkSize","SetUpReadableByteStreamController","ReadableByteStreamController","_reader","_disturbed","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","closedOrErrored","canceled1","canceled2","cancelPromise","result","_readableStreamController","value1","value2","compositeReason","cancelResult","ReadableStreamAddReadIntoRequest","readIntoRequest","_readIntoRequests","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamClose","IsReadableStreamDefaultReader","defaultReaderClosedPromiseResolve","ReadableStreamError","defaultReaderClosedPromiseReject","ReadableStreamFulfillReadIntoRequest","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","IsReadableStreamBYOBReader","ReadableStreamHasDefaultReader","ReadableStreamReaderGenericInitialize","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","ReadableStreamBYOBReaderRead","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","defaultReaderClosedPromiseResetToRejected","ReadableByteStreamControllerPullInto","IsReadableStreamDefaultController","defaultControllerBrandCheckException","_cancelAlgorithm","_controlledReadableStream","_closeRequested","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","ReadableStreamDefaultControllerShouldCallPull","_pulling","_pullAlgorithm","_pullAgain","ReadableStreamBYOBRequest","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","bytesWritten","_associatedReadableByteStreamController","ReadableByteStreamControllerRespond","ReadableByteStreamControllerRespondWithNewView","byobRequest","byteStreamControllerBrandCheckException","_byobRequest","_pendingPullIntos","firstDescriptor","byteOffset","bytesFilled","SetUpReadableStreamBYOBRequest","ReadableByteStreamControllerGetDesiredSize","_controlledReadableByteStream","ReadableByteStreamControllerClose","ReadableByteStreamControllerEnqueue","ReadableByteStreamControllerError","entry","ReadableByteStreamControllerHandleQueueDrain","viewE","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","elementSize","ctor","readerType","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","ReadableByteStreamControllerEnqueueChunkToQueue","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerShiftPendingPullInto","constructor","DataView","BYTES_PER_ELEMENT","emptyView","ReadableByteStreamControllerRespondInClosedState","ReadableByteStreamControllerRespondInReadableState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInternal","descriptor","transferredBuffer","underlyingByteSource","Number.isInteger","request","createDataProperty","ByteLengthQueuingStrategy","CountQueuingStrategy","TransformStream","transformer","writableStrategy","readableStrategy","readableType","writableType","writableSizeFunction","writableSizeAlgorithm","writableHighWaterMark","readableSizeFunction","readableSizeAlgorithm","startPromise_resolve","readableHighWaterMark","InitializeTransformStream","SetUpTransformStreamDefaultControllerFromTransformer","_transformStreamController","IsTransformStream","_readable","_writable","CreateTransformStream","transformAlgorithm","flushAlgorithm","SetUpTransformStreamDefaultController","TransformStreamDefaultController","startPromise","TransformStreamDefaultSinkWriteAlgorithm","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise","_backpressureChangePromise_resolve","TransformStreamSetBackpressure","TransformStreamError","IsTransformStreamDefaultController","readableController","_controlledTransformStream","TransformStreamDefaultControllerEnqueue","TransformStreamDefaultControllerError","TransformStreamDefaultControllerTerminate","_transformAlgorithm","_flushAlgorithm","transformResultE","transformMethod","transform"],"mappings":"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"}